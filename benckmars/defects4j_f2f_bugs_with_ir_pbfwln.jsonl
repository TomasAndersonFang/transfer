{"bug_id": "Compress-35", "buggy_code": "1     public static boolean verifyCheckSum(byte[] header) {\n2         long storedSum = 0;\n3         long unsignedSum = 0;\n4         long signedSum = 0;\n5         int digits = 0;\n6         for (int i = 0; i < header.length; i++) {\n7             byte b = header[i];\n8             if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n9                 if ('0' <= b && b <= '7' && digits++ < 6) {\n10                     storedSum = storedSum * 8 + b - '0';\n11                 } else if (digits > 0) {\n12                     digits = 6;\n13                 }\n14                 b = ' ';\n15             }\n16             unsignedSum += 0xff & b;\n17             signedSum += b;\n18         }\n19         return storedSum == unsignedSum || storedSum == signedSum;\n20     }\n", "fixed_code": "    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\n        long unsignedSum = 0;\n        long signedSum = 0;\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n        return storedSum == unsignedSum || storedSum == signedSum;\n    }\n"}
{"bug_id": "JacksonCore-21", "buggy_code": "1     public JsonToken nextToken() throws IOException\n2     {\n3         if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n4                 if (_currToken.isStructEnd()) {\n5                     if (_headContext.isStartHandled()) {\n6                         return (_currToken = null);\n7                     }\n8                 } else if (_currToken.isScalarValue()) {\n9                     if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n10                         return (_currToken = null);\n11                     }\n12             }\n13         }\n14         TokenFilterContext ctxt = _exposedContext;\n15         if (ctxt != null) {\n16             while (true) {\n17                 JsonToken t = ctxt.nextTokenToRead();\n18                 if (t != null) {\n19                     _currToken = t;\n20                     return t;\n21                 }\n22                 if (ctxt == _headContext) {\n23                     _exposedContext = null;\n24                     if (ctxt.inArray()) {\n25                         t = delegate.getCurrentToken();\n26                         _currToken = t;\n27                         return t;\n28                     }\n29                     break;\n30                 }\n31                 ctxt = _headContext.findChildOf(ctxt);\n32                 _exposedContext = ctxt;\n33                 if (ctxt == null) { \n34                     throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n35                 }\n36             }\n37         }\n38         JsonToken t = delegate.nextToken();\n39         if (t == null) {\n40             _currToken = t;\n41             return t;\n42         }\n43         TokenFilter f;\n44         switch (t.id()) {\n45         case ID_START_ARRAY:\n46             f = _itemFilter;\n47             if (f == TokenFilter.INCLUDE_ALL) {\n48                 _headContext = _headContext.createChildArrayContext(f, true);\n49                 return (_currToken = t);\n50             }\n51             if (f == null) { \n52                 delegate.skipChildren();\n53                 break;\n54             }\n55             f = _headContext.checkValue(f);\n56             if (f == null) {\n57                 delegate.skipChildren();\n58                 break;\n59             }\n60             if (f != TokenFilter.INCLUDE_ALL) {\n61                 f = f.filterStartArray();\n62             }\n63             _itemFilter = f;\n64             if (f == TokenFilter.INCLUDE_ALL) {\n65                 _headContext = _headContext.createChildArrayContext(f, true);\n66                 return (_currToken = t);\n67             }\n68             _headContext = _headContext.createChildArrayContext(f, false);\n69             if (_includePath) {\n70                 t = _nextTokenWithBuffering(_headContext);\n71                 if (t != null) {\n72                     _currToken = t;\n73                     return t;\n74                 }\n75             }\n76             break;\n77         case ID_START_OBJECT:\n78             f = _itemFilter;\n79             if (f == TokenFilter.INCLUDE_ALL) {\n80                 _headContext = _headContext.createChildObjectContext(f, true);\n81                 return (_currToken = t);\n82             }\n83             if (f == null) { \n84                 delegate.skipChildren();\n85                 break;\n86             }\n87             f = _headContext.checkValue(f);\n88             if (f == null) {\n89                 delegate.skipChildren();\n90                 break;\n91             }\n92             if (f != TokenFilter.INCLUDE_ALL) {\n93                 f = f.filterStartObject();\n94             }\n95             _itemFilter = f;\n96             if (f == TokenFilter.INCLUDE_ALL) {\n97                 _headContext = _headContext.createChildObjectContext(f, true);\n98                 return (_currToken = t);\n99             }\n100             _headContext = _headContext.createChildObjectContext(f, false);\n101             if (_includePath) {\n102                 t = _nextTokenWithBuffering(_headContext);\n103                 if (t != null) {\n104                     _currToken = t;\n105                     return t;\n106                 }\n107             }\n108             break;\n109         case ID_END_ARRAY:\n110         case ID_END_OBJECT:\n111             {\n112                 boolean returnEnd = _headContext.isStartHandled();\n113                 f = _headContext.getFilter();\n114                 if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n115                     f.filterFinishArray();\n116                 }\n117                 _headContext = _headContext.getParent();\n118                 _itemFilter = _headContext.getFilter();\n119                 if (returnEnd) {\n120                     return (_currToken = t);\n121                 }\n122             }\n123             break;\n124         case ID_FIELD_NAME:\n125             {\n126                 final String name = delegate.getCurrentName();\n127                 f = _headContext.setFieldName(name);\n128                 if (f == TokenFilter.INCLUDE_ALL) {\n129                     _itemFilter = f;\n130                     if (!_includePath) {\n131                         if (_includeImmediateParent && !_headContext.isStartHandled()) {\n132                             t = _headContext.nextTokenToRead(); \n133                             _exposedContext = _headContext;\n134                         }\n135                     }\n136                     return (_currToken = t);\n137                 }\n138                 if (f == null) {\n139                     delegate.nextToken();\n140                     delegate.skipChildren();\n141                     break;\n142                 }\n143                 f = f.includeProperty(name);\n144                 if (f == null) {\n145                     delegate.nextToken();\n146                     delegate.skipChildren();\n147                     break;\n148                 }\n149                 _itemFilter = f;\n150                 if (f == TokenFilter.INCLUDE_ALL) {\n151                     if (_includePath) {\n152                         return (_currToken = t);\n153                     }\n154                 }\n155                 if (_includePath) {\n156                     t = _nextTokenWithBuffering(_headContext);\n157                     if (t != null) {\n158                         _currToken = t;\n159                         return t;\n160                     }\n161                 }\n162                 break;\n163             }\n164         default: \n165             f = _itemFilter;\n166             if (f == TokenFilter.INCLUDE_ALL) {\n167                 return (_currToken = t);\n168             }\n169             if (f != null) {\n170                 f = _headContext.checkValue(f);\n171                 if ((f == TokenFilter.INCLUDE_ALL)\n172                         || ((f != null) && f.includeValue(delegate))) {\n173                     return (_currToken = t);\n174                 }\n175             }\n176             break;\n177         }\n178         return _nextToken2();\n179     }\n", "fixed_code": "    public JsonToken nextToken() throws IOException\n    {\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            if (!_includePath) {\n                if (_currToken.isStructEnd()) {\n                    if (_headContext.isStartHandled()) {\n                        return (_currToken = null);\n                    }\n                } else if (_currToken.isScalarValue()) {\n                    if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                        return (_currToken = null);\n                    }\n                }\n            }\n        }\n        TokenFilterContext ctxt = _exposedContext;\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n                        _currToken = t;\n                        return t;\n                    }\n                    break;\n                }\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { \n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            _currToken = t;\n            return t;\n        }\n        TokenFilter f;\n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { \n                delegate.skipChildren();\n                break;\n            }\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { \n                delegate.skipChildren();\n                break;\n            }\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); \n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n        default: \n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n        }\n        return _nextToken2();\n    }\n"}
{"bug_id": "Lang-5", "buggy_code": "1     public static Locale toLocale(final String str) {\n2         if (str == null) {\n3             return null;\n4         }\n5         final int len = str.length();\n6         if (len < 2) {\n7             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n8         }\n9         final char ch0 = str.charAt(0);\n10             final char ch1 = str.charAt(1);\n11             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n12                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n13             }\n14             if (len == 2) {\n15                 return new Locale(str);\n16             }\n17             if (len < 5) {\n18                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n19             }\n20             if (str.charAt(2) != '_') {\n21                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n22             }\n23             final char ch3 = str.charAt(3);\n24             if (ch3 == '_') {\n25                 return new Locale(str.substring(0, 2), \"\", str.substring(4));\n26             }\n27             final char ch4 = str.charAt(4);\n28             if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n29                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n30             }\n31             if (len == 5) {\n32                 return new Locale(str.substring(0, 2), str.substring(3, 5));\n33             }\n34             if (len < 7) {\n35                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n36             }\n37             if (str.charAt(5) != '_') {\n38                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n39             }\n40             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n41     }\n", "fixed_code": "    public static Locale toLocale(final String str) {\n        if (str == null) {\n            return null;\n        }\n        final int len = str.length();\n        if (len < 2) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch0 = str.charAt(0);\n        if (ch0 == '_') {\n            if (len < 3) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            final char ch1 = str.charAt(1);\n            final char ch2 = str.charAt(2);\n            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 3) {\n                return new Locale(\"\", str.substring(1, 3));\n            }\n            if (len < 5) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(3) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(\"\", str.substring(1, 3), str.substring(4));\n        } else {\n            final char ch1 = str.charAt(1);\n            if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 2) {\n                return new Locale(str);\n            }\n            if (len < 5) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(2) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            final char ch3 = str.charAt(3);\n            if (ch3 == '_') {\n                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n            }\n            final char ch4 = str.charAt(4);\n            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 5) {\n                return new Locale(str.substring(0, 2), str.substring(3, 5));\n            }\n            if (len < 7) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(5) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        }\n    }\n"}
{"bug_id": "Codec-17", "buggy_code": "1     public static String newStringIso8859_1(final byte[] bytes) {\n2         return new String(bytes, Charsets.ISO_8859_1);\n3     }\n", "fixed_code": "    public static String newStringIso8859_1(final byte[] bytes) {\n        return newString(bytes, Charsets.ISO_8859_1);\n    }\n"}
{"bug_id": "Compress-12", "buggy_code": "1     public TarArchiveEntry getNextTarEntry() throws IOException {\n2         if (hasHitEOF) {\n3             return null;\n4         }\n5         if (currEntry != null) {\n6             long numToSkip = entrySize - entryOffset;\n7             while (numToSkip > 0) {\n8                 long skipped = skip(numToSkip);\n9                 if (skipped <= 0) {\n10                     throw new RuntimeException(\"failed to skip current tar entry\");\n11                 }\n12                 numToSkip -= skipped;\n13             }\n14             readBuf = null;\n15         }\n16         byte[] headerBuf = getRecord();\n17         if (hasHitEOF) {\n18             currEntry = null;\n19             return null;\n20         }\n21         currEntry = new TarArchiveEntry(headerBuf);\n22         entryOffset = 0;\n23         entrySize = currEntry.getSize();\n24         if (currEntry.isGNULongNameEntry()) {\n25             StringBuffer longName = new StringBuffer();\n26             byte[] buf = new byte[SMALL_BUFFER_SIZE];\n27             int length = 0;\n28             while ((length = read(buf)) >= 0) {\n29                 longName.append(new String(buf, 0, length));\n30             }\n31             getNextEntry();\n32             if (currEntry == null) {\n33                 return null;\n34             }\n35             if (longName.length() > 0\n36                 && longName.charAt(longName.length() - 1) == 0) {\n37                 longName.deleteCharAt(longName.length() - 1);\n38             }\n39             currEntry.setName(longName.toString());\n40         }\n41         if (currEntry.isPaxHeader()){ \n42             paxHeaders();\n43         }\n44         if (currEntry.isGNUSparse()){ \n45             readGNUSparse();\n46         }\n47         entrySize = currEntry.getSize();\n48         return currEntry;\n49     }\n", "fixed_code": "    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n            readBuf = null;\n        }\n        byte[] headerBuf = getRecord();\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n        try {\n            currEntry = new TarArchiveEntry(headerBuf);\n        } catch (IllegalArgumentException e) {\n            IOException ioe = new IOException(\"Error detected parsing the header\");\n            ioe.initCause(e);\n            throw ioe;\n        }\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n        if (currEntry.isGNULongNameEntry()) {\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                return null;\n            }\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n        if (currEntry.isPaxHeader()){ \n            paxHeaders();\n        }\n        if (currEntry.isGNUSparse()){ \n            readGNUSparse();\n        }\n        entrySize = currEntry.getSize();\n        return currEntry;\n    }\n"}
{"bug_id": "Lang-31", "buggy_code": "1 \tpublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n2 \t\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n3 \t\t\treturn false;\n4 \t\t}\n5 \t\tint csLength = cs.length();\n6 \t\tint searchLength = searchChars.length;\n7 \t\tfor (int i = 0; i < csLength; i++) {\n8 \t\t\tchar ch = cs.charAt(i);\n9 \t\t\tfor (int j = 0; j < searchLength; j++) {\n10 \t\t\t\tif (searchChars[j] == ch) {\n11 \t\t\t\t\t\treturn true;\n12 \t\t\t\t}\n13 \t\t\t}\n14 \t\t}\n15 \t\treturn false;\n16 \t}\n", "fixed_code": "\tpublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\t\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\t\treturn false;\n\t\t}\n\t\tint csLength = cs.length();\n\t\tint searchLength = searchChars.length;\n\t\tint csLastIndex = csLength - 1;\n\t\tint searchLastIndex = searchLength - 1;\n\t\tfor (int i = 0; i < csLength; i++) {\n\t\t\tchar ch = cs.charAt(i);\n\t\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\tif (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n\t\t\t\t\t\tif (searchChars[j + 1] == cs.charAt(i + 1)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n"}
{"bug_id": "Closure-116", "buggy_code": "1   private CanInlineResult canInlineReferenceDirectly(\n2       Node callNode, Node fnNode) {\n3     if (!isDirectCallNodeReplacementPossible(fnNode)) {\n4       return CanInlineResult.NO;\n5     }\n6     Node block = fnNode.getLastChild();\n7     Node cArg = callNode.getFirstChild().getNext();\n8     if (!callNode.getFirstChild().isName()) {\n9       if (NodeUtil.isFunctionObjectCall(callNode)) {\n10         if (cArg == null || !cArg.isThis()) {\n11           return CanInlineResult.NO;\n12         }\n13         cArg = cArg.getNext();\n14       } else {\n15         Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n16       }\n17     }\n18     Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n19     while (cArg != null || fnParam != null) {\n20       if (fnParam != null) {\n21         if (cArg != null) {\n22           if (NodeUtil.mayEffectMutableState(cArg, compiler)\n23               && NodeUtil.getNameReferenceCount(\n24                   block, fnParam.getString()) > 1) {\n25             return CanInlineResult.NO;\n26           }\n27         }\n28         fnParam = fnParam.getNext();\n29       }\n30       if (cArg != null) {\n31         if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n32           return CanInlineResult.NO;\n33         }\n34         cArg = cArg.getNext();\n35       }\n36     }\n37     return CanInlineResult.YES;\n38   }\n", "fixed_code": "  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n    Node block = fnNode.getLastChild();\n    boolean hasSideEffects = false;  \n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(\n            stmt.getFirstChild(), compiler);\n      }\n    }\n    Node cArg = callNode.getFirstChild().getNext();\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      if (fnParam != null) {\n        if (cArg != null) {\n          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n        fnParam = fnParam.getNext();\n      }\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n    return CanInlineResult.YES;\n  }\n"}
{"bug_id": "Mockito-18", "buggy_code": "1     Object returnValueFor(Class<?> type) {\n2         if (Primitives.isPrimitiveOrWrapper(type)) {\n3             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n4         } else if (type == Collection.class) {\n5             return new LinkedList<Object>();\n6         } else if (type == Set.class) {\n7             return new HashSet<Object>();\n8         } else if (type == HashSet.class) {\n9             return new HashSet<Object>();\n10         } else if (type == SortedSet.class) {\n11             return new TreeSet<Object>();\n12         } else if (type == TreeSet.class) {\n13             return new TreeSet<Object>();\n14         } else if (type == LinkedHashSet.class) {\n15             return new LinkedHashSet<Object>();\n16         } else if (type == List.class) {\n17             return new LinkedList<Object>();\n18         } else if (type == LinkedList.class) {\n19             return new LinkedList<Object>();\n20         } else if (type == ArrayList.class) {\n21             return new ArrayList<Object>();\n22         } else if (type == Map.class) {\n23             return new HashMap<Object, Object>();\n24         } else if (type == HashMap.class) {\n25             return new HashMap<Object, Object>();\n26         } else if (type == SortedMap.class) {\n27             return new TreeMap<Object, Object>();\n28         } else if (type == TreeMap.class) {\n29             return new TreeMap<Object, Object>();\n30         } else if (type == LinkedHashMap.class) {\n31             return new LinkedHashMap<Object, Object>();\n32         }\n33         return null;\n34     }\n", "fixed_code": "    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        } else if (type == Iterable.class) {\n            return new ArrayList<Object>(0);\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }\n        return null;\n    }\n"}
{"bug_id": "Time-7", "buggy_code": "1     public int parseInto(ReadWritableInstant instant, String text, int position) {\n2         DateTimeParser parser = requireParser();\n3         if (instant == null) {\n4             throw new IllegalArgumentException(\"Instant must not be null\");\n5         }\n6         long instantMillis = instant.getMillis();\n7         Chronology chrono = instant.getChronology();\n8         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n9         chrono = selectChronology(chrono);\n10         int defaultYear = chrono.year().get(instantLocal);\n11         DateTimeParserBucket bucket = new DateTimeParserBucket(\n12             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n13         int newPos = parser.parseInto(bucket, text, position);\n14         instant.setMillis(bucket.computeMillis(false, text));\n15         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n16             int parsedOffset = bucket.getOffsetInteger();\n17             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n18             chrono = chrono.withZone(parsedZone);\n19         } else if (bucket.getZone() != null) {\n20             chrono = chrono.withZone(bucket.getZone());\n21         }\n22         instant.setChronology(chrono);\n23         if (iZone != null) {\n24             instant.setZone(iZone);\n25         }\n26         return newPos;\n27     }\n", "fixed_code": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n"}
{"bug_id": "Closure-18", "buggy_code": "1   Node parseInputs() {\n2     boolean devMode = options.devMode != DevMode.OFF;\n3     if (externsRoot != null) {\n4       externsRoot.detachChildren();\n5     }\n6     if (jsRoot != null) {\n7       jsRoot.detachChildren();\n8     }\n9     jsRoot = IR.block();\n10     jsRoot.setIsSyntheticBlock(true);\n11     externsRoot = IR.block();\n12     externsRoot.setIsSyntheticBlock(true);\n13     externAndJsRoot = IR.block(externsRoot, jsRoot);\n14     externAndJsRoot.setIsSyntheticBlock(true);\n15     if (options.tracer.isOn()) {\n16       tracker = new PerformanceTracker(jsRoot, options.tracer);\n17       addChangeHandler(tracker.getCodeChangeHandler());\n18     }\n19     Tracer tracer = newTracer(\"parseInputs\");\n20     try {\n21       for (CompilerInput input : externs) {\n22         Node n = input.getAstRoot(this);\n23         if (hasErrors()) {\n24           return null;\n25         }\n26         externsRoot.addChildToBack(n);\n27       }\n28       if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n29         processAMDAndCommonJSModules();\n30       }\n31       hoistExterns(externsRoot);\n32       boolean staleInputs = false;\n33       if (options.dependencyOptions.needsManagement() && options.closurePass) {\n34         for (CompilerInput input : inputs) {\n35           for (String provide : input.getProvides()) {\n36             getTypeRegistry().forwardDeclareType(provide);\n37           }\n38         }\n39         try {\n40           inputs =\n41               (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n42               .manageDependencies(options.dependencyOptions, inputs);\n43           staleInputs = true;\n44         } catch (CircularDependencyException e) {\n45           report(JSError.make(\n46               JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n47           if (hasErrors()) {\n48             return null;\n49           }\n50         } catch (MissingProvideException e) {\n51           report(JSError.make(\n52               MISSING_ENTRY_ERROR, e.getMessage()));\n53           if (hasErrors()) {\n54             return null;\n55           }\n56         }\n57       }\n58       hoistNoCompileFiles();\n59       if (staleInputs) {\n60         repartitionInputs();\n61       }\n62       for (CompilerInput input : inputs) {\n63         Node n = input.getAstRoot(this);\n64         if (n == null) {\n65           continue;\n66         }\n67         if (devMode) {\n68           runSanityCheck();\n69           if (hasErrors()) {\n70             return null;\n71           }\n72         }\n73         if (options.sourceMapOutputPath != null ||\n74             options.nameReferenceReportPath != null) {\n75           SourceInformationAnnotator sia =\n76               new SourceInformationAnnotator(\n77                   input.getName(), options.devMode != DevMode.OFF);\n78           NodeTraversal.traverse(this, n, sia);\n79         }\n80         jsRoot.addChildToBack(n);\n81       }\n82       if (hasErrors()) {\n83         return null;\n84       }\n85       return externAndJsRoot;\n86     } finally {\n87       stopTracer(tracer, \"parseInputs\");\n88     }\n89   }\n", "fixed_code": "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n      hoistExterns(externsRoot);\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement()) {\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      hoistNoCompileFiles();\n      if (staleInputs) {\n        repartitionInputs();\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n        jsRoot.addChildToBack(n);\n      }\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n"}
{"bug_id": "JacksonDatabind-17", "buggy_code": "1         public boolean useForType(JavaType t)\n2         {\n3             switch (_appliesFor) {\n4             case NON_CONCRETE_AND_ARRAYS:\n5                 while (t.isArrayType()) {\n6                     t = t.getContentType();\n7                 }\n8             case OBJECT_AND_NON_CONCRETE:\n9                 return (t.getRawClass() == Object.class)\n10                         || (!t.isConcrete()\n11                         || TreeNode.class.isAssignableFrom(t.getRawClass()));\n12             case NON_FINAL:\n13                 while (t.isArrayType()) {\n14                     t = t.getContentType();\n15                 }\n16                 return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n17             default:\n18                 return (t.getRawClass() == Object.class);\n19             }\n20         }\n", "fixed_code": "        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n            case OBJECT_AND_NON_CONCRETE:\n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n                return (t.getRawClass() == Object.class);\n            }\n        }\n"}
{"bug_id": "Math-52", "buggy_code": "1   public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n2   double u1u1 = u1.getNormSq();\n3   double u2u2 = u2.getNormSq();\n4   double v1v1 = v1.getNormSq();\n5   double v2v2 = v2.getNormSq();\n6   if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n7     throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n8   }\n9   v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n10   double u1u2   = u1.dotProduct(u2);\n11   double v1v2   = v1.dotProduct(v2);\n12   double coeffU = u1u2 / u1u1;\n13   double coeffV = v1v2 / u1u1;\n14   double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n15   double alpha  = coeffU - beta * coeffV;\n16   v2 = new Vector3D(alpha, v1, beta, v2);\n17   Vector3D uRef  = u1;\n18   Vector3D vRef  = v1;\n19   Vector3D v1Su1 = v1.subtract(u1);\n20   Vector3D v2Su2 = v2.subtract(u2);\n21   Vector3D k     = v1Su1.crossProduct(v2Su2);\n22   Vector3D u3    = u1.crossProduct(u2);\n23   double c       = k.dotProduct(u3);\n24   if (c == 0) {\n25     Vector3D v3 = Vector3D.crossProduct(v1, v2);\n26     Vector3D v3Su3 = v3.subtract(u3);\n27     k = v1Su1.crossProduct(v3Su3);\n28     Vector3D u2Prime = u1.crossProduct(u3);\n29     c = k.dotProduct(u2Prime);\n30     if (c == 0) {\n31       k = v2Su2.crossProduct(v3Su3);;\n32       c = k.dotProduct(u2.crossProduct(u3));;\n33       if (c == 0) {\n34         q0 = 1.0;\n35         q1 = 0.0;\n36         q2 = 0.0;\n37         q3 = 0.0;\n38         return;\n39       }\n40       uRef = u2;\n41       vRef = v2;\n42     }\n43   }\n44   c = FastMath.sqrt(c);\n45   double inv = 1.0 / (c + c);\n46   q1 = inv * k.getX();\n47   q2 = inv * k.getY();\n48   q3 = inv * k.getZ();\n49    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n50                     uRef.getZ() * q1 - uRef.getX() * q3,\n51                     uRef.getX() * q2 - uRef.getY() * q1);\n52   q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n53   }\n", "fixed_code": "  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n  double u1u1 = u1.getNormSq();\n  double u2u2 = u2.getNormSq();\n  double v1v1 = v1.getNormSq();\n  double v2v2 = v2.getNormSq();\n  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n  }\n  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n  double u1u2   = u1.dotProduct(u2);\n  double v1v2   = v1.dotProduct(v2);\n  double coeffU = u1u2 / u1u1;\n  double coeffV = v1v2 / u1u1;\n  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n  double alpha  = coeffU - beta * coeffV;\n  v2 = new Vector3D(alpha, v1, beta, v2);\n  Vector3D uRef  = u1;\n  Vector3D vRef  = v1;\n  Vector3D v1Su1 = v1.subtract(u1);\n  Vector3D v2Su2 = v2.subtract(u2);\n  Vector3D k     = v1Su1.crossProduct(v2Su2);\n  Vector3D u3    = u1.crossProduct(u2);\n  double c       = k.dotProduct(u3);\n  final double inPlaneThreshold = 0.001;\n  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n      if (c <= 0) {\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n      uRef = u2;\n      vRef = v2;\n    }\n  }\n  c = FastMath.sqrt(c);\n  double inv = 1.0 / (c + c);\n  q1 = inv * k.getX();\n  q2 = inv * k.getY();\n  q3 = inv * k.getZ();\n   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n                    uRef.getZ() * q1 - uRef.getX() * q3,\n                    uRef.getX() * q2 - uRef.getY() * q1);\n  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n  }\n"}
{"bug_id": "Chart-8", "buggy_code": "1     public Week(Date time, TimeZone zone) {\n2         this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n3     }\n", "fixed_code": "    public Week(Date time, TimeZone zone) {\n        this(time, zone, Locale.getDefault());\n    }\n"}
{"bug_id": "Chart-11", "buggy_code": "1     public static boolean equal(GeneralPath p1, GeneralPath p2) {\n2         if (p1 == null) {\n3             return (p2 == null);\n4         }\n5         if (p2 == null) {\n6             return false;\n7         }\n8         if (p1.getWindingRule() != p2.getWindingRule()) {\n9             return false;\n10         }\n11         PathIterator iterator1 = p1.getPathIterator(null);\n12         PathIterator iterator2 = p1.getPathIterator(null);\n13         double[] d1 = new double[6];\n14         double[] d2 = new double[6];\n15         boolean done = iterator1.isDone() && iterator2.isDone();\n16         while (!done) {\n17             if (iterator1.isDone() != iterator2.isDone()) {\n18                 return false;\n19             }\n20             int seg1 = iterator1.currentSegment(d1);\n21             int seg2 = iterator2.currentSegment(d2);\n22             if (seg1 != seg2) {\n23                 return false;\n24             }\n25             if (!Arrays.equals(d1, d2)) {\n26                 return false;\n27             }\n28             iterator1.next();\n29             iterator2.next();\n30             done = iterator1.isDone() && iterator2.isDone();\n31         }\n32         return true;\n33     }\n", "fixed_code": "    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n"}
{"bug_id": "Closure-10", "buggy_code": "1   static boolean mayBeString(Node n, boolean recurse) {\n2     if (recurse) {\n3       return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n4     } else {\n5       return mayBeStringHelper(n);\n6     }\n7   }\n", "fixed_code": "  static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    } else {\n      return mayBeStringHelper(n);\n    }\n  }\n"}
{"bug_id": "Jsoup-40", "buggy_code": "1     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n2         super(baseUri);\n3         Validate.notEmpty(name);\n4         attr(\"name\", name);\n5         attr(\"publicId\", publicId);\n6         attr(\"systemId\", systemId);\n7     }\n", "fixed_code": "    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n        attr(\"name\", name);\n        attr(\"publicId\", publicId);\n        attr(\"systemId\", systemId);\n    }\n"}
{"bug_id": "Time-24", "buggy_code": "1     public long computeMillis(boolean resetFields, String text) {\n2         SavedField[] savedFields = iSavedFields;\n3         int count = iSavedFieldsCount;\n4         if (iSavedFieldsShared) {\n5             iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n6             iSavedFieldsShared = false;\n7         }\n8         sort(savedFields, count);\n9         if (count > 0) {\n10             DurationField months = DurationFieldType.months().getField(iChrono);\n11             DurationField days = DurationFieldType.days().getField(iChrono);\n12             DurationField first = savedFields[0].iField.getDurationField();\n13             if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n14                 saveField(DateTimeFieldType.year(), iDefaultYear);\n15                 return computeMillis(resetFields, text);\n16             }\n17         }\n18         long millis = iMillis;\n19         try {\n20             for (int i = 0; i < count; i++) {\n21                 millis = savedFields[i].set(millis, resetFields);\n22             }\n23         } catch (IllegalFieldValueException e) {\n24             if (text != null) {\n25                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n26             }\n27             throw e;\n28         }\n29         if (iZone == null) {\n30             millis -= iOffset;\n31         } else {\n32             int offset = iZone.getOffsetFromLocal(millis);\n33             millis -= offset;\n34             if (offset != iZone.getOffset(millis)) {\n35                 String message =\n36                     \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n37                 if (text != null) {\n38                     message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n39                 }\n40                 throw new IllegalArgumentException(message);\n41             }\n42         }\n43         return millis;\n44     }\n", "fixed_code": "    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        return millis;\n    }\n"}
{"bug_id": "Cli-26", "buggy_code": "1     public static Option create(String opt) throws IllegalArgumentException\n2     {\n3         Option option = new Option(opt, description);\n4             option.setLongOpt(longopt);\n5             option.setRequired(required);\n6             option.setOptionalArg(optionalArg);\n7             option.setArgs(numberOfArgs);\n8             option.setType(type);\n9             option.setValueSeparator(valuesep);\n10             option.setArgName(argName);\n11             OptionBuilder.reset();\n12         return option;\n13     }\n", "fixed_code": "    public static Option create(String opt) throws IllegalArgumentException\n    {\n        Option option = null;\n        try {\n            option = new Option(opt, description);\n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n        } finally {\n            OptionBuilder.reset();\n        }\n        return option;\n    }\n"}
{"bug_id": "Math-82", "buggy_code": "1     private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n2         double minRatio = Double.MAX_VALUE;\n3         Integer minRatioPos = null;\n4         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n5             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n6             final double entry = tableau.getEntry(i, col);\n7             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n8                 final double ratio = rhs / entry;\n9                 if (ratio < minRatio) {\n10                     minRatio = ratio;\n11                     minRatioPos = i; \n12                 }\n13             }\n14         }\n15         return minRatioPos;\n16     }\n", "fixed_code": "    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n"}
{"bug_id": "JacksonDatabind-82", "buggy_code": "1     protected void addBeanProps(DeserializationContext ctxt,\n2             BeanDescription beanDesc, BeanDeserializerBuilder builder)\n3         throws JsonMappingException\n4     {\n5         final boolean isConcrete = !beanDesc.getType().isAbstract();\n6         final SettableBeanProperty[] creatorProps = isConcrete\n7                 ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n8                 : null;\n9         final boolean hasCreatorProps = (creatorProps != null);\n10         JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n11                 .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n12                         beanDesc.getClassInfo());\n13         Set<String> ignored;\n14         if (ignorals != null) {\n15             boolean ignoreAny = ignorals.getIgnoreUnknown();\n16             builder.setIgnoreUnknownProperties(ignoreAny);\n17             ignored = ignorals.getIgnored();\n18             for (String propName : ignored) {\n19                 builder.addIgnorable(propName);\n20             }\n21         } else {\n22             ignored = Collections.emptySet();\n23         }\n24         AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n25         AnnotatedMember anySetterField = null;\n26         if (anySetterMethod != null) {\n27             builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n28         }\n29         else {\n30         \tanySetterField = beanDesc.findAnySetterField();\n31         \tif(anySetterField != null) {\n32         \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n33         \t}\n34         }\n35         if (anySetterMethod == null && anySetterField == null) {\n36             Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n37             if (ignored2 != null) {\n38                 for (String propName : ignored2) {\n39                     builder.addIgnorable(propName);\n40                 }\n41             }\n42         }\n43         final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n44                 && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n45         List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n46                 beanDesc, builder, beanDesc.findProperties(), ignored);\n47         if (_factoryConfig.hasDeserializerModifiers()) {\n48             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n49                 propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n50             }\n51         }\n52         for (BeanPropertyDefinition propDef : propDefs) {\n53             SettableBeanProperty prop = null;\n54             if (propDef.hasSetter()) {\n55                 JavaType propertyType = propDef.getSetter().getParameterType(0);\n56                 prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n57             } else if (propDef.hasField()) {\n58                 JavaType propertyType = propDef.getField().getType();\n59                 prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n60             } else if (useGettersAsSetters && propDef.hasGetter()) {\n61                 AnnotatedMethod getter = propDef.getGetter();\n62                 Class<?> rawPropertyType = getter.getRawType();\n63                 if (Collection.class.isAssignableFrom(rawPropertyType)\n64                         || Map.class.isAssignableFrom(rawPropertyType)) {\n65                     prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n66                 }\n67             }\n68             if (hasCreatorProps && propDef.hasConstructorParameter()) {\n69                 final String name = propDef.getName();\n70                 CreatorProperty cprop = null;\n71                 if (creatorProps != null) {\n72                     for (SettableBeanProperty cp : creatorProps) {\n73                         if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n74                             cprop = (CreatorProperty) cp;\n75                             break;\n76                         }\n77                     }\n78                 }\n79                 if (cprop == null) {\n80                     List<String> n = new ArrayList<>();\n81                     for (SettableBeanProperty cp : creatorProps) {\n82                         n.add(cp.getName());\n83                     }\n84                     ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n85                             \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n86                             name, n);\n87                     continue;\n88                 }\n89                 if (prop != null) {\n90                     cprop.setFallbackSetter(prop);\n91                 }\n92                 prop = cprop;\n93                 builder.addCreatorProperty(cprop);\n94                 continue;\n95             }\n96             if (prop != null) {\n97                 Class<?>[] views = propDef.findViews();\n98                 if (views == null) {\n99                     if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n100                         views = NO_VIEWS;\n101                     }\n102                 }\n103                 prop.setViews(views);\n104                 builder.addProperty(prop);\n105             }\n106         }\n107     }\n", "fixed_code": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            ignored = ignorals.findIgnoredForDeserialization();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        if (anySetterMethod == null && anySetterField == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasSetter()) {\n                JavaType propertyType = propDef.getSetter().getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                JavaType propertyType = propDef.getField().getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                AnnotatedMethod getter = propDef.getGetter();\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue;\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n"}
{"bug_id": "Jsoup-35", "buggy_code": "1         boolean process(Token t, HtmlTreeBuilder tb) {\n2             switch (t.type) {\n3                 case Character: {\n4                     Token.Character c = t.asCharacter();\n5                     if (c.getData().equals(nullString)) {\n6                         tb.error(this);\n7                         return false;\n8                     } else if (isWhitespace(c)) {\n9                         tb.reconstructFormattingElements();\n10                         tb.insert(c);\n11                     } else {\n12                         tb.reconstructFormattingElements();\n13                         tb.insert(c);\n14                         tb.framesetOk(false);\n15                     }\n16                     break;\n17                 }\n18                 case Comment: {\n19                     tb.insert(t.asComment());\n20                     break;\n21                 }\n22                 case Doctype: {\n23                     tb.error(this);\n24                     return false;\n25                 }\n26                 case StartTag:\n27                     Token.StartTag startTag = t.asStartTag();\n28                     String name = startTag.name();\n29                     if (name.equals(\"html\")) {\n30                         tb.error(this);\n31                         Element html = tb.getStack().getFirst();\n32                         for (Attribute attribute : startTag.getAttributes()) {\n33                             if (!html.hasAttr(attribute.getKey()))\n34                                 html.attributes().put(attribute);\n35                         }\n36                     } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n37                         return tb.process(t, InHead);\n38                     } else if (name.equals(\"body\")) {\n39                         tb.error(this);\n40                         LinkedList<Element> stack = tb.getStack();\n41                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n42                             return false; \n43                         } else {\n44                             tb.framesetOk(false);\n45                             Element body = stack.get(1);\n46                             for (Attribute attribute : startTag.getAttributes()) {\n47                                 if (!body.hasAttr(attribute.getKey()))\n48                                     body.attributes().put(attribute);\n49                             }\n50                         }\n51                     } else if (name.equals(\"frameset\")) {\n52                         tb.error(this);\n53                         LinkedList<Element> stack = tb.getStack();\n54                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n55                             return false; \n56                         } else if (!tb.framesetOk()) {\n57                             return false; \n58                         } else {\n59                             Element second = stack.get(1);\n60                             if (second.parent() != null)\n61                                 second.remove();\n62                             while (stack.size() > 1)\n63                                 stack.removeLast();\n64                             tb.insert(startTag);\n65                             tb.transition(InFrameset);\n66                         }\n67                     } else if (StringUtil.in(name,\n68                             \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n69                             \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n70                             \"p\", \"section\", \"summary\", \"ul\")) {\n71                         if (tb.inButtonScope(\"p\")) {\n72                             tb.process(new Token.EndTag(\"p\"));\n73                         }\n74                         tb.insert(startTag);\n75                     } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n76                         if (tb.inButtonScope(\"p\")) {\n77                             tb.process(new Token.EndTag(\"p\"));\n78                         }\n79                         if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n80                             tb.error(this);\n81                             tb.pop();\n82                         }\n83                         tb.insert(startTag);\n84                     } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n85                         if (tb.inButtonScope(\"p\")) {\n86                             tb.process(new Token.EndTag(\"p\"));\n87                         }\n88                         tb.insert(startTag);\n89                         tb.framesetOk(false);\n90                     } else if (name.equals(\"form\")) {\n91                         if (tb.getFormElement() != null) {\n92                             tb.error(this);\n93                             return false;\n94                         }\n95                         if (tb.inButtonScope(\"p\")) {\n96                             tb.process(new Token.EndTag(\"p\"));\n97                         }\n98                         tb.insertForm(startTag, true);\n99                     } else if (name.equals(\"li\")) {\n100                         tb.framesetOk(false);\n101                         LinkedList<Element> stack = tb.getStack();\n102                         for (int i = stack.size() - 1; i > 0; i--) {\n103                             Element el = stack.get(i);\n104                             if (el.nodeName().equals(\"li\")) {\n105                                 tb.process(new Token.EndTag(\"li\"));\n106                                 break;\n107                             }\n108                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n109                                 break;\n110                         }\n111                         if (tb.inButtonScope(\"p\")) {\n112                             tb.process(new Token.EndTag(\"p\"));\n113                         }\n114                         tb.insert(startTag);\n115                     } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n116                         tb.framesetOk(false);\n117                         LinkedList<Element> stack = tb.getStack();\n118                         for (int i = stack.size() - 1; i > 0; i--) {\n119                             Element el = stack.get(i);\n120                             if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n121                                 tb.process(new Token.EndTag(el.nodeName()));\n122                                 break;\n123                             }\n124                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n125                                 break;\n126                         }\n127                         if (tb.inButtonScope(\"p\")) {\n128                             tb.process(new Token.EndTag(\"p\"));\n129                         }\n130                         tb.insert(startTag);\n131                     } else if (name.equals(\"plaintext\")) {\n132                         if (tb.inButtonScope(\"p\")) {\n133                             tb.process(new Token.EndTag(\"p\"));\n134                         }\n135                         tb.insert(startTag);\n136                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n137                     } else if (name.equals(\"button\")) {\n138                         if (tb.inButtonScope(\"button\")) {\n139                             tb.error(this);\n140                             tb.process(new Token.EndTag(\"button\"));\n141                             tb.process(startTag);\n142                         } else {\n143                             tb.reconstructFormattingElements();\n144                             tb.insert(startTag);\n145                             tb.framesetOk(false);\n146                         }\n147                     } else if (name.equals(\"a\")) {\n148                         if (tb.getActiveFormattingElement(\"a\") != null) {\n149                             tb.error(this);\n150                             tb.process(new Token.EndTag(\"a\"));\n151                             Element remainingA = tb.getFromStack(\"a\");\n152                             if (remainingA != null) {\n153                                 tb.removeFromActiveFormattingElements(remainingA);\n154                                 tb.removeFromStack(remainingA);\n155                             }\n156                         }\n157                         tb.reconstructFormattingElements();\n158                         Element a = tb.insert(startTag);\n159                         tb.pushActiveFormattingElements(a);\n160                     } else if (StringUtil.in(name,\n161                             \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n162                         tb.reconstructFormattingElements();\n163                         Element el = tb.insert(startTag);\n164                         tb.pushActiveFormattingElements(el);\n165                     } else if (name.equals(\"nobr\")) {\n166                         tb.reconstructFormattingElements();\n167                         if (tb.inScope(\"nobr\")) {\n168                             tb.error(this);\n169                             tb.process(new Token.EndTag(\"nobr\"));\n170                             tb.reconstructFormattingElements();\n171                         }\n172                         Element el = tb.insert(startTag);\n173                         tb.pushActiveFormattingElements(el);\n174                     } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n175                         tb.reconstructFormattingElements();\n176                         tb.insert(startTag);\n177                         tb.insertMarkerToFormattingElements();\n178                         tb.framesetOk(false);\n179                     } else if (name.equals(\"table\")) {\n180                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n181                             tb.process(new Token.EndTag(\"p\"));\n182                         }\n183                         tb.insert(startTag);\n184                         tb.framesetOk(false);\n185                         tb.transition(InTable);\n186                     } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n187                         tb.reconstructFormattingElements();\n188                         tb.insertEmpty(startTag);\n189                         tb.framesetOk(false);\n190                     } else if (name.equals(\"input\")) {\n191                         tb.reconstructFormattingElements();\n192                         Element el = tb.insertEmpty(startTag);\n193                         if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n194                             tb.framesetOk(false);\n195                     } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n196                         tb.insertEmpty(startTag);\n197                     } else if (name.equals(\"hr\")) {\n198                         if (tb.inButtonScope(\"p\")) {\n199                             tb.process(new Token.EndTag(\"p\"));\n200                         }\n201                         tb.insertEmpty(startTag);\n202                         tb.framesetOk(false);\n203                     } else if (name.equals(\"image\")) {\n204                         startTag.name(\"img\");\n205                         return tb.process(startTag);\n206                     } else if (name.equals(\"isindex\")) {\n207                         tb.error(this);\n208                         if (tb.getFormElement() != null)\n209                             return false;\n210                         tb.tokeniser.acknowledgeSelfClosingFlag();\n211                         tb.process(new Token.StartTag(\"form\"));\n212                         if (startTag.attributes.hasKey(\"action\")) {\n213                             Element form = tb.getFormElement();\n214                             form.attr(\"action\", startTag.attributes.get(\"action\"));\n215                         }\n216                         tb.process(new Token.StartTag(\"hr\"));\n217                         tb.process(new Token.StartTag(\"label\"));\n218                         String prompt = startTag.attributes.hasKey(\"prompt\") ?\n219                                 startTag.attributes.get(\"prompt\") :\n220                                 \"This is a searchable index. Enter search keywords: \";\n221                         tb.process(new Token.Character(prompt));\n222                         Attributes inputAttribs = new Attributes();\n223                         for (Attribute attr : startTag.attributes) {\n224                             if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n225                                 inputAttribs.put(attr);\n226                         }\n227                         inputAttribs.put(\"name\", \"isindex\");\n228                         tb.process(new Token.StartTag(\"input\", inputAttribs));\n229                         tb.process(new Token.EndTag(\"label\"));\n230                         tb.process(new Token.StartTag(\"hr\"));\n231                         tb.process(new Token.EndTag(\"form\"));\n232                     } else if (name.equals(\"textarea\")) {\n233                         tb.insert(startTag);\n234                         tb.tokeniser.transition(TokeniserState.Rcdata);\n235                         tb.markInsertionMode();\n236                         tb.framesetOk(false);\n237                         tb.transition(Text);\n238                     } else if (name.equals(\"xmp\")) {\n239                         if (tb.inButtonScope(\"p\")) {\n240                             tb.process(new Token.EndTag(\"p\"));\n241                         }\n242                         tb.reconstructFormattingElements();\n243                         tb.framesetOk(false);\n244                         handleRawtext(startTag, tb);\n245                     } else if (name.equals(\"iframe\")) {\n246                         tb.framesetOk(false);\n247                         handleRawtext(startTag, tb);\n248                     } else if (name.equals(\"noembed\")) {\n249                         handleRawtext(startTag, tb);\n250                     } else if (name.equals(\"select\")) {\n251                         tb.reconstructFormattingElements();\n252                         tb.insert(startTag);\n253                         tb.framesetOk(false);\n254                         HtmlTreeBuilderState state = tb.state();\n255                         if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n256                             tb.transition(InSelectInTable);\n257                         else\n258                             tb.transition(InSelect);\n259                     } else if (StringUtil.in(\"optgroup\", \"option\")) {\n260                         if (tb.currentElement().nodeName().equals(\"option\"))\n261                             tb.process(new Token.EndTag(\"option\"));\n262                         tb.reconstructFormattingElements();\n263                         tb.insert(startTag);\n264                     } else if (StringUtil.in(\"rp\", \"rt\")) {\n265                         if (tb.inScope(\"ruby\")) {\n266                             tb.generateImpliedEndTags();\n267                             if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n268                                 tb.error(this);\n269                                 tb.popStackToBefore(\"ruby\"); \n270                             }\n271                             tb.insert(startTag);\n272                         }\n273                     } else if (name.equals(\"math\")) {\n274                         tb.reconstructFormattingElements();\n275                         tb.insert(startTag);\n276                         tb.tokeniser.acknowledgeSelfClosingFlag();\n277                     } else if (name.equals(\"svg\")) {\n278                         tb.reconstructFormattingElements();\n279                         tb.insert(startTag);\n280                         tb.tokeniser.acknowledgeSelfClosingFlag();\n281                     } else if (StringUtil.in(name,\n282                             \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n283                         tb.error(this);\n284                         return false;\n285                     } else {\n286                         tb.reconstructFormattingElements();\n287                         tb.insert(startTag);\n288                     }\n289                     break;\n290                 case EndTag:\n291                     Token.EndTag endTag = t.asEndTag();\n292                     name = endTag.name();\n293                     if (name.equals(\"body\")) {\n294                         if (!tb.inScope(\"body\")) {\n295                             tb.error(this);\n296                             return false;\n297                         } else {\n298                             tb.transition(AfterBody);\n299                         }\n300                     } else if (name.equals(\"html\")) {\n301                         boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n302                         if (notIgnored)\n303                             return tb.process(endTag);\n304                     } else if (StringUtil.in(name,\n305                             \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n306                             \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n307                             \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n308                         if (!tb.inScope(name)) {\n309                             tb.error(this);\n310                             return false;\n311                         } else {\n312                             tb.generateImpliedEndTags();\n313                             if (!tb.currentElement().nodeName().equals(name))\n314                                 tb.error(this);\n315                             tb.popStackToClose(name);\n316                         }\n317                     } else if (name.equals(\"form\")) {\n318                         Element currentForm = tb.getFormElement();\n319                         tb.setFormElement(null);\n320                         if (currentForm == null || !tb.inScope(name)) {\n321                             tb.error(this);\n322                             return false;\n323                         } else {\n324                             tb.generateImpliedEndTags();\n325                             if (!tb.currentElement().nodeName().equals(name))\n326                                 tb.error(this);\n327                             tb.removeFromStack(currentForm);\n328                         }\n329                     } else if (name.equals(\"p\")) {\n330                         if (!tb.inButtonScope(name)) {\n331                             tb.error(this);\n332                             tb.process(new Token.StartTag(name)); \n333                             return tb.process(endTag);\n334                         } else {\n335                             tb.generateImpliedEndTags(name);\n336                             if (!tb.currentElement().nodeName().equals(name))\n337                                 tb.error(this);\n338                             tb.popStackToClose(name);\n339                         }\n340                     } else if (name.equals(\"li\")) {\n341                         if (!tb.inListItemScope(name)) {\n342                             tb.error(this);\n343                             return false;\n344                         } else {\n345                             tb.generateImpliedEndTags(name);\n346                             if (!tb.currentElement().nodeName().equals(name))\n347                                 tb.error(this);\n348                             tb.popStackToClose(name);\n349                         }\n350                     } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n351                         if (!tb.inScope(name)) {\n352                             tb.error(this);\n353                             return false;\n354                         } else {\n355                             tb.generateImpliedEndTags(name);\n356                             if (!tb.currentElement().nodeName().equals(name))\n357                                 tb.error(this);\n358                             tb.popStackToClose(name);\n359                         }\n360                     } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n361                         if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n362                             tb.error(this);\n363                             return false;\n364                         } else {\n365                             tb.generateImpliedEndTags(name);\n366                             if (!tb.currentElement().nodeName().equals(name))\n367                                 tb.error(this);\n368                             tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n369                         }\n370                     } else if (name.equals(\"sarcasm\")) {\n371                         return anyOtherEndTag(t, tb);\n372                     } else if (StringUtil.in(name,\n373                             \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n374                         OUTER:\n375                         for (int i = 0; i < 8; i++) {\n376                             Element formatEl = tb.getActiveFormattingElement(name);\n377                             if (formatEl == null)\n378                                 return anyOtherEndTag(t, tb);\n379                             else if (!tb.onStack(formatEl)) {\n380                                 tb.error(this);\n381                                 tb.removeFromActiveFormattingElements(formatEl);\n382                                 return true;\n383                             } else if (!tb.inScope(formatEl.nodeName())) {\n384                                 tb.error(this);\n385                                 return false;\n386                             } else if (tb.currentElement() != formatEl)\n387                                 tb.error(this);\n388                             Element furthestBlock = null;\n389                             Element commonAncestor = null;\n390                             boolean seenFormattingElement = false;\n391                             LinkedList<Element> stack = tb.getStack();\n392                             for (int si = 0; si < stack.size() && si < 64; si++) {\n393                                 Element el = stack.get(si);\n394                                 if (el == formatEl) {\n395                                     commonAncestor = stack.get(si - 1);\n396                                     seenFormattingElement = true;\n397                                 } else if (seenFormattingElement && tb.isSpecial(el)) {\n398                                     furthestBlock = el;\n399                                     break;\n400                                 }\n401                             }\n402                             if (furthestBlock == null) {\n403                                 tb.popStackToClose(formatEl.nodeName());\n404                                 tb.removeFromActiveFormattingElements(formatEl);\n405                                 return true;\n406                             }\n407                             Element node = furthestBlock;\n408                             Element lastNode = furthestBlock;\n409                             INNER:\n410                             for (int j = 0; j < 3; j++) {\n411                                 if (tb.onStack(node))\n412                                     node = tb.aboveOnStack(node);\n413                                 if (!tb.isInActiveFormattingElements(node)) { \n414                                     tb.removeFromStack(node);\n415                                     continue INNER;\n416                                 } else if (node == formatEl)\n417                                     break INNER;\n418                                 Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n419                                 tb.replaceActiveFormattingElement(node, replacement);\n420                                 tb.replaceOnStack(node, replacement);\n421                                 node = replacement;\n422                                 if (lastNode == furthestBlock) {\n423                                 }\n424                                 if (lastNode.parent() != null)\n425                                     lastNode.remove();\n426                                 node.appendChild(lastNode);\n427                                 lastNode = node;\n428                             }\n429                             if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n430                                 if (lastNode.parent() != null)\n431                                     lastNode.remove();\n432                                 tb.insertInFosterParent(lastNode);\n433                             } else {\n434                                 if (lastNode.parent() != null)\n435                                     lastNode.remove();\n436                                 commonAncestor.appendChild(lastNode);\n437                             }\n438                             Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n439                             Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n440                             for (Node childNode : childNodes) {\n441                                 adopter.appendChild(childNode); \n442                             }\n443                             furthestBlock.appendChild(adopter);\n444                             tb.removeFromActiveFormattingElements(formatEl);\n445                             tb.removeFromStack(formatEl);\n446                             tb.insertOnStackAfter(furthestBlock, adopter);\n447                         }\n448                     } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n449                         if (!tb.inScope(\"name\")) {\n450                             if (!tb.inScope(name)) {\n451                                 tb.error(this);\n452                                 return false;\n453                             }\n454                             tb.generateImpliedEndTags();\n455                             if (!tb.currentElement().nodeName().equals(name))\n456                                 tb.error(this);\n457                             tb.popStackToClose(name);\n458                             tb.clearFormattingElementsToLastMarker();\n459                         }\n460                     } else if (name.equals(\"br\")) {\n461                         tb.error(this);\n462                         tb.process(new Token.StartTag(\"br\"));\n463                         return false;\n464                     } else {\n465                         return anyOtherEndTag(t, tb);\n466                     }\n467                     break;\n468                 case EOF:\n469                     break;\n470             }\n471             return true;\n472         }\n", "fixed_code": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else if (isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            return false; \n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            return false; \n                        } else if (!tb.framesetOk()) {\n                            return false; \n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            while (stack.size() > 1)\n                                stack.removeLast();\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                            \"p\", \"section\", \"summary\", \"ul\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.in(name,\n                            \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        startTag.name(\"img\");\n                        return tb.process(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n                        tb.process(new Token.Character(prompt));\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(\"rp\", \"rt\")) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); \n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.in(name,\n                            \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); \n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.in(name,\n                            \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        OUTER:\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            LinkedList<Element> stack = tb.getStack();\n                            for (int si = 0; si < stack.size() && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            INNER:\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { \n                                    tb.removeFromStack(node);\n                                    continue INNER;\n                                } else if (node == formatEl)\n                                    break INNER;\n                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n                                if (lastNode == furthestBlock) {\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n                                lastNode = node;\n                            }\n                            if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); \n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n                    break;\n                case EOF:\n                    break;\n            }\n            return true;\n        }\n"}
{"bug_id": "Lang-48", "buggy_code": "1     public EqualsBuilder append(Object lhs, Object rhs) {\n2         if (isEquals == false) {\n3             return this;\n4         }\n5         if (lhs == rhs) {\n6             return this;\n7         }\n8         if (lhs == null || rhs == null) {\n9             this.setEquals(false);\n10             return this;\n11         }\n12         Class lhsClass = lhs.getClass();\n13         if (!lhsClass.isArray()) {\n14                 isEquals = lhs.equals(rhs);\n15         } else if (lhs.getClass() != rhs.getClass()) {\n16             this.setEquals(false);\n17         }\n18         else if (lhs instanceof long[]) {\n19             append((long[]) lhs, (long[]) rhs);\n20         } else if (lhs instanceof int[]) {\n21             append((int[]) lhs, (int[]) rhs);\n22         } else if (lhs instanceof short[]) {\n23             append((short[]) lhs, (short[]) rhs);\n24         } else if (lhs instanceof char[]) {\n25             append((char[]) lhs, (char[]) rhs);\n26         } else if (lhs instanceof byte[]) {\n27             append((byte[]) lhs, (byte[]) rhs);\n28         } else if (lhs instanceof double[]) {\n29             append((double[]) lhs, (double[]) rhs);\n30         } else if (lhs instanceof float[]) {\n31             append((float[]) lhs, (float[]) rhs);\n32         } else if (lhs instanceof boolean[]) {\n33             append((boolean[]) lhs, (boolean[]) rhs);\n34         } else {\n35             append((Object[]) lhs, (Object[]) rhs);\n36         }\n37         return this;\n38     }\n", "fixed_code": "    public EqualsBuilder append(Object lhs, Object rhs) {\n        if (isEquals == false) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        Class lhsClass = lhs.getClass();\n        if (!lhsClass.isArray()) {\n            if (lhs instanceof java.math.BigDecimal) {\n                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);\n            } else {\n                isEquals = lhs.equals(rhs);\n            }\n        } else if (lhs.getClass() != rhs.getClass()) {\n            this.setEquals(false);\n        }\n        else if (lhs instanceof long[]) {\n            append((long[]) lhs, (long[]) rhs);\n        } else if (lhs instanceof int[]) {\n            append((int[]) lhs, (int[]) rhs);\n        } else if (lhs instanceof short[]) {\n            append((short[]) lhs, (short[]) rhs);\n        } else if (lhs instanceof char[]) {\n            append((char[]) lhs, (char[]) rhs);\n        } else if (lhs instanceof byte[]) {\n            append((byte[]) lhs, (byte[]) rhs);\n        } else if (lhs instanceof double[]) {\n            append((double[]) lhs, (double[]) rhs);\n        } else if (lhs instanceof float[]) {\n            append((float[]) lhs, (float[]) rhs);\n        } else if (lhs instanceof boolean[]) {\n            append((boolean[]) lhs, (boolean[]) rhs);\n        } else {\n            append((Object[]) lhs, (Object[]) rhs);\n        }\n        return this;\n    }\n"}
{"bug_id": "Chart-20", "buggy_code": "1     public ValueMarker(double value, Paint paint, Stroke stroke, \n2                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n3         super(paint, stroke, paint, stroke, alpha);\n4         this.value = value;\n5     }\n", "fixed_code": "    public ValueMarker(double value, Paint paint, Stroke stroke, \n                       Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(paint, stroke, outlinePaint, outlineStroke, alpha);\n        this.value = value;\n    }\n"}
{"bug_id": "Lang-45", "buggy_code": "1     public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n2         if (str == null) {\n3             return null;\n4         }\n5         if (str.length() == 0) {\n6             return StringUtils.EMPTY;\n7         }\n8         if (upper == -1 || upper > str.length()) {\n9             upper = str.length();\n10         }\n11         if (upper < lower) {\n12             upper = lower;\n13         }\n14         StringBuffer result = new StringBuffer();\n15         int index = StringUtils.indexOf(str, \" \", lower);\n16         if (index == -1) {\n17             result.append(str.substring(0, upper));\n18             if (upper != str.length()) {\n19                 result.append(StringUtils.defaultString(appendToEnd));\n20             }\n21         } else if (index > upper) {\n22             result.append(str.substring(0, upper));\n23             result.append(StringUtils.defaultString(appendToEnd));\n24         } else {\n25             result.append(str.substring(0, index));\n26             result.append(StringUtils.defaultString(appendToEnd));\n27         }\n28         return result.toString();\n29     }\n", "fixed_code": "    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (lower > str.length()) {\n            lower = str.length();    \n        }\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        if (upper < lower) {\n            upper = lower;\n        }\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }\n"}
{"bug_id": "Codec-7", "buggy_code": "1     public static String encodeBase64String(byte[] binaryData) {\n2         return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n3     }\n", "fixed_code": "    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n"}
{"bug_id": "Gson-2", "buggy_code": "1   public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n2       final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n3     return new TypeAdapterFactory() {\n4       @SuppressWarnings(\"unchecked\")\n5       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n6         final Class<? super T2> requestedType = typeToken.getRawType();\n7         if (!clazz.isAssignableFrom(requestedType)) {\n8           return null;\n9         }\n10         return (TypeAdapter<T2>) typeAdapter;\n11       }\n12       @Override public String toString() {\n13         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n14       }\n15     };\n16   }\n", "fixed_code": "  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n"}
{"bug_id": "Chart-5", "buggy_code": "1     public XYDataItem addOrUpdate(Number x, Number y) {\n2         if (x == null) {\n3             throw new IllegalArgumentException(\"Null 'x' argument.\");\n4         }\n5         XYDataItem overwritten = null;\n6         int index = indexOf(x);\n7         if (index >= 0 && !this.allowDuplicateXValues) {\n8             XYDataItem existing = (XYDataItem) this.data.get(index);\n9             try {\n10                 overwritten = (XYDataItem) existing.clone();\n11             }\n12             catch (CloneNotSupportedException e) {\n13                 throw new SeriesException(\"Couldn't clone XYDataItem!\");\n14             }\n15             existing.setY(y);\n16         }\n17         else {\n18             if (this.autoSort) {\n19                 this.data.add(-index - 1, new XYDataItem(x, y));\n20             }\n21             else {\n22                 this.data.add(new XYDataItem(x, y));\n23             }\n24             if (getItemCount() > this.maximumItemCount) {\n25                 this.data.remove(0);\n26             }\n27         }\n28         fireSeriesChanged();\n29         return overwritten;\n30     }\n", "fixed_code": "    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(x, y);\n            return null;\n        }\n        XYDataItem overwritten = null;\n        int index = indexOf(x);\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            try {\n                overwritten = (XYDataItem) existing.clone();\n            }\n            catch (CloneNotSupportedException e) {\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n            }\n            existing.setY(y);\n        }\n        else {\n            if (this.autoSort) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\n            }\n            else {\n                this.data.add(new XYDataItem(x, y));\n            }\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }\n"}
{"bug_id": "Closure-5", "buggy_code": "1     private boolean isInlinableObject(List<Reference> refs) {\n2       boolean ret = false;\n3       Set<String> validProperties = Sets.newHashSet();\n4       for (Reference ref : refs) {\n5         Node name = ref.getNode();\n6         Node parent = ref.getParent();\n7         Node gramps = ref.getGrandparent();\n8         if (parent.isGetProp()) {\n9           Preconditions.checkState(parent.getFirstChild() == name);\n10           if (gramps.isCall()\n11               && gramps.getFirstChild() == parent) {\n12             return false;\n13           }\n14           String propName = parent.getLastChild().getString();\n15           if (!validProperties.contains(propName)) {\n16             if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n17               validProperties.add(propName);\n18             } else {\n19               return false;\n20             }\n21           }\n22           continue;\n23         }\n24         if (!isVarOrAssignExprLhs(name)) {\n25            return false;\n26         }\n27         Node val = ref.getAssignedValue();\n28         if (val == null) {\n29           continue;\n30         }\n31         if (!val.isObjectLit()) {\n32           return false;\n33         }\n34         for (Node child = val.getFirstChild(); child != null;\n35              child = child.getNext()) {\n36           if (child.isGetterDef() ||\n37               child.isSetterDef()) {\n38             return false;\n39           }\n40           validProperties.add(child.getString());\n41           Node childVal = child.getFirstChild();\n42           for (Reference t : refs) {\n43             Node refNode = t.getParent();\n44             while (!NodeUtil.isStatementBlock(refNode)) {\n45               if (refNode == childVal) {\n46                 return false;\n47               }\n48               refNode = refNode.getParent();\n49             }\n50           }\n51         }\n52         ret = true;\n53       }\n54       return ret;\n55     }\n", "fixed_code": "    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n          if (gramps.isDelProp()) {\n            return false;\n          }\n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n          continue;\n        }\n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          continue;\n        }\n        if (!val.isObjectLit()) {\n          return false;\n        }\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            return false;\n          }\n          validProperties.add(child.getString());\n          Node childVal = child.getFirstChild();\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n        ret = true;\n      }\n      return ret;\n    }\n"}
{"bug_id": "Math-64", "buggy_code": "1     protected VectorialPointValuePair doOptimize()\n2         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n3         solvedCols  = Math.min(rows, cols);\n4         diagR       = new double[cols];\n5         jacNorm     = new double[cols];\n6         beta        = new double[cols];\n7         permutation = new int[cols];\n8         lmDir       = new double[cols];\n9         double   delta   = 0;\n10         double   xNorm   = 0;\n11         double[] diag    = new double[cols];\n12         double[] oldX    = new double[cols];\n13         double[] oldRes  = new double[rows];\n14         double[] work1   = new double[cols];\n15         double[] work2   = new double[cols];\n16         double[] work3   = new double[cols];\n17         updateResidualsAndCost();\n18         lmPar = 0;\n19         boolean firstIteration = true;\n20         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n21         while (true) {\n22             incrementIterationsCounter();\n23             VectorialPointValuePair previous = current;\n24             updateJacobian();\n25             qrDecomposition();\n26             qTy(residuals);\n27             for (int k = 0; k < solvedCols; ++k) {\n28                 int pk = permutation[k];\n29                 jacobian[k][pk] = diagR[pk];\n30             }\n31             if (firstIteration) {\n32                 xNorm = 0;\n33                 for (int k = 0; k < cols; ++k) {\n34                     double dk = jacNorm[k];\n35                     if (dk == 0) {\n36                         dk = 1.0;\n37                     }\n38                     double xk = dk * point[k];\n39                     xNorm  += xk * xk;\n40                     diag[k] = dk;\n41                 }\n42                 xNorm = Math.sqrt(xNorm);\n43                 delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n44             }\n45             double maxCosine = 0;\n46             if (cost != 0) {\n47                 for (int j = 0; j < solvedCols; ++j) {\n48                     int    pj = permutation[j];\n49                     double s  = jacNorm[pj];\n50                     if (s != 0) {\n51                         double sum = 0;\n52                         for (int i = 0; i <= j; ++i) {\n53                             sum += jacobian[i][pj] * residuals[i];\n54                         }\n55                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n56                     }\n57                 }\n58             }\n59             if (maxCosine <= orthoTolerance) {\n60                 return current;\n61             }\n62             for (int j = 0; j < cols; ++j) {\n63                 diag[j] = Math.max(diag[j], jacNorm[j]);\n64             }\n65             for (double ratio = 0; ratio < 1.0e-4;) {\n66                 for (int j = 0; j < solvedCols; ++j) {\n67                     int pj = permutation[j];\n68                     oldX[pj] = point[pj];\n69                 }\n70                 double previousCost = cost;\n71                 double[] tmpVec = residuals;\n72                 residuals = oldRes;\n73                 oldRes    = tmpVec;\n74                 determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n75                 double lmNorm = 0;\n76                 for (int j = 0; j < solvedCols; ++j) {\n77                     int pj = permutation[j];\n78                     lmDir[pj] = -lmDir[pj];\n79                     point[pj] = oldX[pj] + lmDir[pj];\n80                     double s = diag[pj] * lmDir[pj];\n81                     lmNorm  += s * s;\n82                 }\n83                 lmNorm = Math.sqrt(lmNorm);\n84                 if (firstIteration) {\n85                     delta = Math.min(delta, lmNorm);\n86                 }\n87                 updateResidualsAndCost();\n88                 current = new VectorialPointValuePair(point, objective);\n89                 double actRed = -1.0;\n90                 if (0.1 * cost < previousCost) {\n91                     double r = cost / previousCost;\n92                     actRed = 1.0 - r * r;\n93                 }\n94                 for (int j = 0; j < solvedCols; ++j) {\n95                     int pj = permutation[j];\n96                     double dirJ = lmDir[pj];\n97                     work1[j] = 0;\n98                     for (int i = 0; i <= j; ++i) {\n99                         work1[i] += jacobian[i][pj] * dirJ;\n100                     }\n101                 }\n102                 double coeff1 = 0;\n103                 for (int j = 0; j < solvedCols; ++j) {\n104                     coeff1 += work1[j] * work1[j];\n105                 }\n106                 double pc2 = previousCost * previousCost;\n107                 coeff1 = coeff1 / pc2;\n108                 double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n109                 double preRed = coeff1 + 2 * coeff2;\n110                 double dirDer = -(coeff1 + coeff2);\n111                 ratio = (preRed == 0) ? 0 : (actRed / preRed);\n112                 if (ratio <= 0.25) {\n113                     double tmp =\n114                         (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n115                         if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n116                             tmp = 0.1;\n117                         }\n118                         delta = tmp * Math.min(delta, 10.0 * lmNorm);\n119                         lmPar /= tmp;\n120                 } else if ((lmPar == 0) || (ratio >= 0.75)) {\n121                     delta = 2 * lmNorm;\n122                     lmPar *= 0.5;\n123                 }\n124                 if (ratio >= 1.0e-4) {\n125                     firstIteration = false;\n126                     xNorm = 0;\n127                     for (int k = 0; k < cols; ++k) {\n128                         double xK = diag[k] * point[k];\n129                         xNorm    += xK * xK;\n130                     }\n131                     xNorm = Math.sqrt(xNorm);\n132                 } else {\n133                     cost = previousCost;\n134                     for (int j = 0; j < solvedCols; ++j) {\n135                         int pj = permutation[j];\n136                         point[pj] = oldX[pj];\n137                     }\n138                     tmpVec    = residuals;\n139                     residuals = oldRes;\n140                     oldRes    = tmpVec;\n141                 }\n142                 if (checker==null) {\n143                 \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n144                         (preRed <= costRelativeTolerance) &&\n145                         (ratio <= 2.0)) ||\n146                        (delta <= parRelativeTolerance * xNorm)) {\n147                        return current;\n148                    }\n149                 } else {\n150                     if (checker.converged(getIterations(), previous, current)) {\n151                         return current;\n152                     }\n153                 }\n154                 if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n155                     throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n156                             costRelativeTolerance);\n157                 } else if (delta <= 2.2204e-16 * xNorm) {\n158                     throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n159                             parRelativeTolerance);\n160                 } else if (maxCosine <= 2.2204e-16)  {\n161                     throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n162                             orthoTolerance);\n163                 }\n164             }\n165         }\n166     }\n", "fixed_code": "    protected VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n        solvedCols  = Math.min(rows, cols);\n        diagR       = new double[cols];\n        jacNorm     = new double[cols];\n        beta        = new double[cols];\n        permutation = new int[cols];\n        lmDir       = new double[cols];\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[cols];\n        double[] oldX    = new double[cols];\n        double[] oldRes  = new double[rows];\n        double[] oldObj  = new double[rows];\n        double[] qtf     = new double[rows];\n        double[] work1   = new double[cols];\n        double[] work2   = new double[cols];\n        double[] work3   = new double[cols];\n        updateResidualsAndCost();\n        lmPar = 0;\n        boolean firstIteration = true;\n        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n        while (true) {\n            for (int i=0;i<rows;i++) {\n                qtf[i]=residuals[i];\n            }\n            incrementIterationsCounter();\n            VectorialPointValuePair previous = current;\n            updateJacobian();\n            qrDecomposition();\n            qTy(qtf);\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                jacobian[k][pk] = diagR[pk];\n            }\n            if (firstIteration) {\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * point[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = Math.sqrt(xNorm);\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n            }\n            double maxCosine = 0;\n            if (cost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += jacobian[i][pj] * qtf[i];\n                        }\n                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n            \tupdateResidualsAndCost();\n            \tcurrent = new VectorialPointValuePair(point, objective);\n                return current;\n            }\n            for (int j = 0; j < cols; ++j) {\n                diag[j] = Math.max(diag[j], jacNorm[j]);\n            }\n            for (double ratio = 0; ratio < 1.0e-4;) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = point[pj];\n                }\n                double previousCost = cost;\n                double[] tmpVec = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n                tmpVec    = objective;\n                objective = oldObj;\n                oldObj    = tmpVec;\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    point[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = Math.sqrt(lmNorm);\n                if (firstIteration) {\n                    delta = Math.min(delta, lmNorm);\n                }\n                updateResidualsAndCost();\n                double actRed = -1.0;\n                if (0.1 * cost < previousCost) {\n                    double r = cost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += jacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n                if (ratio >= 1.0e-4) {\n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < cols; ++k) {\n                        double xK = diag[k] * point[k];\n                        xNorm    += xK * xK;\n                    }\n                    xNorm = Math.sqrt(xNorm);\n                    current = new VectorialPointValuePair(point, objective);\n                    if (checker != null) {\n                    \tif (checker.converged(getIterations(), previous, current)) {\n                    \t\treturn current;\n                    \t}\n                    }\n                } else {\n                    cost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        point[pj] = oldX[pj];\n                    }\n                    tmpVec    = residuals;\n                    residuals = oldRes;\n                    oldRes    = tmpVec;\n                    tmpVec    = objective;\n                    objective = oldObj;\n                    oldObj    = tmpVec;\n                }\n                if (checker==null) {\n                \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                        (preRed <= costRelativeTolerance) &&\n                        (ratio <= 2.0)) ||\n                       (delta <= parRelativeTolerance * xNorm)) {\n                       return current;\n                   }\n                }\n                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                            costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                            parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                            orthoTolerance);\n                }\n            }\n        }\n    }\n"}
{"bug_id": "Mockito-22", "buggy_code": "1     public static boolean areEqual(Object o1, Object o2) {\n2         if (o1 == null || o2 == null) {\n3             return o1 == null && o2 == null;\n4         } else if (isArray(o1)) {\n5             return isArray(o2) && areArraysEqual(o1, o2);\n6         } else {\n7             return o1.equals(o2);\n8         }\n9     }\n", "fixed_code": "    public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2 ) {\n            return true;\n\t} else if (o1 == null || o2 == null) {\n            return o1 == null && o2 == null;\n        } else if (isArray(o1)) {\n            return isArray(o2) && areArraysEqual(o1, o2);\n        } else {\n            return o1.equals(o2);\n        }\n    }\n"}
{"bug_id": "JacksonXml-1", "buggy_code": "1     public JsonToken nextToken() throws IOException\n2     {\n3         _binaryValue = null;\n4         if (_nextToken != null) {\n5             JsonToken t = _nextToken;\n6             _currToken = t;\n7             _nextToken = null;\n8             switch (t) {\n9             case START_OBJECT:\n10                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n11                 break;\n12             case START_ARRAY:\n13                 _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n14                 break;\n15             case END_OBJECT:\n16             case END_ARRAY:\n17                 _parsingContext = _parsingContext.getParent();\n18                 _namesToWrap = _parsingContext.getNamesToWrap();\n19                 break;\n20             case FIELD_NAME:\n21                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n22                 break;\n23             default: \n24             }\n25             return t;\n26         }\n27         int token = _xmlTokens.next();\n28         while (token == XmlTokenStream.XML_START_ELEMENT) {\n29             if (_mayBeLeaf) {\n30                 _nextToken = JsonToken.FIELD_NAME;\n31                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n32                 return (_currToken = JsonToken.START_OBJECT);\n33             }\n34             if (_parsingContext.inArray()) {\n35                 token = _xmlTokens.next();\n36                 _mayBeLeaf = true;\n37                 continue;\n38             }\n39             String name = _xmlTokens.getLocalName();\n40             _parsingContext.setCurrentName(name);\n41             if (_namesToWrap != null && _namesToWrap.contains(name)) {\n42                 _xmlTokens.repeatStartElement();\n43             }\n44             _mayBeLeaf = true;\n45             return (_currToken = JsonToken.FIELD_NAME);\n46         }\n47         switch (token) {\n48         case XmlTokenStream.XML_END_ELEMENT:\n49             if (_mayBeLeaf) {\n50                 _mayBeLeaf = false;\n51                 return (_currToken = JsonToken.VALUE_NULL);\n52             }\n53             _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n54             _parsingContext = _parsingContext.getParent();\n55             _namesToWrap = _parsingContext.getNamesToWrap();\n56             return _currToken;\n57         case XmlTokenStream.XML_ATTRIBUTE_NAME:\n58             if (_mayBeLeaf) {\n59                 _mayBeLeaf = false;\n60                 _nextToken = JsonToken.FIELD_NAME;\n61                 _currText = _xmlTokens.getText();\n62                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n63                 return (_currToken = JsonToken.START_OBJECT);\n64             }\n65             _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n66             return (_currToken = JsonToken.FIELD_NAME);\n67         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n68             _currText = _xmlTokens.getText();\n69             return (_currToken = JsonToken.VALUE_STRING);\n70         case XmlTokenStream.XML_TEXT:\n71             _currText = _xmlTokens.getText();\n72             if (_mayBeLeaf) {\n73                 _mayBeLeaf = false;\n74                 _xmlTokens.skipEndElement();\n75                 if (_parsingContext.inArray()) {\n76                     if (_isEmpty(_currText)) {\n77                         _currToken = JsonToken.END_ARRAY;\n78                         _parsingContext = _parsingContext.getParent();\n79                         _namesToWrap = _parsingContext.getNamesToWrap();\n80                         return _currToken;\n81                     }\n82                 }\n83                 return (_currToken = JsonToken.VALUE_STRING);\n84             } else {\n85                 if (_parsingContext.inObject()\n86                         && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n87                     _currToken = JsonToken.END_OBJECT;\n88                     _parsingContext = _parsingContext.getParent();\n89                     _namesToWrap = _parsingContext.getNamesToWrap();\n90                     return _currToken;\n91                 }\n92             }\n93             _parsingContext.setCurrentName(_cfgNameForTextElement);\n94             _nextToken = JsonToken.VALUE_STRING;\n95             return (_currToken = JsonToken.FIELD_NAME);\n96         case XmlTokenStream.XML_END:\n97             return (_currToken = null);\n98         }\n99         _throwInternal();\n100         return null;\n101     }\n", "fixed_code": "    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: \n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                if (_parsingContext.inArray()) {\n                    _nextToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT);\n                }\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        _nextToken = JsonToken.END_OBJECT;\n                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                        return (_currToken = JsonToken.START_OBJECT);\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                if (_parsingContext.inObject()\n                        && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n        }\n        _throwInternal();\n        return null;\n    }\n"}
{"bug_id": "Gson-15", "buggy_code": "1   public JsonWriter value(double value) throws IOException {\n2     writeDeferredName();\n3     if (Double.isNaN(value) || Double.isInfinite(value)) {\n4       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n5     }\n6     beforeValue();\n7     out.append(Double.toString(value));\n8     return this;\n9   }\n", "fixed_code": "  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n"}
{"bug_id": "Math-74", "buggy_code": "1   public double integrate(final FirstOrderDifferentialEquations equations,\n2                           final double t0, final double[] y0,\n3                           final double t, final double[] y)\n4   throws DerivativeException, IntegratorException {\n5     sanityChecks(equations, t0, y0, t, y);\n6     setEquations(equations);\n7     resetEvaluations();\n8     final boolean forward = t > t0;\n9     final int stages = c.length + 1;\n10     if (y != y0) {\n11       System.arraycopy(y0, 0, y, 0, y0.length);\n12     }\n13     final double[][] yDotK = new double[stages][y0.length];\n14     final double[] yTmp = new double[y0.length];\n15     AbstractStepInterpolator interpolator;\n16     if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n17       final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n18       rki.reinitialize(this, yTmp, yDotK, forward);\n19       interpolator = rki;\n20     } else {\n21       interpolator = new DummyStepInterpolator(yTmp, forward);\n22     }\n23     interpolator.storeTime(t0);\n24     stepStart         = t0;\n25     double  hNew      = 0;\n26     boolean firstTime = true;\n27     for (StepHandler handler : stepHandlers) {\n28         handler.reset();\n29     }\n30     CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n31     boolean lastStep = false;\n32     while (!lastStep) {\n33       interpolator.shift();\n34       double error = 0;\n35       for (boolean loop = true; loop;) {\n36         if (firstTime || !fsal) {\n37           computeDerivatives(stepStart, y, yDotK[0]);\n38         }\n39         if (firstTime) {\n40           final double[] scale;\n41           if (vecAbsoluteTolerance == null) {\n42               scale = new double[y0.length];\n43               java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n44             } else {\n45               scale = vecAbsoluteTolerance;\n46             }\n47           hNew = initializeStep(equations, forward, getOrder(), scale,\n48                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n49           firstTime = false;\n50         }\n51         stepSize = hNew;\n52         for (int k = 1; k < stages; ++k) {\n53           for (int j = 0; j < y0.length; ++j) {\n54             double sum = a[k-1][0] * yDotK[0][j];\n55             for (int l = 1; l < k; ++l) {\n56               sum += a[k-1][l] * yDotK[l][j];\n57             }\n58             yTmp[j] = y[j] + stepSize * sum;\n59           }\n60           computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n61         }\n62         for (int j = 0; j < y0.length; ++j) {\n63           double sum    = b[0] * yDotK[0][j];\n64           for (int l = 1; l < stages; ++l) {\n65             sum    += b[l] * yDotK[l][j];\n66           }\n67           yTmp[j] = y[j] + stepSize * sum;\n68         }\n69         error = estimateError(yDotK, y, yTmp, stepSize);\n70         if (error <= 1.0) {\n71           interpolator.storeTime(stepStart + stepSize);\n72           if (manager.evaluateStep(interpolator)) {\n73               final double dt = manager.getEventTime() - stepStart;\n74               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n75                   loop = false;\n76               } else {\n77                   hNew = dt;\n78               }\n79           } else {\n80             loop = false;\n81           }\n82         } else {\n83           final double factor =\n84               Math.min(maxGrowth,\n85                        Math.max(minReduction, safety * Math.pow(error, exp)));\n86           hNew = filterStep(stepSize * factor, forward, false);\n87         }\n88       }\n89       final double nextStep = stepStart + stepSize;\n90       System.arraycopy(yTmp, 0, y, 0, y0.length);\n91       manager.stepAccepted(nextStep, y);\n92       lastStep = manager.stop();\n93       interpolator.storeTime(nextStep);\n94       for (StepHandler handler : stepHandlers) {\n95           handler.handleStep(interpolator, lastStep);\n96       }\n97       stepStart = nextStep;\n98       if (fsal) {\n99         System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n100       }\n101       if (manager.reset(stepStart, y) && ! lastStep) {\n102         computeDerivatives(stepStart, y, yDotK[0]);\n103       }\n104       if (! lastStep) {\n105           stepSize = filterStep(stepSize, forward, true);\n106         final double factor = Math.min(maxGrowth,\n107                                        Math.max(minReduction,\n108                                                 safety * Math.pow(error, exp)));\n109         final double  scaledH    = stepSize * factor;\n110         final double  nextT      = stepStart + scaledH;\n111         final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n112         hNew = filterStep(scaledH, forward, nextIsLast);\n113       }\n114     }\n115     final double stopTime = stepStart;\n116     resetInternalState();\n117     return stopTime;\n118   }\n", "fixed_code": "  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n    while (!lastStep) {\n      interpolator.shift();\n      double error = 0;\n      for (boolean loop = true; loop;) {\n        if (firstTime || !fsal) {\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n        stepSize = hNew;\n        for (int k = 1; k < stages; ++k) {\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n        }\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  loop = false;\n              } else {\n                  hNew = dt;\n              }\n          } else {\n            loop = false;\n          }\n        } else {\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n      }\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n      if (fsal) {\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n      if (! lastStep) {\n          stepSize = filterStep(stepSize, forward, true);\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n    }\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n  }\n"}
{"bug_id": "Gson-11", "buggy_code": "1     public Number read(JsonReader in) throws IOException {\n2       JsonToken jsonToken = in.peek();\n3       switch (jsonToken) {\n4       case NULL:\n5         in.nextNull();\n6         return null;\n7       case NUMBER:\n8         return new LazilyParsedNumber(in.nextString());\n9       default:\n10         throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n11       }\n12     }\n", "fixed_code": "    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n      case STRING:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n"}
{"bug_id": "Jsoup-15", "buggy_code": "1         boolean process(Token t, TreeBuilder tb) {\n2             switch (t.type) {\n3                 case Character: {\n4                     Token.Character c = t.asCharacter();\n5                     if (c.getData().equals(nullString)) {\n6                         tb.error(this);\n7                         return false;\n8                     } else if (isWhitespace(c)) {\n9                         tb.reconstructFormattingElements();\n10                         tb.insert(c);\n11                     } else {\n12                         tb.reconstructFormattingElements();\n13                         tb.insert(c);\n14                         tb.framesetOk(false);\n15                     }\n16                     break;\n17                 }\n18                 case Comment: {\n19                     tb.insert(t.asComment());\n20                     break;\n21                 }\n22                 case Doctype: {\n23                     tb.error(this);\n24                     return false;\n25                 }\n26                 case StartTag:\n27                     Token.StartTag startTag = t.asStartTag();\n28                     String name = startTag.name();\n29                     if (name.equals(\"html\")) {\n30                         tb.error(this);\n31                         Element html = tb.getStack().getFirst();\n32                         for (Attribute attribute : startTag.getAttributes()) {\n33                             if (!html.hasAttr(attribute.getKey()))\n34                                 html.attributes().put(attribute);\n35                         }\n36                     } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n37                         return tb.process(t, InHead);\n38                     } else if (name.equals(\"body\")) {\n39                         tb.error(this);\n40                         LinkedList<Element> stack = tb.getStack();\n41                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n42                             return false; \n43                         } else {\n44                             tb.framesetOk(false);\n45                             Element body = stack.get(1);\n46                             for (Attribute attribute : startTag.getAttributes()) {\n47                                 if (!body.hasAttr(attribute.getKey()))\n48                                     body.attributes().put(attribute);\n49                             }\n50                         }\n51                     } else if (name.equals(\"frameset\")) {\n52                         tb.error(this);\n53                         LinkedList<Element> stack = tb.getStack();\n54                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n55                             return false; \n56                         } else if (!tb.framesetOk()) {\n57                             return false; \n58                         } else {\n59                             Element second = stack.get(1);\n60                             if (second.parent() != null)\n61                                 second.remove();\n62                             while (stack.size() > 1)\n63                                 stack.removeLast();\n64                             tb.insert(startTag);\n65                             tb.transition(InFrameset);\n66                         }\n67                     } else if (StringUtil.in(name,\n68                             \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n69                             \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n70                             \"p\", \"section\", \"summary\", \"ul\")) {\n71                         if (tb.inButtonScope(\"p\")) {\n72                             tb.process(new Token.EndTag(\"p\"));\n73                         }\n74                         tb.insert(startTag);\n75                     } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n76                         if (tb.inButtonScope(\"p\")) {\n77                             tb.process(new Token.EndTag(\"p\"));\n78                         }\n79                         if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n80                             tb.error(this);\n81                             tb.pop();\n82                         }\n83                         tb.insert(startTag);\n84                     } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n85                         if (tb.inButtonScope(\"p\")) {\n86                             tb.process(new Token.EndTag(\"p\"));\n87                         }\n88                         tb.insert(startTag);\n89                         tb.framesetOk(false);\n90                     } else if (name.equals(\"form\")) {\n91                         if (tb.getFormElement() != null) {\n92                             tb.error(this);\n93                             return false;\n94                         }\n95                         if (tb.inButtonScope(\"p\")) {\n96                             tb.process(new Token.EndTag(\"p\"));\n97                         }\n98                         Element form = tb.insert(startTag);\n99                         tb.setFormElement(form);\n100                     } else if (name.equals(\"li\")) {\n101                         tb.framesetOk(false);\n102                         LinkedList<Element> stack = tb.getStack();\n103                         for (int i = stack.size() - 1; i > 0; i--) {\n104                             Element el = stack.get(i);\n105                             if (el.nodeName().equals(\"li\")) {\n106                                 tb.process(new Token.EndTag(\"li\"));\n107                                 break;\n108                             }\n109                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n110                                 break;\n111                         }\n112                         if (tb.inButtonScope(\"p\")) {\n113                             tb.process(new Token.EndTag(\"p\"));\n114                         }\n115                         tb.insert(startTag);\n116                     } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n117                         tb.framesetOk(false);\n118                         LinkedList<Element> stack = tb.getStack();\n119                         for (int i = stack.size() - 1; i > 0; i--) {\n120                             Element el = stack.get(i);\n121                             if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n122                                 tb.process(new Token.EndTag(el.nodeName()));\n123                                 break;\n124                             }\n125                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n126                                 break;\n127                         }\n128                         if (tb.inButtonScope(\"p\")) {\n129                             tb.process(new Token.EndTag(\"p\"));\n130                         }\n131                         tb.insert(startTag);\n132                     } else if (name.equals(\"plaintext\")) {\n133                         if (tb.inButtonScope(\"p\")) {\n134                             tb.process(new Token.EndTag(\"p\"));\n135                         }\n136                         tb.insert(startTag);\n137                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n138                     } else if (name.equals(\"button\")) {\n139                         if (tb.inButtonScope(\"button\")) {\n140                             tb.error(this);\n141                             tb.process(new Token.EndTag(\"button\"));\n142                             tb.process(startTag);\n143                         } else {\n144                             tb.reconstructFormattingElements();\n145                             tb.insert(startTag);\n146                             tb.framesetOk(false);\n147                         }\n148                     } else if (name.equals(\"a\")) {\n149                         if (tb.getActiveFormattingElement(\"a\") != null) {\n150                             tb.error(this);\n151                             tb.process(new Token.EndTag(\"a\"));\n152                             Element remainingA = tb.getFromStack(\"a\");\n153                             if (remainingA != null) {\n154                                 tb.removeFromActiveFormattingElements(remainingA);\n155                                 tb.removeFromStack(remainingA);\n156                             }\n157                         }\n158                         tb.reconstructFormattingElements();\n159                         Element a = tb.insert(startTag);\n160                         tb.pushActiveFormattingElements(a);\n161                     } else if (StringUtil.in(name,\n162                             \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n163                         tb.reconstructFormattingElements();\n164                         Element el = tb.insert(startTag);\n165                         tb.pushActiveFormattingElements(el);\n166                     } else if (name.equals(\"nobr\")) {\n167                         tb.reconstructFormattingElements();\n168                         if (tb.inScope(\"nobr\")) {\n169                             tb.error(this);\n170                             tb.process(new Token.EndTag(\"nobr\"));\n171                             tb.reconstructFormattingElements();\n172                         }\n173                         Element el = tb.insert(startTag);\n174                         tb.pushActiveFormattingElements(el);\n175                     } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n176                         tb.reconstructFormattingElements();\n177                         tb.insert(startTag);\n178                         tb.insertMarkerToFormattingElements();\n179                         tb.framesetOk(false);\n180                     } else if (name.equals(\"table\")) {\n181                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n182                             tb.process(new Token.EndTag(\"p\"));\n183                         }\n184                         tb.insert(startTag);\n185                         tb.framesetOk(false);\n186                         tb.transition(InTable);\n187                     } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n188                         tb.reconstructFormattingElements();\n189                         tb.insertEmpty(startTag);\n190                         tb.framesetOk(false);\n191                     } else if (name.equals(\"input\")) {\n192                         tb.reconstructFormattingElements();\n193                         Element el = tb.insertEmpty(startTag);\n194                         if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n195                             tb.framesetOk(false);\n196                     } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n197                         tb.insertEmpty(startTag);\n198                     } else if (name.equals(\"hr\")) {\n199                         if (tb.inButtonScope(\"p\")) {\n200                             tb.process(new Token.EndTag(\"p\"));\n201                         }\n202                         tb.insertEmpty(startTag);\n203                         tb.framesetOk(false);\n204                     } else if (name.equals(\"image\")) {\n205                         startTag.name(\"img\");\n206                         return tb.process(startTag);\n207                     } else if (name.equals(\"isindex\")) {\n208                         tb.error(this);\n209                         if (tb.getFormElement() != null)\n210                             return false;\n211                         tb.tokeniser.acknowledgeSelfClosingFlag();\n212                         tb.process(new Token.StartTag(\"form\"));\n213                         if (startTag.attributes.hasKey(\"action\")) {\n214                             Element form = tb.getFormElement();\n215                             form.attr(\"action\", startTag.attributes.get(\"action\"));\n216                         }\n217                         tb.process(new Token.StartTag(\"hr\"));\n218                         tb.process(new Token.StartTag(\"label\"));\n219                         String prompt = startTag.attributes.hasKey(\"prompt\") ?\n220                                 startTag.attributes.get(\"prompt\") :\n221                                 \"This is a searchable index. Enter search keywords: \";\n222                         tb.process(new Token.Character(prompt));\n223                         Attributes inputAttribs = new Attributes();\n224                         for (Attribute attr : startTag.attributes) {\n225                             if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n226                                 inputAttribs.put(attr);\n227                         }\n228                         inputAttribs.put(\"name\", \"isindex\");\n229                         tb.process(new Token.StartTag(\"input\", inputAttribs));\n230                         tb.process(new Token.EndTag(\"label\"));\n231                         tb.process(new Token.StartTag(\"hr\"));\n232                         tb.process(new Token.EndTag(\"form\"));\n233                     } else if (name.equals(\"textarea\")) {\n234                         tb.insert(startTag);\n235                         tb.tokeniser.transition(TokeniserState.Rcdata);\n236                         tb.markInsertionMode();\n237                         tb.framesetOk(false);\n238                         tb.transition(Text);\n239                     } else if (name.equals(\"xmp\")) {\n240                         if (tb.inButtonScope(\"p\")) {\n241                             tb.process(new Token.EndTag(\"p\"));\n242                         }\n243                         tb.reconstructFormattingElements();\n244                         tb.framesetOk(false);\n245                         handleRawtext(startTag, tb);\n246                     } else if (name.equals(\"iframe\")) {\n247                         tb.framesetOk(false);\n248                         handleRawtext(startTag, tb);\n249                     } else if (name.equals(\"noembed\")) {\n250                         handleRawtext(startTag, tb);\n251                     } else if (name.equals(\"select\")) {\n252                         tb.reconstructFormattingElements();\n253                         tb.insert(startTag);\n254                         tb.framesetOk(false);\n255                         TreeBuilderState state = tb.state();\n256                         if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n257                             tb.transition(InSelectInTable);\n258                         else\n259                             tb.transition(InSelect);\n260                     } else if (StringUtil.in(\"optgroup\", \"option\")) {\n261                         if (tb.currentElement().nodeName().equals(\"option\"))\n262                             tb.process(new Token.EndTag(\"option\"));\n263                         tb.reconstructFormattingElements();\n264                         tb.insert(startTag);\n265                     } else if (StringUtil.in(\"rp\", \"rt\")) {\n266                         if (tb.inScope(\"ruby\")) {\n267                             tb.generateImpliedEndTags();\n268                             if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n269                                 tb.error(this);\n270                                 tb.popStackToBefore(\"ruby\"); \n271                             }\n272                             tb.insert(startTag);\n273                         }\n274                     } else if (name.equals(\"math\")) {\n275                         tb.reconstructFormattingElements();\n276                         tb.insert(startTag);\n277                         tb.tokeniser.acknowledgeSelfClosingFlag();\n278                     } else if (name.equals(\"svg\")) {\n279                         tb.reconstructFormattingElements();\n280                         tb.insert(startTag);\n281                         tb.tokeniser.acknowledgeSelfClosingFlag();\n282                     } else if (StringUtil.in(name,\n283                             \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n284                         tb.error(this);\n285                         return false;\n286                     } else {\n287                         tb.reconstructFormattingElements();\n288                         tb.insert(startTag);\n289                     }\n290                     break;\n291                 case EndTag:\n292                     Token.EndTag endTag = t.asEndTag();\n293                     name = endTag.name();\n294                     if (name.equals(\"body\")) {\n295                         if (!tb.inScope(\"body\")) {\n296                             tb.error(this);\n297                             return false;\n298                         } else {\n299                             tb.transition(AfterBody);\n300                         }\n301                     } else if (name.equals(\"html\")) {\n302                         boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n303                         if (notIgnored)\n304                             return tb.process(endTag);\n305                     } else if (StringUtil.in(name,\n306                             \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n307                             \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n308                             \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n309                         if (!tb.inScope(name)) {\n310                             tb.error(this);\n311                             return false;\n312                         } else {\n313                             tb.generateImpliedEndTags();\n314                             if (!tb.currentElement().nodeName().equals(name))\n315                                 tb.error(this);\n316                             tb.popStackToClose(name);\n317                         }\n318                     } else if (name.equals(\"form\")) {\n319                         Element currentForm = tb.getFormElement();\n320                         tb.setFormElement(null);\n321                         if (currentForm == null || !tb.inScope(name)) {\n322                             tb.error(this);\n323                             return false;\n324                         } else {\n325                             tb.generateImpliedEndTags();\n326                             if (!tb.currentElement().nodeName().equals(name))\n327                                 tb.error(this);\n328                             tb.removeFromStack(currentForm);\n329                         }\n330                     } else if (name.equals(\"p\")) {\n331                         if (!tb.inButtonScope(name)) {\n332                             tb.error(this);\n333                             tb.process(new Token.StartTag(name)); \n334                             return tb.process(endTag);\n335                         } else {\n336                             tb.generateImpliedEndTags(name);\n337                             if (!tb.currentElement().nodeName().equals(name))\n338                                 tb.error(this);\n339                             tb.popStackToClose(name);\n340                         }\n341                     } else if (name.equals(\"li\")) {\n342                         if (!tb.inListItemScope(name)) {\n343                             tb.error(this);\n344                             return false;\n345                         } else {\n346                             tb.generateImpliedEndTags(name);\n347                             if (!tb.currentElement().nodeName().equals(name))\n348                                 tb.error(this);\n349                             tb.popStackToClose(name);\n350                         }\n351                     } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n352                         if (!tb.inScope(name)) {\n353                             tb.error(this);\n354                             return false;\n355                         } else {\n356                             tb.generateImpliedEndTags(name);\n357                             if (!tb.currentElement().nodeName().equals(name))\n358                                 tb.error(this);\n359                             tb.popStackToClose(name);\n360                         }\n361                     } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n362                         if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n363                             tb.error(this);\n364                             return false;\n365                         } else {\n366                             tb.generateImpliedEndTags(name);\n367                             if (!tb.currentElement().nodeName().equals(name))\n368                                 tb.error(this);\n369                             tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n370                         }\n371                     } else if (name.equals(\"sarcasm\")) {\n372                         return anyOtherEndTag(t, tb);\n373                     } else if (StringUtil.in(name,\n374                             \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n375                         OUTER:\n376                         for (int i = 0; i < 8; i++) {\n377                             Element formatEl = tb.getActiveFormattingElement(name);\n378                             if (formatEl == null)\n379                                 return anyOtherEndTag(t, tb);\n380                             else if (!tb.onStack(formatEl)) {\n381                                 tb.error(this);\n382                                 tb.removeFromActiveFormattingElements(formatEl);\n383                                 return true;\n384                             } else if (!tb.inScope(formatEl.nodeName())) {\n385                                 tb.error(this);\n386                                 return false;\n387                             } else if (tb.currentElement() != formatEl)\n388                                 tb.error(this);\n389                             Element furthestBlock = null;\n390                             Element commonAncestor = null;\n391                             boolean seenFormattingElement = false;\n392                             LinkedList<Element> stack = tb.getStack();\n393                             for (int si = 0; si < stack.size(); si++) {\n394                                 Element el = stack.get(si);\n395                                 if (el == formatEl) {\n396                                     commonAncestor = stack.get(si - 1);\n397                                     seenFormattingElement = true;\n398                                 } else if (seenFormattingElement && tb.isSpecial(el)) {\n399                                     furthestBlock = el;\n400                                     break;\n401                                 }\n402                             }\n403                             if (furthestBlock == null) {\n404                                 tb.popStackToClose(formatEl.nodeName());\n405                                 tb.removeFromActiveFormattingElements(formatEl);\n406                                 return true;\n407                             }\n408                             Element node = furthestBlock;\n409                             Element lastNode = furthestBlock;\n410                             INNER:\n411                             for (int j = 0; j < 3; j++) {\n412                                 if (tb.onStack(node))\n413                                     node = tb.aboveOnStack(node);\n414                                 if (!tb.isInActiveFormattingElements(node)) { \n415                                     tb.removeFromStack(node);\n416                                     continue INNER;\n417                                 } else if (node == formatEl)\n418                                     break INNER;\n419                                 Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n420                                 tb.replaceActiveFormattingElement(node, replacement);\n421                                 tb.replaceOnStack(node, replacement);\n422                                 node = replacement;\n423                                 if (lastNode == furthestBlock) {\n424                                 }\n425                                 if (lastNode.parent() != null)\n426                                     lastNode.remove();\n427                                 node.appendChild(lastNode);\n428                                 lastNode = node;\n429                             }\n430                             if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n431                                 if (lastNode.parent() != null)\n432                                     lastNode.remove();\n433                                 tb.insertInFosterParent(lastNode);\n434                             } else {\n435                                 if (lastNode.parent() != null)\n436                                     lastNode.remove();\n437                                 commonAncestor.appendChild(lastNode);\n438                             }\n439                             Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n440                             Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n441                             for (Node childNode : childNodes) {\n442                                 adopter.appendChild(childNode); \n443                             }\n444                             furthestBlock.appendChild(adopter);\n445                             tb.removeFromActiveFormattingElements(formatEl);\n446                             tb.removeFromStack(formatEl);\n447                             tb.insertOnStackAfter(furthestBlock, adopter);\n448                         }\n449                     } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n450                         if (!tb.inScope(\"name\")) {\n451                             if (!tb.inScope(name)) {\n452                                 tb.error(this);\n453                                 return false;\n454                             }\n455                             tb.generateImpliedEndTags();\n456                             if (!tb.currentElement().nodeName().equals(name))\n457                                 tb.error(this);\n458                             tb.popStackToClose(name);\n459                             tb.clearFormattingElementsToLastMarker();\n460                         }\n461                     } else if (name.equals(\"br\")) {\n462                         tb.error(this);\n463                         tb.process(new Token.StartTag(\"br\"));\n464                         return false;\n465                     } else {\n466                         return anyOtherEndTag(t, tb);\n467                     }\n468                     break;\n469                 case EOF:\n470                     break;\n471             }\n472             return true;\n473         }\n", "fixed_code": "        boolean process(Token t, TreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else if (isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            return false; \n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            return false; \n                        } else if (!tb.framesetOk()) {\n                            return false; \n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            while (stack.size() > 1)\n                                stack.removeLast();\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                            \"p\", \"section\", \"summary\", \"ul\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        Element form = tb.insert(startTag);\n                        tb.setFormElement(form);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.in(name,\n                            \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        startTag.name(\"img\");\n                        return tb.process(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n                        tb.process(new Token.Character(prompt));\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        TreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(\"rp\", \"rt\")) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); \n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.in(name,\n                            \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); \n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.in(name,\n                            \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        OUTER:\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            LinkedList<Element> stack = tb.getStack();\n                            for (int si = 0; si < stack.size(); si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            INNER:\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { \n                                    tb.removeFromStack(node);\n                                    continue INNER;\n                                } else if (node == formatEl)\n                                    break INNER;\n                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n                                if (lastNode == furthestBlock) {\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n                                lastNode = node;\n                            }\n                            if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n                            Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); \n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n                    break;\n                case EOF:\n                    break;\n            }\n            return true;\n        }\n"}
{"bug_id": "JacksonDatabind-98", "buggy_code": "1     public Object complete(JsonParser p, DeserializationContext ctxt,\n2             PropertyValueBuffer buffer, PropertyBasedCreator creator)\n3         throws IOException\n4     {\n5         final int len = _properties.length;\n6         Object[] values = new Object[len];\n7         for (int i = 0; i < len; ++i) {\n8             String typeId = _typeIds[i];\n9             final ExtTypedProperty extProp = _properties[i];\n10             if (typeId == null) {\n11                 if (_tokens[i] == null) {\n12                     continue;\n13                 }\n14                 if (!extProp.hasDefaultType()) {\n15                     ctxt.reportInputMismatch(_beanType,\n16                             \"Missing external type id property '%s'\",\n17                             extProp.getTypePropertyName());\n18                 } else {\n19                     typeId = extProp.getDefaultTypeId();\n20                 }\n21             } else if (_tokens[i] == null) {\n22                 SettableBeanProperty prop = extProp.getProperty();\n23                 ctxt.reportInputMismatch(_beanType,\n24                         \"Missing property '%s' for external type id '%s'\",\n25                         prop.getName(), _properties[i].getTypePropertyName());\n26             }\n27             values[i] = _deserialize(p, ctxt, i, typeId);\n28             final SettableBeanProperty prop = extProp.getProperty();\n29             if (prop.getCreatorIndex() >= 0) {\n30                 buffer.assignParameter(prop, values[i]);\n31                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n32                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n33                     buffer.assignParameter(typeProp, typeId);\n34                 }\n35             }\n36         }\n37         Object bean = creator.build(ctxt, buffer);\n38         for (int i = 0; i < len; ++i) {\n39             SettableBeanProperty prop = _properties[i].getProperty();\n40             if (prop.getCreatorIndex() < 0) {\n41                 prop.set(bean, values[i]);\n42             }\n43         }\n44         return bean;\n45     }\n", "fixed_code": "    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n            if (typeId == null) {\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                if (!extProp.hasDefaultType()) {\n                    ctxt.reportInputMismatch(_beanType,\n                            \"Missing external type id property '%s'\",\n                            extProp.getTypePropertyName());\n                } else {\n                    typeId = extProp.getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = extProp.getProperty();\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            values[i] = _deserialize(p, ctxt, i, typeId);\n            final SettableBeanProperty prop = extProp.getProperty();\n            if (prop.getCreatorIndex() >= 0) {\n                buffer.assignParameter(prop, values[i]);\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    final Object v;\n                    if (typeProp.getType().hasRawClass(String.class)) {\n                        v = typeId;\n                    } else {\n                        TokenBuffer tb = new TokenBuffer(p, ctxt);\n                        tb.writeString(typeId);\n                        v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt);\n                        tb.close();\n                    }\n                    buffer.assignParameter(typeProp, v);\n                }\n            }\n        }\n        Object bean = creator.build(ctxt, buffer);\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (prop.getCreatorIndex() < 0) {\n                prop.set(bean, values[i]);\n            }\n        }\n        return bean;\n    }\n"}
{"bug_id": "Math-69", "buggy_code": "1     public RealMatrix getCorrelationPValues() throws MathException {\n2         TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n3         int nVars = correlationMatrix.getColumnDimension();\n4         double[][] out = new double[nVars][nVars];\n5         for (int i = 0; i < nVars; i++) {\n6             for (int j = 0; j < nVars; j++) {\n7                 if (i == j) {\n8                     out[i][j] = 0d;\n9                 } else {\n10                     double r = correlationMatrix.getEntry(i, j);\n11                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n12                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n13                 }\n14             }\n15         }\n16         return new BlockRealMatrix(out);\n17     }\n", "fixed_code": "    public RealMatrix getCorrelationPValues() throws MathException {\n        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n                if (i == j) {\n                    out[i][j] = 0d;\n                } else {\n                    double r = correlationMatrix.getEntry(i, j);\n                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n                }\n            }\n        }\n        return new BlockRealMatrix(out);\n    }\n"}
{"bug_id": "Csv-11", "buggy_code": "1     private Map<String, Integer> initializeHeader() throws IOException {\n2         Map<String, Integer> hdrMap = null;\n3         final String[] formatHeader = this.format.getHeader();\n4         if (formatHeader != null) {\n5             hdrMap = new LinkedHashMap<String, Integer>();\n6             String[] headerRecord = null;\n7             if (formatHeader.length == 0) {\n8                 final CSVRecord nextRecord = this.nextRecord();\n9                 if (nextRecord != null) {\n10                     headerRecord = nextRecord.values();\n11                 }\n12             } else {\n13                 if (this.format.getSkipHeaderRecord()) {\n14                     this.nextRecord();\n15                 }\n16                 headerRecord = formatHeader;\n17             }\n18             if (headerRecord != null) {\n19                 for (int i = 0; i < headerRecord.length; i++) {\n20                     final String header = headerRecord[i];\n21                     final boolean containsHeader = hdrMap.containsKey(header);\n22                     final boolean emptyHeader = header.trim().isEmpty();\n23                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n24                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n25                                 \"\\\" in \" + Arrays.toString(headerRecord));\n26                     }\n27                     hdrMap.put(header, Integer.valueOf(i));\n28                 }\n29             }\n30         }\n31         return hdrMap;\n32     }\n", "fixed_code": "    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n"}
{"bug_id": "Closure-97", "buggy_code": "1   private Node tryFoldShift(Node n, Node left, Node right) {\n2     if (left.getType() == Token.NUMBER &&\n3         right.getType() == Token.NUMBER) {\n4       double result;\n5       double lval = left.getDouble();\n6       double rval = right.getDouble();\n7       if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n8         error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n9         return n;\n10       }\n11       if (!(rval >= 0 && rval < 32)) {\n12         error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n13         return n;\n14       }\n15       int lvalInt = (int) lval;\n16       if (lvalInt != lval) {\n17         error(FRACTIONAL_BITWISE_OPERAND, left);\n18         return n;\n19       }\n20       int rvalInt = (int) rval;\n21       if (rvalInt != rval) {\n22         error(FRACTIONAL_BITWISE_OPERAND, right);\n23         return n;\n24       }\n25       switch (n.getType()) {\n26         case Token.LSH:\n27           result = lvalInt << rvalInt;\n28           break;\n29         case Token.RSH:\n30           result = lvalInt >> rvalInt;\n31           break;\n32         case Token.URSH:\n33           result = lvalInt >>> rvalInt;\n34           break;\n35         default:\n36           throw new AssertionError(\"Unknown shift operator: \" +\n37               Node.tokenToName(n.getType()));\n38       }\n39       Node newNumber = Node.newNumber(result);\n40       n.getParent().replaceChild(n, newNumber);\n41       reportCodeChange();\n42       return newNumber;\n43     }\n44     return n;\n45   }\n", "fixed_code": "  private Node tryFoldShift(Node n, Node left, Node right) {\n    if (left.getType() == Token.NUMBER &&\n        right.getType() == Token.NUMBER) {\n      double result;\n      double lval = left.getDouble();\n      double rval = right.getDouble();\n      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n        return n;\n      }\n      if (!(rval >= 0 && rval < 32)) {\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      }\n      int lvalInt = (int) lval;\n      if (lvalInt != lval) {\n        error(FRACTIONAL_BITWISE_OPERAND, left);\n        return n;\n      }\n      int rvalInt = (int) rval;\n      if (rvalInt != rval) {\n        error(FRACTIONAL_BITWISE_OPERAND, right);\n        return n;\n      }\n      switch (n.getType()) {\n        case Token.LSH:\n          result = lvalInt << rvalInt;\n          break;\n        case Token.RSH:\n          result = lvalInt >> rvalInt;\n          break;\n        case Token.URSH:\n          long lvalLong = lvalInt & 0xffffffffL;\n          result = lvalLong >>> rvalInt;\n          break;\n        default:\n          throw new AssertionError(\"Unknown shift operator: \" +\n              Node.tokenToName(n.getType()));\n      }\n      Node newNumber = Node.newNumber(result);\n      n.getParent().replaceChild(n, newNumber);\n      reportCodeChange();\n      return newNumber;\n    }\n    return n;\n  }\n"}
{"bug_id": "Jsoup-2", "buggy_code": "1     private void parseStartTag() {\n2         tq.consume(\"<\");\n3         String tagName = tq.consumeWord();\n4         if (tagName.length() == 0) { \n5             tq.addFirst(\"&lt;\");\n6             parseTextNode();\n7             return;\n8         }\n9         Attributes attributes = new Attributes();\n10         while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n11             Attribute attribute = parseAttribute();\n12             if (attribute != null)\n13                 attributes.put(attribute);\n14         }\n15         Tag tag = Tag.valueOf(tagName);\n16         Element child = new Element(tag, baseUri, attributes);\n17         boolean isEmptyElement = tag.isEmpty(); \n18         if (tq.matchChomp(\"/>\")) { \n19             isEmptyElement = true;\n20         } else {\n21             tq.matchChomp(\">\");\n22         }\n23         addChildToParent(child, isEmptyElement);\n24         if (tag.isData()) {\n25             String data = tq.chompTo(\"</\" + tagName);\n26             tq.chompTo(\">\");\n27             Node dataNode;\n28             if (tag.equals(titleTag) || tag.equals(textareaTag)) \n29                 dataNode = TextNode.createFromEncoded(data, baseUri);\n30             else\n31                 dataNode = new DataNode(data, baseUri); \n32             child.appendChild(dataNode);   \n33         }\n34         if (child.tagName().equals(\"base\")) {\n35             String href = child.absUrl(\"href\");\n36             if (href.length() != 0) { \n37                 baseUri = href;\n38                 doc.setBaseUri(href); \n39             }\n40         }\n41     }\n", "fixed_code": "    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeWord();\n        if (tagName.length() == 0) { \n            tq.addFirst(\"&lt;\");\n            parseTextNode();\n            return;\n        }\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n        boolean isEmptyElement = tag.isEmpty(); \n        if (tq.matchChomp(\"/>\")) { \n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n        addChildToParent(child, isEmptyElement);\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            tq.chompTo(\">\");\n            popStackToClose(tag);\n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) \n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); \n            child.appendChild(dataNode);   \n        }\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { \n                baseUri = href;\n                doc.setBaseUri(href); \n            }\n        }\n    }\n"}
{"bug_id": "Jsoup-88", "buggy_code": "1     public String getValue() {\n2         return val;\n3     }\n", "fixed_code": "    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }\n"}
{"bug_id": "Jsoup-86", "buggy_code": "1     public XmlDeclaration asXmlDeclaration() {\n2         String data = getData();\n3         Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n4         XmlDeclaration decl = null;\n5         if (doc.childNodeSize() > 0) {\n6             Element el = doc.child(0);\n7             decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n8             decl.attributes().addAll(el.attributes());\n9         }\n10         return decl;\n11     }\n", "fixed_code": "    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n        if (doc.children().size() > 0) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n"}
{"bug_id": "Closure-105", "buggy_code": "1   void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n2                          Node parent) {\n3     if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n4       return;\n5     }\n6     Node arrayNode = left.getFirstChild();\n7     Node functionName = arrayNode.getNext();\n8     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n9         !functionName.getString().equals(\"join\")) {\n10       return;\n11     }\n12     String joinString = NodeUtil.getStringValue(right);\n13     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n14     StringBuilder sb = new StringBuilder();\n15     int foldedSize = 0;\n16     Node elem = arrayNode.getFirstChild();\n17     while (elem != null) {\n18       if (NodeUtil.isImmutableValue(elem)) {\n19         if (sb.length() > 0) {\n20           sb.append(joinString);\n21         }\n22         sb.append(NodeUtil.getStringValue(elem));\n23       } else {\n24         if (sb.length() > 0) {\n25           foldedSize += sb.length() + 2;\n26           arrayFoldedChildren.add(Node.newString(sb.toString()));\n27           sb = new StringBuilder();\n28         }\n29         foldedSize += InlineCostEstimator.getCost(elem);\n30         arrayFoldedChildren.add(elem);\n31       }\n32       elem = elem.getNext();\n33     }\n34     if (sb.length() > 0) {\n35       foldedSize += sb.length() + 2;\n36       arrayFoldedChildren.add(Node.newString(sb.toString()));\n37     }\n38     foldedSize += arrayFoldedChildren.size() - 1;\n39     int originalSize = InlineCostEstimator.getCost(n);\n40     switch (arrayFoldedChildren.size()) {\n41       case 0:\n42         Node emptyStringNode = Node.newString(\"\");\n43         parent.replaceChild(n, emptyStringNode);\n44         break;\n45       case 1:\n46         Node foldedStringNode = arrayFoldedChildren.remove(0);\n47         if (foldedSize > originalSize) {\n48           return;\n49         }\n50         arrayNode.detachChildren();\n51         if (foldedStringNode.getType() != Token.STRING) {\n52           Node replacement = new Node(Token.ADD,\n53               Node.newString(\"\"), foldedStringNode);\n54           foldedStringNode = replacement;\n55         }\n56         parent.replaceChild(n, foldedStringNode);\n57         break;\n58       default:\n59         if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n60           return;\n61         }\n62         int kJoinOverhead = \"[].join()\".length();\n63         foldedSize += kJoinOverhead;\n64         foldedSize += InlineCostEstimator.getCost(right);\n65         if (foldedSize > originalSize) {\n66           return;\n67         }\n68         arrayNode.detachChildren();\n69         for (Node node : arrayFoldedChildren) {\n70           arrayNode.addChildToBack(node);\n71         }\n72         break;\n73     }\n74     t.getCompiler().reportCodeChange();\n75   }\n", "fixed_code": "  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(elem));\n      } else {\n        if (sb != null) {\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n    if (sb != null) {\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n"}
{"bug_id": "Compress-21", "buggy_code": "1     private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n2         int cache = 0;\n3         int shift = 7;\n4         for (int i = 0; i < length; i++) {\n5             cache |= ((bits.get(i) ? 1 : 0) << shift);\n6             --shift;\n7             if (shift == 0) {\n8                 header.write(cache);\n9                 shift = 7;\n10                 cache = 0;\n11             }\n12         }\n13         if (length > 0 && shift > 0) {\n14             header.write(cache);\n15         }\n16     }\n", "fixed_code": "    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n            if (--shift < 0) {\n                header.write(cache);\n                shift = 7;\n                cache = 0;\n            }\n        }\n        if (shift != 7) {\n            header.write(cache);\n        }\n    }\n"}
{"bug_id": "Codec-2", "buggy_code": "1     void encode(byte[] in, int inPos, int inAvail) {\n2         if (eof) {\n3             return;\n4         }\n5         if (inAvail < 0) {\n6             eof = true;\n7             if (buf == null || buf.length - pos < encodeSize) {\n8                 resizeBuf();\n9             }\n10             switch (modulus) {\n11                 case 1:\n12                     buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n13                     buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n14                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n15                         buf[pos++] = PAD;\n16                         buf[pos++] = PAD;\n17                     }\n18                     break;\n19                 case 2:\n20                     buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n21                     buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n22                     buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n23                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n24                         buf[pos++] = PAD;\n25                     }\n26                     break;\n27             }\n28             if (lineLength > 0) {\n29                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n30                 pos += lineSeparator.length;\n31             }\n32         } else {\n33             for (int i = 0; i < inAvail; i++) {\n34                 if (buf == null || buf.length - pos < encodeSize) {\n35                     resizeBuf();\n36                 }\n37                 modulus = (++modulus) % 3;\n38                 int b = in[inPos++];\n39                 if (b < 0) { b += 256; }\n40                 x = (x << 8) + b;\n41                 if (0 == modulus) {\n42                     buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n43                     buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n44                     buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n45                     buf[pos++] = encodeTable[x & MASK_6BITS];\n46                     currentLinePos += 4;\n47                     if (lineLength > 0 && lineLength <= currentLinePos) {\n48                         System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n49                         pos += lineSeparator.length;\n50                         currentLinePos = 0;\n51                     }\n52                 }\n53             }\n54         }\n55     }\n", "fixed_code": "    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            switch (modulus) {\n                case 1:\n                    buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n"}
{"bug_id": "JacksonDatabind-76", "buggy_code": "1     protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n2     \t\tDeserializationContext ctxt)\n3         throws IOException, JsonProcessingException\n4     {\n5         final PropertyBasedCreator creator = _propertyBasedCreator;\n6         PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n7         TokenBuffer tokens = new TokenBuffer(p, ctxt);\n8         tokens.writeStartObject();\n9         JsonToken t = p.getCurrentToken();\n10         for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n11             String propName = p.getCurrentName();\n12             p.nextToken(); \n13             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n14             if (creatorProp != null) {\n15                 if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n16                     t = p.nextToken();\n17                     Object bean;\n18                     try {\n19                         bean = creator.build(ctxt, buffer);\n20                     } catch (Exception e) {\n21                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n22                         continue;\n23                     }\n24                     while (t == JsonToken.FIELD_NAME) {\n25                         p.nextToken();\n26                         tokens.copyCurrentStructure(p);\n27                         t = p.nextToken();\n28                     }\n29                     tokens.writeEndObject();\n30                     if (bean.getClass() != _beanType.getRawClass()) {\n31                         ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n32                         return null;\n33                     }\n34                     return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n35                 }\n36                 continue;\n37             }\n38             if (buffer.readIdProperty(propName)) {\n39                 continue;\n40             }\n41             SettableBeanProperty prop = _beanProperties.find(propName);\n42             if (prop != null) {\n43                 buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n44                 continue;\n45             }\n46             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n47                 handleIgnoredProperty(p, ctxt, handledType(), propName);\n48                 continue;\n49             }\n50             tokens.writeFieldName(propName);\n51             tokens.copyCurrentStructure(p);\n52             if (_anySetter != null) {\n53                 buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n54             }\n55         }\n56         Object bean;\n57         try {\n58             bean = creator.build(ctxt, buffer);\n59         } catch (Exception e) {\n60             return wrapInstantiationProblem(e, ctxt);\n61         }\n62         return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n63     }\n", "fixed_code": "    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); \n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n                continue;\n            }\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n        }\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n"}
{"bug_id": "Mockito-20", "buggy_code": "1     public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n2         if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n3             throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n4         }\n5         Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n6                 settings.getTypeToMock(),\n7                 settings.getExtraInterfaces()\n8         );\n9         T mockInstance = null;\n10         try {\n11             mockInstance = classInstantiator.instantiate(mockedProxyType);\n12             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n13             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n14             return ensureMockIsAssignableToMockedType(settings, mockInstance);\n15         } catch (ClassCastException cce) {\n16             throw new MockitoException(join(\n17                     \"ClassCastException occurred while creating the mockito mock :\",\n18                     \"  class to mock : \" + describeClass(mockedProxyType),\n19                     \"  created class : \" + describeClass(settings.getTypeToMock()),\n20                     \"  proxy instance class : \" + describeClass(mockInstance),\n21                     \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n22                     \"\",\n23                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n24                     \"\"\n25             ),cce);\n26         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n27             throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n28         }\n29     }\n", "fixed_code": "    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n        }\n        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n                settings.getTypeToMock(),\n                settings.getExtraInterfaces()\n        );\n        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);\n        T mockInstance = null;\n        try {\n            mockInstance = instantiator.newInstance(mockedProxyType);\n            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n        } catch (ClassCastException cce) {\n            throw new MockitoException(join(\n                    \"ClassCastException occurred while creating the mockito mock :\",\n                    \"  class to mock : \" + describeClass(mockedProxyType),\n                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n                    \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n                    \"\",\n                    \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                    \"\"\n            ),cce);\n        } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        }\n    }\n"}
{"bug_id": "Jsoup-39", "buggy_code": "1     static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n2         String docData;\n3         Document doc = null;\n4         if (charsetName == null) { \n5             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n6             doc = parser.parseInput(docData, baseUri);\n7             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n8             if (meta != null) { \n9                 String foundCharset;\n10                 if (meta.hasAttr(\"http-equiv\")) {\n11                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n12                     if (foundCharset == null && meta.hasAttr(\"charset\")) {\n13                         try {\n14                             if (Charset.isSupported(meta.attr(\"charset\"))) {\n15                                 foundCharset = meta.attr(\"charset\");\n16                             }\n17                         } catch (IllegalCharsetNameException e) {\n18                             foundCharset = null;\n19                         }\n20                     }\n21                 } else {\n22                     foundCharset = meta.attr(\"charset\");\n23                 }\n24                 if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { \n25                     foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n26                     charsetName = foundCharset;\n27                     byteData.rewind();\n28                     docData = Charset.forName(foundCharset).decode(byteData).toString();\n29                     doc = null;\n30                 }\n31             }\n32         } else { \n33             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n34             docData = Charset.forName(charsetName).decode(byteData).toString();\n35         }\n36         if (docData.length() > 0 && docData.charAt(0) == 65279) {\n37             byteData.rewind();\n38             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n39             docData = docData.substring(1);\n40             charsetName = defaultCharset;\n41         }\n42         if (doc == null) {\n43             doc = parser.parseInput(docData, baseUri);\n44             doc.outputSettings().charset(charsetName);\n45         }\n46         return doc;\n47     }\n", "fixed_code": "    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { \n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { \n                String foundCharset;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                    if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                        try {\n                            if (Charset.isSupported(meta.attr(\"charset\"))) {\n                                foundCharset = meta.attr(\"charset\");\n                            }\n                        } catch (IllegalCharsetNameException e) {\n                            foundCharset = null;\n                        }\n                    }\n                } else {\n                    foundCharset = meta.attr(\"charset\");\n                }\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { \n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { \n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (docData.length() > 0 && docData.charAt(0) == 65279) {\n            byteData.rewind();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1);\n            charsetName = defaultCharset;\n            doc = null;\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n"}
{"bug_id": "Jsoup-90", "buggy_code": "1         private static boolean looksLikeUtf8(byte[] input) {\n2             int i = 0;\n3             if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n4                 && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n5                 i = 3;\n6             }\n7             int end;\n8             for (int j = input.length; i < j; ++i) {\n9                 int o = input[i];\n10                 if ((o & 0x80) == 0) {\n11                     continue; \n12                 }\n13                 if ((o & 0xE0) == 0xC0) {\n14                     end = i + 1;\n15                 } else if ((o & 0xF0) == 0xE0) {\n16                     end = i + 2;\n17                 } else if ((o & 0xF8) == 0xF0) {\n18                     end = i + 3;\n19                 } else {\n20                     return false;\n21                 }\n22                 while (i < end) {\n23                     i++;\n24                     o = input[i];\n25                     if ((o & 0xC0) != 0x80) {\n26                         return false;\n27                     }\n28                 }\n29             }\n30             return true;\n31         }\n", "fixed_code": "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; \n                }\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n                if (end >= input.length)\n                    return false;\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n"}
{"bug_id": "Time-5", "buggy_code": "1     public Period normalizedStandard(PeriodType type) {\n2         type = DateTimeUtils.getPeriodType(type);\n3         long millis = getMillis();  \n4         millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n5         millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n6         millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n7         millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n8         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n9         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n10         int years = getYears();\n11         int months = getMonths();\n12         if (years != 0 || months != 0) {\n13             years = FieldUtils.safeAdd(years, months / 12);\n14             months = months % 12;\n15             if (years != 0) {\n16                 result = result.withYears(years);\n17             }\n18             if (months != 0) {\n19                 result = result.withMonths(months);\n20             }\n21         }\n22         return result;\n23     }\n", "fixed_code": "    public Period normalizedStandard(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n        long millis = getMillis();  \n        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n        int years = getYears();\n        int months = getMonths();\n        if (years != 0 || months != 0) {\n            long totalMonths = years * 12L + months;\n            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\n                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);\n                result = result.withYears(normalizedYears);\n                totalMonths = totalMonths - (normalizedYears * 12);\n            }\n            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\n                int normalizedMonths = FieldUtils.safeToInt(totalMonths);\n                result = result.withMonths(normalizedMonths);\n                totalMonths = totalMonths - normalizedMonths;\n            }\n            if (totalMonths != 0) {\n                throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());\n            }\n        }\n        return result;\n    }\n"}
{"bug_id": "Mockito-5", "buggy_code": "1     public void verify(VerificationData data) {\n2         AssertionError error = null;\n3         timer.start();\n4         while (timer.isCounting()) {\n5             try {\n6                 delegate.verify(data);\n7                 if (returnOnSuccess) {\n8                     return;\n9                 } else {\n10                     error = null;\n11                 }\n12             } catch (MockitoAssertionError e) {\n13                 error = handleVerifyException(e);\n14             }\n15             catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n16                 error = handleVerifyException(e);\n17             }\n18         }\n19         if (error != null) {\n20             throw error;\n21         }\n22     }\n", "fixed_code": "    public void verify(VerificationData data) {\n        AssertionError error = null;\n        timer.start();\n        while (timer.isCounting()) {\n            try {\n                delegate.verify(data);\n                if (returnOnSuccess) {\n                    return;\n                } else {\n                    error = null;\n                }\n            } catch (MockitoAssertionError e) {\n                error = handleVerifyException(e);\n            }\n            catch (AssertionError e) {\n                error = handleVerifyException(e);\n            }\n        }\n        if (error != null) {\n            throw error;\n        }\n    }\n"}
{"bug_id": "Lang-17", "buggy_code": "1     public final void translate(CharSequence input, Writer out) throws IOException {\n2         if (out == null) {\n3             throw new IllegalArgumentException(\"The Writer must not be null\");\n4         }\n5         if (input == null) {\n6             return;\n7         }\n8         int pos = 0;\n9         int len = Character.codePointCount(input, 0, input.length());\n10         while (pos < len) {\n11             int consumed = translate(input, pos, out);\n12             if (consumed == 0) {\n13                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n14                 out.write(c);\n15             }\n16             else {\n17             for (int pt = 0; pt < consumed; pt++) {\n18                     if (pos < len - 2) {\n19                 pos += Character.charCount(Character.codePointAt(input, pos));\n20                     } else {\n21                         pos++;\n22                     }\n23                 }\n24                 pos--;\n25             }\n26             pos++;\n27         }\n28     }\n", "fixed_code": "    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n            }\n        }\n    }\n"}
{"bug_id": "Compress-1", "buggy_code": "1     public void close() throws IOException {\n2         if (!this.closed) {\n3             super.close();\n4             this.closed = true;\n5         }\n6     }\n", "fixed_code": "    public void close() throws IOException {\n        if (!this.closed) {\n            this.finish();\n            super.close();\n            this.closed = true;\n        }\n    }\n"}
{"bug_id": "Closure-22", "buggy_code": "1   public void visit(NodeTraversal t, Node n, Node parent) {\n2     if (n.isEmpty() ||\n3         n.isComma()) {\n4       return;\n5     }\n6     if (parent == null) {\n7       return;\n8     }\n9     if (parent.getType() == Token.COMMA) {\n10       Node gramps = parent.getParent();\n11       if (gramps.isCall() && parent == gramps.getFirstChild()) {\n12         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n13       return;\n14         }\n15     }\n16       if (n == parent.getLastChild()) {\n17         for (Node an : parent.getAncestors()) {\n18           int ancestorType = an.getType();\n19           if (ancestorType == Token.COMMA)\n20             continue;\n21           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n22             return;\n23           else\n24             break;\n25         }\n26       }\n27     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n28       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n29            n == parent.getFirstChild().getNext().getNext())) {\n30       } else {\n31       return;\n32       }\n33     }\n34     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n35     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n36     if (!isResultUsed &&\n37         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n38       if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n39         return;\n40       } else if (n.isExprResult()) {\n41         return;\n42       }\n43       String msg = \"This code lacks side-effects. Is there a bug?\";\n44       if (n.isString()) {\n45         msg = \"Is there a missing '+' on the previous line?\";\n46       } else if (isSimpleOp) {\n47         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n48             \"' operator is not being used.\";\n49       }\n50       t.getCompiler().report(\n51           t.makeError(n, level, USELESS_CODE_ERROR, msg));\n52       if (!NodeUtil.isStatement(n)) {\n53         problemNodes.add(n);\n54       }\n55     }\n56   }\n", "fixed_code": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n    if (parent == null) {\n      return;\n    }\n    if (n.isExprResult() || n.isBlock()) {\n      return;\n    }\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"}
{"bug_id": "JacksonCore-25", "buggy_code": "1     private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n2     {\n3         _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n4         char[] outBuf = _textBuffer.getCurrentSegment();\n5         int outPtr = _textBuffer.getCurrentSegmentSize();\n6         final int maxCode = codes.length;\n7         while (true) {\n8             if (_inputPtr >= _inputEnd) {\n9                 if (!_loadMore()) { \n10                     break;\n11                 }\n12             }\n13             char c = _inputBuffer[_inputPtr];\n14             int i = (int) c;\n15             if (i <= maxCode) {\n16                 if (codes[i] != 0) {\n17                     break;\n18                 }\n19             } else if (!Character.isJavaIdentifierPart(c)) {\n20                 break;\n21             }\n22             ++_inputPtr;\n23             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n24             outBuf[outPtr++] = c;\n25             if (outPtr >= outBuf.length) {\n26                 outBuf = _textBuffer.finishCurrentSegment();\n27                 outPtr = 0;\n28             }\n29         }\n30         _textBuffer.setCurrentLength(outPtr);\n31         {\n32             TextBuffer tb = _textBuffer;\n33             char[] buf = tb.getTextBuffer();\n34             int start = tb.getTextOffset();\n35             int len = tb.size();\n36             return _symbols.findSymbol(buf, start, len, hash);\n37         }\n38     }\n", "fixed_code": "    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { \n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            outBuf[outPtr++] = c;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n"}
{"bug_id": "Lang-44", "buggy_code": "1     public static Number createNumber(String val) throws NumberFormatException {\n2         if (val == null) {\n3             return null;\n4         }\n5         if (val.length() == 0) {\n6             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n7         }\n8         if (val.startsWith(\"--\")) {\n9             return null;\n10         }\n11         if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n12             return createInteger(val);\n13         }   \n14         char lastChar = val.charAt(val.length() - 1);\n15         String mant;\n16         String dec;\n17         String exp;\n18         int decPos = val.indexOf('.');\n19         int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n20         if (decPos > -1) {\n21             if (expPos > -1) {\n22                 if (expPos < decPos) {\n23                     throw new NumberFormatException(val + \" is not a valid number.\");\n24                 }\n25                 dec = val.substring(decPos + 1, expPos);\n26             } else {\n27                 dec = val.substring(decPos + 1);\n28             }\n29             mant = val.substring(0, decPos);\n30         } else {\n31             if (expPos > -1) {\n32                 mant = val.substring(0, expPos);\n33             } else {\n34                 mant = val;\n35             }\n36             dec = null;\n37         }\n38         if (!Character.isDigit(lastChar)) {\n39             if (expPos > -1 && expPos < val.length() - 1) {\n40                 exp = val.substring(expPos + 1, val.length() - 1);\n41             } else {\n42                 exp = null;\n43             }\n44             String numeric = val.substring(0, val.length() - 1);\n45             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n46             switch (lastChar) {\n47                 case 'l' :\n48                 case 'L' :\n49                     if (dec == null\n50                         && exp == null\n51                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n52                         try {\n53                             return createLong(numeric);\n54                         } catch (NumberFormatException nfe) {\n55                         }\n56                         return createBigInteger(numeric);\n57                     }\n58                     throw new NumberFormatException(val + \" is not a valid number.\");\n59                 case 'f' :\n60                 case 'F' :\n61                     try {\n62                         Float f = NumberUtils.createFloat(numeric);\n63                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n64                             return f;\n65                         }\n66                     } catch (NumberFormatException e) {\n67                     }\n68                 case 'd' :\n69                 case 'D' :\n70                     try {\n71                         Double d = NumberUtils.createDouble(numeric);\n72                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n73                             return d;\n74                         }\n75                     } catch (NumberFormatException nfe) {\n76                     }\n77                     try {\n78                         return createBigDecimal(numeric);\n79                     } catch (NumberFormatException e) {\n80                     }\n81                 default :\n82                     throw new NumberFormatException(val + \" is not a valid number.\");\n83             }\n84         } else {\n85             if (expPos > -1 && expPos < val.length() - 1) {\n86                 exp = val.substring(expPos + 1, val.length());\n87             } else {\n88                 exp = null;\n89             }\n90             if (dec == null && exp == null) {\n91                 try {\n92                     return createInteger(val);\n93                 } catch (NumberFormatException nfe) {\n94                 }\n95                 try {\n96                     return createLong(val);\n97                 } catch (NumberFormatException nfe) {\n98                 }\n99                 return createBigInteger(val);\n100             } else {\n101                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n102                 try {\n103                     Float f = createFloat(val);\n104                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n105                         return f;\n106                     }\n107                 } catch (NumberFormatException nfe) {\n108                 }\n109                 try {\n110                     Double d = createDouble(val);\n111                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n112                         return d;\n113                     }\n114                 } catch (NumberFormatException nfe) {\n115                 }\n116                 return createBigDecimal(val);\n117             }\n118         }\n119     }\n", "fixed_code": "    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {\n            throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n        if (decPos > -1) {\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                        }\n                        return createBigInteger(numeric);\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (NumberFormatException e) {\n                    }\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                    }\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n        } else {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigInteger(val);\n            } else {\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigDecimal(val);\n            }\n        }\n    }\n"}
{"bug_id": "Chart-9", "buggy_code": "1     public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n2         throws CloneNotSupportedException {\n3         if (start == null) {\n4             throw new IllegalArgumentException(\"Null 'start' argument.\");\n5         }\n6         if (end == null) {\n7             throw new IllegalArgumentException(\"Null 'end' argument.\");\n8         }\n9         if (start.compareTo(end) > 0) {\n10             throw new IllegalArgumentException(\n11                     \"Requires start on or before end.\");\n12         }\n13         boolean emptyRange = false;\n14         int startIndex = getIndex(start);\n15         if (startIndex < 0) {\n16             startIndex = -(startIndex + 1);\n17             if (startIndex == this.data.size()) {\n18                 emptyRange = true;  \n19             }\n20         }\n21         int endIndex = getIndex(end);\n22         if (endIndex < 0) {             \n23             endIndex = -(endIndex + 1); \n24             endIndex = endIndex - 1;    \n25         }\n26         if (endIndex < 0) {\n27             emptyRange = true;\n28         }\n29         if (emptyRange) {\n30             TimeSeries copy = (TimeSeries) super.clone();\n31             copy.data = new java.util.ArrayList();\n32             return copy;\n33         }\n34         else {\n35             return createCopy(startIndex, endIndex);\n36         }\n37     }\n", "fixed_code": "    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             \n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n    }\n"}
{"bug_id": "Closure-81", "buggy_code": "1     Node processFunctionNode(FunctionNode functionNode) {\n2       Name name = functionNode.getFunctionName();\n3       Boolean isUnnamedFunction = false;\n4       if (name == null) {\n5         name = new Name();\n6         name.setIdentifier(\"\");\n7         isUnnamedFunction = true;\n8       }\n9       Node node = newNode(Token.FUNCTION);\n10       Node newName = transform(name);\n11       if (isUnnamedFunction) {\n12         newName.setLineno(functionNode.getLineno());\n13         int lpColumn = functionNode.getAbsolutePosition() +\n14             functionNode.getLp();\n15         newName.setCharno(position2charno(lpColumn));\n16       }\n17       node.addChildToBack(newName);\n18       Node lp = newNode(Token.LP);\n19       Name fnName = functionNode.getFunctionName();\n20       if (fnName != null) {\n21         lp.setLineno(fnName.getLineno());\n22       } else {\n23         lp.setLineno(functionNode.getLineno());\n24       }\n25       int lparenCharno = functionNode.getLp() +\n26           functionNode.getAbsolutePosition();\n27       lp.setCharno(position2charno(lparenCharno));\n28       for (AstNode param : functionNode.getParams()) {\n29         lp.addChildToBack(transform(param));\n30       }\n31       node.addChildToBack(lp);\n32       Node bodyNode = transform(functionNode.getBody());\n33       parseDirectives(bodyNode);\n34       node.addChildToBack(bodyNode);\n35      return node;\n36     }\n", "fixed_code": "    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        newName.setLineno(functionNode.getLineno());\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n      }\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.LP);\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }\n"}
{"bug_id": "Jsoup-50", "buggy_code": "1     static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n2         String docData;\n3         Document doc = null;\n4         if (charsetName == null) { \n5             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n6             doc = parser.parseInput(docData, baseUri);\n7             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n8             if (meta != null) { \n9                 String foundCharset = null;\n10                 if (meta.hasAttr(\"http-equiv\")) {\n11                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n12                 }\n13                 if (foundCharset == null && meta.hasAttr(\"charset\")) {\n14                     try {\n15                         if (Charset.isSupported(meta.attr(\"charset\"))) {\n16                             foundCharset = meta.attr(\"charset\");\n17                         }\n18                     } catch (IllegalCharsetNameException e) {\n19                         foundCharset = null;\n20                     }\n21                 }\n22                 if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { \n23                     foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n24                     charsetName = foundCharset;\n25                     byteData.rewind();\n26                     docData = Charset.forName(foundCharset).decode(byteData).toString();\n27                     doc = null;\n28                 }\n29             }\n30         } else { \n31             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n32             docData = Charset.forName(charsetName).decode(byteData).toString();\n33         }\n34         if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n35             byteData.rewind();\n36             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n37             docData = docData.substring(1);\n38             charsetName = defaultCharset;\n39             doc = null;\n40         }\n41         if (doc == null) {\n42             doc = parser.parseInput(docData, baseUri);\n43             doc.outputSettings().charset(charsetName);\n44         }\n45         return doc;\n46     }\n", "fixed_code": "    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        byteData.mark();\n        byte[] bom = new byte[4];\n        byteData.get(bom);\n        byteData.rewind();\n        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || \n                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { \n            charsetName = \"UTF-32\"; \n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || \n                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            charsetName = \"UTF-16\"; \n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            charsetName = \"UTF-8\"; \n            byteData.position(3); \n        }\n        if (charsetName == null) { \n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { \n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { \n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { \n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n"}
{"bug_id": "Jsoup-55", "buggy_code": "1         void read(Tokeniser t, CharacterReader r) {\n2             char c = r.consume();\n3             switch (c) {\n4                 case '>':\n5                     t.tagPending.selfClosing = true;\n6                     t.emitTagPending();\n7                     t.transition(Data);\n8                     break;\n9                 case eof:\n10                     t.eofError(this);\n11                     t.transition(Data);\n12                     break;\n13                 default:\n14                     t.error(this);\n15                     t.transition(BeforeAttributeName);\n16             }\n17         }\n", "fixed_code": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n        }\n"}
{"bug_id": "Jsoup-49", "buggy_code": "1     protected void addChildren(int index, Node... children) {\n2         Validate.noNullElements(children);\n3         ensureChildNodes();\n4         for (int i = children.length - 1; i >= 0; i--) {\n5             Node in = children[i];\n6             reparentChild(in);\n7             childNodes.add(index, in);\n8         }\n9         reindexChildren(index);\n10     }\n", "fixed_code": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        ensureChildNodes();\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n            reindexChildren(index);\n        }\n    }\n"}
{"bug_id": "Lang-21", "buggy_code": "1     public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n2         if (cal1 == null || cal2 == null) {\n3             throw new IllegalArgumentException(\"The date must not be null\");\n4         }\n5         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n6                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n7                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n8                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n9                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n10                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n11                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n12                 cal1.getClass() == cal2.getClass());\n13     }\n", "fixed_code": "    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n"}
{"bug_id": "Jsoup-43", "buggy_code": "1     private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n2         Validate.notNull(search);\n3         Validate.notNull(elements);\n4         for (int i = 0; i < elements.size(); i++) {\n5             E element = elements.get(i);\n6             if (element.equals(search))\n7                 return i;\n8         }\n9         return null;\n10     }\n", "fixed_code": "    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element == search)\n                return i;\n        }\n        return null;\n    }\n"}
{"bug_id": "Cli-25", "buggy_code": "1     protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n2                                              int nextLineTabStop, String text)\n3     {\n4         int pos = findWrapPos(text, width, 0);\n5         if (pos == -1)\n6         {\n7             sb.append(rtrim(text));\n8             return sb;\n9         }\n10         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n11         if (nextLineTabStop >= width)\n12         {\n13             nextLineTabStop = width - 1;\n14         }\n15         final String padding = createPadding(nextLineTabStop);\n16         while (true)\n17         {\n18             text = padding + text.substring(pos).trim();\n19             pos = findWrapPos(text, width, 0);\n20             if (pos == -1)\n21             {\n22                 sb.append(text);\n23                 return sb;\n24             }\n25             if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n26             {\n27                 pos = width;\n28             }\n29             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n30         }\n31     }\n", "fixed_code": "    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        if (nextLineTabStop >= width)\n        {\n            nextLineTabStop = 1;\n        }\n        final String padding = createPadding(nextLineTabStop);\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n            if (pos == -1)\n            {\n                sb.append(text);\n                return sb;\n            }\n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n"}
{"bug_id": "Lang-59", "buggy_code": "1     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n2         if (width > 0) {\n3             ensureCapacity(size + width);\n4             String str = (obj == null ? getNullText() : obj.toString());\n5             int strLen = str.length();\n6             if (strLen >= width) {\n7                 str.getChars(0, strLen, buffer, size);\n8             } else {\n9                 int padLen = width - strLen;\n10                 str.getChars(0, strLen, buffer, size);\n11                 for (int i = 0; i < padLen; i++) {\n12                     buffer[size + strLen + i] = padChar;\n13                 }\n14             }\n15             size += width;\n16         }\n17         return this;\n18     }\n", "fixed_code": "    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"}
{"bug_id": "Closure-118", "buggy_code": "1     private void handleObjectLit(NodeTraversal t, Node n) {\n2       for (Node child = n.getFirstChild();\n3           child != null;\n4           child = child.getNext()) {\n5         String name = child.getString();\n6         T type = typeSystem.getType(getScope(), n, name);\n7         Property prop = getProperty(name);\n8         if (!prop.scheduleRenaming(child,\n9                                    processProperty(t, prop, type, null))) {\n10           if (propertiesToErrorFor.containsKey(name)) {\n11             compiler.report(JSError.make(\n12                 t.getSourceName(), child, propertiesToErrorFor.get(name),\n13                 Warnings.INVALIDATION, name,\n14                 (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n15           }\n16         }\n17       }\n18     }\n", "fixed_code": "    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        if (child.isQuotedString()) {\n          continue;\n        }\n        String name = child.getString();\n        T type = typeSystem.getType(getScope(), n, name);\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, type, null))) {\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }\n"}
{"bug_id": "JacksonCore-4", "buggy_code": "1     public char[] expandCurrentSegment()\n2     {\n3         final char[] curr = _currentSegment;\n4         final int len = curr.length;\n5         int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n6         return (_currentSegment = Arrays.copyOf(curr, newLen));\n7     }\n", "fixed_code": "    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        final int len = curr.length;\n        int newLen = len + (len >> 1);\n        if (newLen > MAX_SEGMENT_LEN) {\n            newLen = len + (len >> 2);\n        }\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n"}
{"bug_id": "Closure-133", "buggy_code": "1   private String getRemainingJSDocLine() {\n2     String result = stream.getRemainingJSDocLine();\n3     return result;\n4   }\n", "fixed_code": "  private String getRemainingJSDocLine() {\n    String result = stream.getRemainingJSDocLine();\n    unreadToken = NO_UNREAD_TOKEN;\n    return result;\n  }\n"}
{"bug_id": "Jsoup-80", "buggy_code": "1     void insert(Token.Comment commentToken) {\n2         Comment comment = new Comment(commentToken.getData());\n3         Node insert = comment;\n4         if (commentToken.bogus) { \n5             String data = comment.getData();\n6             if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n7                 Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n8                     Element el = doc.child(0);\n9                     insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n10                     insert.attributes().addAll(el.attributes());\n11             }\n12         }\n13         insertNode(insert);\n14     }\n", "fixed_code": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus) { \n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                if (doc.childNodeSize() > 0) {\n                    Element el = doc.child(0);\n                    insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                    insert.attributes().addAll(el.attributes());\n                } \n            }\n        }\n        insertNode(insert);\n    }\n"}
{"bug_id": "Math-48", "buggy_code": "1     protected final double doSolve() {\n2         double x0 = getMin();\n3         double x1 = getMax();\n4         double f0 = computeObjectiveValue(x0);\n5         double f1 = computeObjectiveValue(x1);\n6         if (f0 == 0.0) {\n7             return x0;\n8         }\n9         if (f1 == 0.0) {\n10             return x1;\n11         }\n12         verifyBracketing(x0, x1);\n13         final double ftol = getFunctionValueAccuracy();\n14         final double atol = getAbsoluteAccuracy();\n15         final double rtol = getRelativeAccuracy();\n16         boolean inverted = false;\n17         while (true) {\n18             final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n19             final double fx = computeObjectiveValue(x);\n20             if (fx == 0.0) {\n21                 return x;\n22             }\n23             if (f1 * fx < 0) {\n24                 x0 = x1;\n25                 f0 = f1;\n26                 inverted = !inverted;\n27             } else {\n28                 switch (method) {\n29                 case ILLINOIS:\n30                     f0 *= 0.5;\n31                     break;\n32                 case PEGASUS:\n33                     f0 *= f1 / (f1 + fx);\n34                     break;\n35                 case REGULA_FALSI:\n36                     break;\n37                 default:\n38                     throw new MathInternalError();\n39                 }\n40             }\n41             x1 = x;\n42             f1 = fx;\n43             if (FastMath.abs(f1) <= ftol) {\n44                 switch (allowed) {\n45                 case ANY_SIDE:\n46                     return x1;\n47                 case LEFT_SIDE:\n48                     if (inverted) {\n49                         return x1;\n50                     }\n51                     break;\n52                 case RIGHT_SIDE:\n53                     if (!inverted) {\n54                         return x1;\n55                     }\n56                     break;\n57                 case BELOW_SIDE:\n58                     if (f1 <= 0) {\n59                         return x1;\n60                     }\n61                     break;\n62                 case ABOVE_SIDE:\n63                     if (f1 >= 0) {\n64                         return x1;\n65                     }\n66                     break;\n67                 default:\n68                     throw new MathInternalError();\n69                 }\n70             }\n71             if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n72                                                      atol)) {\n73                 switch (allowed) {\n74                 case ANY_SIDE:\n75                     return x1;\n76                 case LEFT_SIDE:\n77                     return inverted ? x1 : x0;\n78                 case RIGHT_SIDE:\n79                     return inverted ? x0 : x1;\n80                 case BELOW_SIDE:\n81                     return (f1 <= 0) ? x1 : x0;\n82                 case ABOVE_SIDE:\n83                     return (f1 >= 0) ? x1 : x0;\n84                 default:\n85                     throw new MathInternalError();\n86                 }\n87             }\n88         }\n89     }\n", "fixed_code": "    protected final double doSolve() {\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n        boolean inverted = false;\n        while (true) {\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n            if (fx == 0.0) {\n                return x;\n            }\n            if (f1 * fx < 0) {\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    if (x == x1) {\n                        throw new ConvergenceException();\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            x1 = x;\n            f1 = fx;\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"}
{"bug_id": "Closure-25", "buggy_code": "1   private FlowScope traverseNew(Node n, FlowScope scope) {\n2     Node constructor = n.getFirstChild();\n3     scope = traverse(constructor, scope);\n4     JSType constructorType = constructor.getJSType();\n5     JSType type = null;\n6     if (constructorType != null) {\n7       constructorType = constructorType.restrictByNotNullOrUndefined();\n8       if (constructorType.isUnknownType()) {\n9         type = getNativeType(UNKNOWN_TYPE);\n10       } else {\n11         FunctionType ct = constructorType.toMaybeFunctionType();\n12         if (ct == null && constructorType instanceof FunctionType) {\n13           ct = (FunctionType) constructorType;\n14         }\n15         if (ct != null && ct.isConstructor()) {\n16           type = ct.getInstanceType();\n17         }\n18       }\n19     }\n20     n.setJSType(type);\n21     for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n22       scope = traverse(arg, scope);\n23     }\n24     return scope;\n25   }\n", "fixed_code": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n    Node constructor = n.getFirstChild();\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n          backwardsInferenceFromCallSite(n, ct);\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }\n"}
{"bug_id": "Time-4", "buggy_code": "1     public Partial with(DateTimeFieldType fieldType, int value) {\n2         if (fieldType == null) {\n3             throw new IllegalArgumentException(\"The field type must not be null\");\n4         }\n5         int index = indexOf(fieldType);\n6         if (index == -1) {\n7             DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n8             int[] newValues = new int[newTypes.length];\n9             int i = 0;\n10             DurationField unitField = fieldType.getDurationType().getField(iChronology);\n11             if (unitField.isSupported()) {\n12                 for (; i < iTypes.length; i++) {\n13                     DateTimeFieldType loopType = iTypes[i];\n14                     DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n15                     if (loopUnitField.isSupported()) {\n16                         int compare = unitField.compareTo(loopUnitField);\n17                         if (compare > 0) {\n18                             break;\n19                         } else if (compare == 0) {\n20                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n21                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n22                             if (rangeField.compareTo(loopRangeField) > 0) {\n23                                 break;\n24                             }\n25                         }\n26                     }\n27                 }\n28             }\n29             System.arraycopy(iTypes, 0, newTypes, 0, i);\n30             System.arraycopy(iValues, 0, newValues, 0, i);\n31             newTypes[i] = fieldType;\n32             newValues[i] = value;\n33             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n34             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n35             Partial newPartial = new Partial(iChronology, newTypes, newValues);\n36             iChronology.validate(newPartial, newValues);\n37             return newPartial;\n38         }\n39         if (value == getValue(index)) {\n40             return this;\n41         }\n42         int[] newValues = getValues();\n43         newValues = getField(index).set(this, index, newValues, value);\n44         return new Partial(this, newValues);\n45     }\n", "fixed_code": "    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n"}
{"bug_id": "Math-85", "buggy_code": "1     public static double[] bracket(UnivariateRealFunction function,\n2             double initial, double lowerBound, double upperBound, \n3             int maximumIterations) throws ConvergenceException, \n4             FunctionEvaluationException {\n5         if (function == null) {\n6             throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n7         }\n8         if (maximumIterations <= 0)  {\n9             throw MathRuntimeException.createIllegalArgumentException(\n10                   \"bad value for maximum iterations number: {0}\", maximumIterations);\n11         }\n12         if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n13             throw MathRuntimeException.createIllegalArgumentException(\n14                   \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n15                   lowerBound, initial, upperBound);\n16         }\n17         double a = initial;\n18         double b = initial;\n19         double fa;\n20         double fb;\n21         int numIterations = 0 ;\n22         do {\n23             a = Math.max(a - 1.0, lowerBound);\n24             b = Math.min(b + 1.0, upperBound);\n25             fa = function.value(a);\n26             fb = function.value(b);\n27             numIterations++ ;\n28         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n29                 ((a > lowerBound) || (b < upperBound)));\n30         if (fa * fb >= 0.0 ) {\n31             throw new ConvergenceException(\n32                       \"number of iterations={0}, maximum iterations={1}, \" +\n33                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n34                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n35                       numIterations, maximumIterations, initial,\n36                       lowerBound, upperBound, a, b, fa, fb);\n37         }\n38         return new double[]{a, b};\n39     }\n", "fixed_code": "    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n        if (fa * fb > 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        return new double[]{a, b};\n    }\n"}
{"bug_id": "Lang-10", "buggy_code": "1     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n2         boolean wasWhite= false;\n3         for(int i= 0; i<value.length(); ++i) {\n4             char c= value.charAt(i);\n5             if(Character.isWhitespace(c)) {\n6                 if(!wasWhite) {\n7                     wasWhite= true;\n8                     regex.append(\"\\\\s*+\");\n9                 }\n10                 continue;\n11             }\n12             wasWhite= false;\n13             switch(c) {\n14             case '\\'':\n15                 if(unquote) {\n16                     if(++i==value.length()) {\n17                         return regex;\n18                     }\n19                     c= value.charAt(i);\n20                 }\n21                 break;\n22             case '?':\n23             case '[':\n24             case ']':\n25             case '(':\n26             case ')':\n27             case '{':\n28             case '}':\n29             case '\\\\':\n30             case '|':\n31             case '*':\n32             case '+':\n33             case '^':\n34             case '$':\n35             case '.':\n36                 regex.append('\\\\');\n37             }\n38             regex.append(c);\n39         }\n40         return regex;\n41     }\n", "fixed_code": "    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }\n"}
{"bug_id": "Lang-65", "buggy_code": "1     private static void modify(Calendar val, int field, boolean round) {\n2         if (val.get(Calendar.YEAR) > 280000000) {\n3             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n4         }\n5         boolean roundUp = false;\n6         for (int i = 0; i < fields.length; i++) {\n7             for (int j = 0; j < fields[i].length; j++) {\n8                 if (fields[i][j] == field) {\n9                     if (round && roundUp) {\n10                         if (field == DateUtils.SEMI_MONTH) {\n11                             if (val.get(Calendar.DATE) == 1) {\n12                                 val.add(Calendar.DATE, 15);\n13                             } else {\n14                                 val.add(Calendar.DATE, -15);\n15                                 val.add(Calendar.MONTH, 1);\n16                             }\n17                         } else {\n18                             val.add(fields[i][0], 1);\n19                         }\n20                     }\n21                     return;\n22                 }\n23             }\n24             int offset = 0;\n25             boolean offsetSet = false;\n26             switch (field) {\n27                 case DateUtils.SEMI_MONTH:\n28                     if (fields[i][0] == Calendar.DATE) {\n29                         offset = val.get(Calendar.DATE) - 1;\n30                         if (offset >= 15) {\n31                             offset -= 15;\n32                         }\n33                         roundUp = offset > 7;\n34                         offsetSet = true;\n35                     }\n36                     break;\n37                 case Calendar.AM_PM:\n38                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n39                         offset = val.get(Calendar.HOUR_OF_DAY);\n40                         if (offset >= 12) {\n41                             offset -= 12;\n42                         }\n43                         roundUp = offset > 6;\n44                         offsetSet = true;\n45                     }\n46                     break;\n47             }\n48             if (!offsetSet) {\n49                 int min = val.getActualMinimum(fields[i][0]);\n50                 int max = val.getActualMaximum(fields[i][0]);\n51                 offset = val.get(fields[i][0]) - min;\n52                 roundUp = offset > ((max - min) / 2);\n53             }\n54                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n55         }\n56         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n57     }\n", "fixed_code": "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n            if (field == Calendar.SECOND) {\n                done = true;\n            }\n        }\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n            if (field == Calendar.MINUTE) {\n                done = true;\n            }\n        }\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            int offset = 0;\n            boolean offsetSet = false;\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        offset = val.get(Calendar.DATE) - 1;\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                offset = val.get(fields[i][0]) - min;\n                roundUp = offset > ((max - min) / 2);\n            }\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n"}
{"bug_id": "JacksonCore-20", "buggy_code": "1     public void writeEmbeddedObject(Object object) throws IOException {\n2         throw new JsonGenerationException(\"No native support for writing embedded objects\",\n3                 this);\n4     }\n", "fixed_code": "    public void writeEmbeddedObject(Object object) throws IOException {\n        if (object == null) {\n            writeNull();\n            return;\n        }\n        if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n            return;\n        }\n        throw new JsonGenerationException(\"No native support for writing embedded objects of type \"\n                +object.getClass().getName(),\n                this);\n    }\n"}
{"bug_id": "Closure-61", "buggy_code": "1   static boolean functionCallHasSideEffects(\n2       Node callNode, @Nullable AbstractCompiler compiler) {\n3     if (callNode.getType() != Token.CALL) {\n4       throw new IllegalStateException(\n5           \"Expected CALL node, got \" + Token.name(callNode.getType()));\n6     }\n7     if (callNode.isNoSideEffectsCall()) {\n8       return false;\n9     }\n10     Node nameNode = callNode.getFirstChild();\n11     if (nameNode.getType() == Token.NAME) {\n12       String name = nameNode.getString();\n13       if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n14         return false;\n15       }\n16     } else if (nameNode.getType() == Token.GETPROP) {\n17       if (callNode.hasOneChild()\n18           && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n19                 nameNode.getLastChild().getString())) {\n20         return false;\n21       }\n22       if (callNode.isOnlyModifiesThisCall()\n23           && evaluatesToLocalValue(nameNode.getFirstChild())) {\n24         return false;\n25       }\n26       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n27         if (nameNode.getFirstChild().getType() == Token.REGEXP\n28             && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n29           return false;\n30         } else if (nameNode.getFirstChild().getType() == Token.STRING\n31             && STRING_REGEXP_METHODS.contains(\n32                 nameNode.getLastChild().getString())) {\n33           Node param = nameNode.getNext();\n34           if (param != null &&\n35               (param.getType() == Token.STRING\n36                   || param.getType() == Token.REGEXP))\n37           return false;\n38         }\n39       }\n40     }\n41     return true;\n42   }\n", "fixed_code": "  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() != Token.CALL) {\n      throw new IllegalStateException(\n          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n    if (callNode.isNoSideEffectsCall()) {\n      return false;\n    }\n    Node nameNode = callNode.getFirstChild();\n    if (nameNode.getType() == Token.NAME) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.getType() == Token.GETPROP) {\n      if (callNode.hasOneChild()\n          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                nameNode.getLastChild().getString())) {\n        return false;\n      }\n      if (callNode.isOnlyModifiesThisCall()\n          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n      if (nameNode.getFirstChild().getType() == Token.NAME) {\n        String namespaceName = nameNode.getFirstChild().getString();\n        if (namespaceName.equals(\"Math\")) {\n          return false;\n        }\n      }\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().getType() == Token.REGEXP\n            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().getType() == Token.STRING\n            && STRING_REGEXP_METHODS.contains(\n                nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null &&\n              (param.getType() == Token.STRING\n                  || param.getType() == Token.REGEXP))\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n"}
{"bug_id": "Closure-161", "buggy_code": "1   private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n2     Node parent = n.getParent();\n3     if (right.getType() != Token.NUMBER) {\n4       return n;\n5     }\n6     double index = right.getDouble();\n7     int intIndex = (int) index;\n8     if (intIndex != index) {\n9       error(INVALID_GETELEM_INDEX_ERROR, right);\n10       return n;\n11     }\n12     if (intIndex < 0) {\n13       error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n14       return n;\n15     }\n16     Node elem = left.getFirstChild();\n17     for (int i = 0; elem != null && i < intIndex; i++) {\n18       elem = elem.getNext();\n19     }\n20     if (elem == null) {\n21       error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n22       return n;\n23     }\n24     if (elem.getType() == Token.EMPTY) {\n25       elem = NodeUtil.newUndefinedNode(elem);\n26     } else {\n27       left.removeChild(elem);\n28     }\n29     n.getParent().replaceChild(n, elem);\n30     reportCodeChange();\n31     return elem;\n32   }\n", "fixed_code": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    if (isAssignmentTarget(n)) {\n      return n;\n    }\n    if (right.getType() != Token.NUMBER) {\n      return n;\n    }\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n    Node elem = left.getFirstChild();\n    for (int i = 0; elem != null && i < intIndex; i++) {\n      elem = elem.getNext();\n    }\n    if (elem == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n    if (elem.getType() == Token.EMPTY) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      left.removeChild(elem);\n    }\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }\n"}
{"bug_id": "Lang-49", "buggy_code": "1     public Fraction reduce() {\n2         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n3         if (gcd == 1) {\n4             return this;\n5         }\n6         return Fraction.getFraction(numerator / gcd, denominator / gcd);\n7     }\n", "fixed_code": "    public Fraction reduce() {\n        if (numerator == 0) {\n            return equals(ZERO) ? this : ZERO;\n        }\n        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n        if (gcd == 1) {\n            return this;\n        }\n        return Fraction.getFraction(numerator / gcd, denominator / gcd);\n    }\n"}
{"bug_id": "Lang-55", "buggy_code": "1     public void stop() {\n2         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n3             throw new IllegalStateException(\"Stopwatch is not running. \");\n4         }\n5             stopTime = System.currentTimeMillis();\n6         this.runningState = STATE_STOPPED;\n7     }\n", "fixed_code": "    public void stop() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        if(this.runningState == STATE_RUNNING) {\n            stopTime = System.currentTimeMillis();\n        }\n        this.runningState = STATE_STOPPED;\n    }\n"}
{"bug_id": "Closure-53", "buggy_code": "1     private void replaceAssignmentExpression(Var v, Reference ref,\n2                                              Map<String, String> varmap) {\n3       List<Node> nodes = Lists.newArrayList();\n4       Node val = ref.getAssignedValue();\n5       blacklistVarReferencesInTree(val, v.scope);\n6       Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n7       Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n8       for (Node key = val.getFirstChild(); key != null;\n9            key = key.getNext()) {\n10         String var = key.getString();\n11         Node value = key.removeFirstChild();\n12         nodes.add(\n13           new Node(Token.ASSIGN,\n14                    Node.newString(Token.NAME, varmap.get(var)), value));\n15         all.remove(var);\n16       }\n17       for (String var : all) {\n18         nodes.add(\n19           new Node(Token.ASSIGN,\n20                    Node.newString(Token.NAME, varmap.get(var)),\n21                    NodeUtil.newUndefinedNode(null)));\n22       }\n23       Node replacement;\n24         nodes.add(new Node(Token.TRUE));\n25         nodes = Lists.reverse(nodes);\n26         replacement = new Node(Token.COMMA);\n27         Node cur = replacement;\n28         int i;\n29         for (i = 0; i < nodes.size() - 2; i++) {\n30           cur.addChildToFront(nodes.get(i));\n31           Node t = new Node(Token.COMMA);\n32           cur.addChildToFront(t);\n33           cur = t;\n34         }\n35         cur.addChildToFront(nodes.get(i));\n36         cur.addChildToFront(nodes.get(i + 1));\n37       Node replace = ref.getParent();\n38       replacement.copyInformationFromForTree(replace);\n39       if (replace.getType() == Token.VAR) {\n40         replace.getParent().replaceChild(\n41             replace, NodeUtil.newExpr(replacement));\n42       } else {\n43         replace.getParent().replaceChild(replace, replacement);\n44       }\n45     }\n", "fixed_code": "    private void replaceAssignmentExpression(Var v, Reference ref,\n                                             Map<String, String> varmap) {\n      List<Node> nodes = Lists.newArrayList();\n      Node val = ref.getAssignedValue();\n      blacklistVarReferencesInTree(val, v.scope);\n      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n      for (Node key = val.getFirstChild(); key != null;\n           key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(var)), value));\n        all.remove(var);\n      }\n      for (String var : all) {\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(var)),\n                   NodeUtil.newUndefinedNode(null)));\n      }\n      Node replacement;\n      if (nodes.isEmpty()) {\n        replacement = new Node(Token.TRUE);\n      } else {\n        nodes.add(new Node(Token.TRUE));\n        nodes = Lists.reverse(nodes);\n        replacement = new Node(Token.COMMA);\n        Node cur = replacement;\n        int i;\n        for (i = 0; i < nodes.size() - 2; i++) {\n          cur.addChildToFront(nodes.get(i));\n          Node t = new Node(Token.COMMA);\n          cur.addChildToFront(t);\n          cur = t;\n        }\n        cur.addChildToFront(nodes.get(i));\n        cur.addChildToFront(nodes.get(i + 1));\n      }\n      Node replace = ref.getParent();\n      replacement.copyInformationFromForTree(replace);\n      if (replace.getType() == Token.VAR) {\n        replace.getParent().replaceChild(\n            replace, NodeUtil.newExpr(replacement));\n      } else {\n        replace.getParent().replaceChild(replace, replacement);\n      }\n    }\n"}
{"bug_id": "Chart-4", "buggy_code": "1     public Range getDataRange(ValueAxis axis) {\n2         Range result = null;\n3         List mappedDatasets = new ArrayList();\n4         List includedAnnotations = new ArrayList();\n5         boolean isDomainAxis = true;\n6         int domainIndex = getDomainAxisIndex(axis);\n7         if (domainIndex >= 0) {\n8             isDomainAxis = true;\n9             mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n10                     new Integer(domainIndex)));\n11             if (domainIndex == 0) {\n12                 Iterator iterator = this.annotations.iterator();\n13                 while (iterator.hasNext()) {\n14                     XYAnnotation annotation = (XYAnnotation) iterator.next();\n15                     if (annotation instanceof XYAnnotationBoundsInfo) {\n16                         includedAnnotations.add(annotation);\n17                     }\n18                 }\n19             }\n20         }\n21         int rangeIndex = getRangeAxisIndex(axis);\n22         if (rangeIndex >= 0) {\n23             isDomainAxis = false;\n24             mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n25                     new Integer(rangeIndex)));\n26             if (rangeIndex == 0) {\n27                 Iterator iterator = this.annotations.iterator();\n28                 while (iterator.hasNext()) {\n29                     XYAnnotation annotation = (XYAnnotation) iterator.next();\n30                     if (annotation instanceof XYAnnotationBoundsInfo) {\n31                         includedAnnotations.add(annotation);\n32                     }\n33                 }\n34             }\n35         }\n36         Iterator iterator = mappedDatasets.iterator();\n37         while (iterator.hasNext()) {\n38             XYDataset d = (XYDataset) iterator.next();\n39             if (d != null) {\n40                 XYItemRenderer r = getRendererForDataset(d);\n41                 if (isDomainAxis) {\n42                     if (r != null) {\n43                         result = Range.combine(result, r.findDomainBounds(d));\n44                     }\n45                     else {\n46                         result = Range.combine(result,\n47                                 DatasetUtilities.findDomainBounds(d));\n48                     }\n49                 }\n50                 else {\n51                     if (r != null) {\n52                         result = Range.combine(result, r.findRangeBounds(d));\n53                     }\n54                     else {\n55                         result = Range.combine(result,\n56                                 DatasetUtilities.findRangeBounds(d));\n57                     }\n58                 }\n59                     Collection c = r.getAnnotations();\n60                     Iterator i = c.iterator();\n61                     while (i.hasNext()) {\n62                         XYAnnotation a = (XYAnnotation) i.next();\n63                         if (a instanceof XYAnnotationBoundsInfo) {\n64                             includedAnnotations.add(a);\n65                         }\n66                     }\n67             }\n68         }\n69         Iterator it = includedAnnotations.iterator();\n70         while (it.hasNext()) {\n71             XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n72             if (xyabi.getIncludeInDataBounds()) {\n73                 if (isDomainAxis) {\n74                     result = Range.combine(result, xyabi.getXRange());\n75                 }\n76                 else {\n77                     result = Range.combine(result, xyabi.getYRange());\n78                 }\n79             }\n80         }\n81         return result;\n82     }\n", "fixed_code": "    public Range getDataRange(ValueAxis axis) {\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n                if (r != null) {\n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n                }\n            }\n        }\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n        return result;\n    }\n"}
{"bug_id": "Closure-40", "buggy_code": "1     public void visit(NodeTraversal t, Node n, Node parent) {\n2       if (t.inGlobalScope()) {\n3         if (NodeUtil.isVarDeclaration(n)) {\n4           NameInformation ns = createNameInformation(t, n, parent);\n5           Preconditions.checkNotNull(ns);\n6           recordSet(ns.name, n);\n7         } else if (NodeUtil.isFunctionDeclaration(n)) {\n8           Node nameNode = n.getFirstChild();\n9           NameInformation ns = createNameInformation(t, nameNode, n);\n10           if (ns != null) {\n11             JsName nameInfo = getName(nameNode.getString(), true);\n12             recordSet(nameInfo.name, nameNode);\n13           }\n14         } else if (NodeUtil.isObjectLitKey(n, parent)) {\n15           NameInformation ns = createNameInformation(t, n, parent);\n16           if (ns != null) {\n17             recordSet(ns.name, n);\n18           }\n19         }\n20       }\n21       if (n.isAssign()) {\n22         Node nameNode = n.getFirstChild();\n23         NameInformation ns = createNameInformation(t, nameNode, n);\n24         if (ns != null) {\n25           if (ns.isPrototype) {\n26             recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n27           } else {\n28             recordSet(ns.name, nameNode);\n29           }\n30         }\n31       } else if (n.isCall()) {\n32         Node nameNode = n.getFirstChild();\n33         NameInformation ns = createNameInformation(t, nameNode, n);\n34         if (ns != null && ns.onlyAffectsClassDef) {\n35           JsName name = getName(ns.name, false);\n36           if (name != null) {\n37           refNodes.add(new ClassDefiningFunctionNode(\n38               name, n, parent, parent.getParent()));\n39           }\n40         }\n41       }\n42     }\n", "fixed_code": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          Preconditions.checkNotNull(ns);\n          recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n          Node nameNode = n.getFirstChild();\n          NameInformation ns = createNameInformation(t, nameNode, n);\n          if (ns != null) {\n            JsName nameInfo = getName(nameNode.getString(), true);\n            recordSet(nameInfo.name, nameNode);\n          }\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          if (ns != null) {\n            recordSet(ns.name, n);\n          }\n        }\n      }\n      if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n          if (ns.isPrototype) {\n            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n          } else {\n            recordSet(ns.name, nameNode);\n          }\n        }\n      } else if (n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, true);\n          refNodes.add(new ClassDefiningFunctionNode(\n              name, n, parent, parent.getParent()));\n        }\n      }\n    }\n"}
{"bug_id": "JacksonDatabind-24", "buggy_code": "1     public BaseSettings withDateFormat(DateFormat df) {\n2         if (_dateFormat == df) {\n3             return this;\n4         }\n5         TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n6         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n7                 _typeResolverBuilder, df, _handlerInstantiator, _locale,\n8                 tz, _defaultBase64);\n9     }\n", "fixed_code": "    public BaseSettings withDateFormat(DateFormat df) {\n        if (_dateFormat == df) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n"}
{"bug_id": "Math-13", "buggy_code": "1     private RealMatrix squareRoot(RealMatrix m) {\n2             final EigenDecomposition dec = new EigenDecomposition(m);\n3             return dec.getSquareRoot();\n4     }\n", "fixed_code": "    private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n        }\n    }\n"}
{"bug_id": "Codec-18", "buggy_code": "1     public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n2         if (cs1 == cs2) {\n3             return true;\n4         }\n5         if (cs1 == null || cs2 == null) {\n6             return false;\n7         }\n8         if (cs1 instanceof String && cs2 instanceof String) {\n9             return cs1.equals(cs2);\n10         }\n11         return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n12     }\n", "fixed_code": "    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\n    }\n"}
{"bug_id": "JacksonDatabind-93", "buggy_code": "1     public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n2     {\n3         final Class<?> raw = type.getRawClass();\n4         String full = raw.getName();\n5         main_check:\n6         do {\n7             if (_cfgIllegalClassNames.contains(full)) {\n8                 break;\n9             }\n10             if (full.startsWith(PREFIX_STRING)) {\n11                 for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n12                     String name = cls.getSimpleName();\n13                     if (\"AbstractPointcutAdvisor\".equals(name)\n14                             || \"AbstractApplicationContext\".equals(name)) {\n15                         break main_check;\n16                     }\n17                 }\n18             }\n19             return;\n20         } while (false);\n21         throw JsonMappingException.from(ctxt,\n22                 String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n23     }\n", "fixed_code": "    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n            if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {\n                    String name = cls.getSimpleName();\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            }\n            return;\n        } while (false);\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n"}
{"bug_id": "Closure-145", "buggy_code": "1   private boolean isOneExactlyFunctionOrDo(Node n) {\n2       return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n3   }\n", "fixed_code": "  private boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n      Node labeledStatement = n.getLastChild();\n      if (labeledStatement.getType() != Token.BLOCK) {\n        return isOneExactlyFunctionOrDo(labeledStatement);\n      } else {\n        if (getNonEmptyChildCount(n, 2) == 1) { \n          return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));\n        } else {\n          return false;\n        }\n      }\n    } else {\n      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n    }\n  }\n"}
{"bug_id": "Closure-176", "buggy_code": "1   private void updateScopeForTypeChange(\n2       FlowScope scope, Node left, JSType leftType, JSType resultType) {\n3     Preconditions.checkNotNull(resultType);\n4     switch (left.getType()) {\n5       case Token.NAME:\n6         String varName = left.getString();\n7         Var var = syntacticScope.getVar(varName);\n8         boolean isVarDeclaration = left.hasChildren();\n9         boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n10         if (isVarTypeBetter) {\n11           redeclareSimpleVar(scope, left, resultType);\n12         }\n13         left.setJSType(isVarDeclaration || leftType == null ?\n14             resultType : null);\n15         if (var != null && var.isTypeInferred()) {\n16           JSType oldType = var.getType();\n17           var.setType(oldType == null ?\n18               resultType : oldType.getLeastSupertype(resultType));\n19         }\n20         break;\n21       case Token.GETPROP:\n22         String qualifiedName = left.getQualifiedName();\n23         if (qualifiedName != null) {\n24           scope.inferQualifiedSlot(left, qualifiedName,\n25               leftType == null ? unknownType : leftType,\n26               resultType);\n27         }\n28         left.setJSType(resultType);\n29         ensurePropertyDefined(left, resultType);\n30         break;\n31     }\n32   }\n", "fixed_code": "  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n        JSType varType = var == null ? null : var.getType();\n        boolean isVarDeclaration = left.hasChildren()\n            && varType != null && !var.isTypeInferred();\n        boolean isVarTypeBetter = isVarDeclaration &&\n            !resultType.isNullType() && !resultType.isVoidType();\n        if (isVarTypeBetter) {\n          redeclareSimpleVar(scope, left, varType);\n        } else {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(resultType);\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? unknownType : leftType,\n              resultType);\n        }\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }\n"}
{"bug_id": "Cli-35", "buggy_code": "1     public List<String> getMatchingOptions(String opt)\n2     {\n3         opt = Util.stripLeadingHyphens(opt);\n4         List<String> matchingOpts = new ArrayList<String>();\n5         for (String longOpt : longOpts.keySet())\n6         {\n7             if (longOpt.startsWith(opt))\n8             {\n9                 matchingOpts.add(longOpt);\n10             }\n11         }\n12         return matchingOpts;\n13     }\n", "fixed_code": "    public List<String> getMatchingOptions(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n        List<String> matchingOpts = new ArrayList<String>();\n        if(longOpts.keySet().contains(opt)) {\n            return Collections.singletonList(opt);\n        }\n        for (String longOpt : longOpts.keySet())\n        {\n            if (longOpt.startsWith(opt))\n            {\n                matchingOpts.add(longOpt);\n            }\n        }\n        return matchingOpts;\n    }\n"}
{"bug_id": "Closure-119", "buggy_code": "1     public void collect(JSModule module, Scope scope, Node n) {\n2       Node parent = n.getParent();\n3       String name;\n4       boolean isSet = false;\n5       Name.Type type = Name.Type.OTHER;\n6       boolean isPropAssign = false;\n7       switch (n.getType()) {\n8         case Token.GETTER_DEF:\n9         case Token.SETTER_DEF:\n10         case Token.STRING_KEY:\n11           name = null;\n12           if (parent != null && parent.isObjectLit()) {\n13             name = getNameForObjLitKey(n);\n14           }\n15           if (name == null) {\n16             return;\n17           }\n18           isSet = true;\n19           switch (n.getType()) {\n20             case Token.STRING_KEY:\n21               type = getValueType(n.getFirstChild());\n22               break;\n23             case Token.GETTER_DEF:\n24               type = Name.Type.GET;\n25               break;\n26             case Token.SETTER_DEF:\n27               type = Name.Type.SET;\n28               break;\n29             default:\n30               throw new IllegalStateException(\"unexpected:\" + n);\n31           }\n32           break;\n33         case Token.NAME:\n34           if (parent != null) {\n35             switch (parent.getType()) {\n36               case Token.VAR:\n37                 isSet = true;\n38                 Node rvalue = n.getFirstChild();\n39                 type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n40                 break;\n41               case Token.ASSIGN:\n42                 if (parent.getFirstChild() == n) {\n43                   isSet = true;\n44                   type = getValueType(n.getNext());\n45                 }\n46                 break;\n47               case Token.GETPROP:\n48                 return;\n49               case Token.FUNCTION:\n50                 Node gramps = parent.getParent();\n51                 if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n52                   return;\n53                 }\n54                 isSet = true;\n55                 type = Name.Type.FUNCTION;\n56                 break;\n57               case Token.INC:\n58               case Token.DEC:\n59                 isSet = true;\n60                 type = Name.Type.OTHER;\n61                 break;\n62               default:\n63                 if (NodeUtil.isAssignmentOp(parent) &&\n64                     parent.getFirstChild() == n) {\n65                   isSet = true;\n66                   type = Name.Type.OTHER;\n67                 }\n68             }\n69           }\n70           name = n.getString();\n71           break;\n72         case Token.GETPROP:\n73           if (parent != null) {\n74             switch (parent.getType()) {\n75               case Token.ASSIGN:\n76                 if (parent.getFirstChild() == n) {\n77                   isSet = true;\n78                   type = getValueType(n.getNext());\n79                   isPropAssign = true;\n80                 }\n81                 break;\n82               case Token.INC:\n83               case Token.DEC:\n84                 isSet = true;\n85                 type = Name.Type.OTHER;\n86                 break;\n87               case Token.GETPROP:\n88                 return;\n89               default:\n90                 if (NodeUtil.isAssignmentOp(parent) &&\n91                     parent.getFirstChild() == n) {\n92                   isSet = true;\n93                   type = Name.Type.OTHER;\n94                 }\n95             }\n96           }\n97           name = n.getQualifiedName();\n98           if (name == null) {\n99             return;\n100           }\n101           break;\n102         default:\n103           return;\n104       }\n105       if (!isGlobalNameReference(name, scope)) {\n106         return;\n107       }\n108       if (isSet) {\n109         if (isGlobalScope(scope)) {\n110           handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n111         } else {\n112           handleSetFromLocal(module, scope, n, parent, name);\n113         }\n114       } else {\n115         handleGet(module, scope, n, parent, name);\n116       }\n117     }\n", "fixed_code": "    public void collect(JSModule module, Scope scope, Node n) {\n      Node parent = n.getParent();\n      String name;\n      boolean isSet = false;\n      Name.Type type = Name.Type.OTHER;\n      boolean isPropAssign = false;\n      switch (n.getType()) {\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n        case Token.STRING_KEY:\n          name = null;\n          if (parent != null && parent.isObjectLit()) {\n            name = getNameForObjLitKey(n);\n          }\n          if (name == null) {\n            return;\n          }\n          isSet = true;\n          switch (n.getType()) {\n            case Token.STRING_KEY:\n              type = getValueType(n.getFirstChild());\n              break;\n            case Token.GETTER_DEF:\n              type = Name.Type.GET;\n              break;\n            case Token.SETTER_DEF:\n              type = Name.Type.SET;\n              break;\n            default:\n              throw new IllegalStateException(\"unexpected:\" + n);\n          }\n          break;\n        case Token.NAME:\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.VAR:\n                isSet = true;\n                Node rvalue = n.getFirstChild();\n                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n                break;\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                }\n                break;\n              case Token.GETPROP:\n                return;\n              case Token.FUNCTION:\n                Node gramps = parent.getParent();\n                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n                  return;\n                }\n                isSet = true;\n                type = Name.Type.FUNCTION;\n                break;\n              case Token.CATCH:\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getString();\n          break;\n        case Token.GETPROP:\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                  isPropAssign = true;\n                }\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              case Token.GETPROP:\n                return;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getQualifiedName();\n          if (name == null) {\n            return;\n          }\n          break;\n        default:\n          return;\n      }\n      if (!isGlobalNameReference(name, scope)) {\n        return;\n      }\n      if (isSet) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n        } else {\n          handleSetFromLocal(module, scope, n, parent, name);\n        }\n      } else {\n        handleGet(module, scope, n, parent, name);\n      }\n    }\n"}
{"bug_id": "JacksonDatabind-19", "buggy_code": "1     private JavaType _mapType(Class<?> rawClass)\n2     {\n3         JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n4         if (typeParams == null) {\n5             return MapType.construct(rawClass, _unknownType(), _unknownType());\n6         }\n7         if (typeParams.length != 2) {\n8             throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n9         }\n10         return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n11     }\n", "fixed_code": "    private JavaType _mapType(Class<?> rawClass)\n    {\n        if (rawClass == Properties.class) {\n            return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING);\n        }\n        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n        if (typeParams == null) {\n            return MapType.construct(rawClass, _unknownType(), _unknownType());\n        }\n        if (typeParams.length != 2) {\n            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n    }\n"}
{"bug_id": "Closure-56", "buggy_code": "1   public String getLine(int lineNumber) {\n2     String js = \"\";\n3     try {\n4       js = getCode();\n5     } catch (IOException e) {\n6       return null;\n7     }\n8     int pos = 0;\n9     int startLine = 1;\n10     if (lineNumber >= lastLine) {\n11       pos = lastOffset;\n12       startLine = lastLine;\n13     }\n14     for (int n = startLine; n < lineNumber; n++) {\n15       int nextpos = js.indexOf('\\n', pos);\n16       if (nextpos == -1) {\n17         return null;\n18       }\n19       pos = nextpos + 1;\n20     }\n21     lastOffset = pos;\n22     lastLine = lineNumber;\n23     if (js.indexOf('\\n', pos) == -1) {\n24         return null;\n25     } else {\n26       return js.substring(pos, js.indexOf('\\n', pos));\n27     }\n28   }\n", "fixed_code": "  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n    int pos = 0;\n    int startLine = 1;\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n    lastOffset = pos;\n    lastLine = lineNumber;\n    if (js.indexOf('\\n', pos) == -1) {\n      if (pos >= js.length()) {\n        return null;\n      } else {\n        return js.substring(pos, js.length());\n      }\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }\n"}
{"bug_id": "Math-103", "buggy_code": "1     public double cumulativeProbability(double x) throws MathException {\n2             return 0.5 * (1.0 + Erf.erf((x - mean) /\n3                     (standardDeviation * Math.sqrt(2.0))));\n4     }\n", "fixed_code": "    public double cumulativeProbability(double x) throws MathException {\n        try {\n            return 0.5 * (1.0 + Erf.erf((x - mean) /\n                    (standardDeviation * Math.sqrt(2.0))));\n        } catch (MaxIterationsExceededException ex) {\n            if (x < (mean - 20 * standardDeviation)) { \n                return 0.0d;\n            } else if (x > (mean + 20 * standardDeviation)) {\n                return 1.0d;\n            } else {\n                throw ex;\n            }\n        }\n    }\n"}
{"bug_id": "Math-80", "buggy_code": "1     private boolean flipIfWarranted(final int n, final int step) {\n2         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n3             int j = 4 * n - 1;\n4             for (int i = 0; i < j; i += 4) {\n5                 for (int k = 0; k < 4; k += step) {\n6                     final double tmp = work[i + k];\n7                     work[i + k] = work[j - k];\n8                     work[j - k] = tmp;\n9                 }\n10                 j -= 4;\n11             }\n12             return true;\n13         }\n14         return false;\n15     }\n", "fixed_code": "    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            int j = 4 * (n - 1);\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"}
{"bug_id": "Math-41", "buggy_code": "1     public double evaluate(final double[] values, final double[] weights,\n2                            final double mean, final int begin, final int length) {\n3         double var = Double.NaN;\n4         if (test(values, weights, begin, length)) {\n5             if (length == 1) {\n6                 var = 0.0;\n7             } else if (length > 1) {\n8                 double accum = 0.0;\n9                 double dev = 0.0;\n10                 double accum2 = 0.0;\n11                 for (int i = begin; i < begin + length; i++) {\n12                     dev = values[i] - mean;\n13                     accum += weights[i] * (dev * dev);\n14                     accum2 += weights[i] * dev;\n15                 }\n16                 double sumWts = 0;\n17                 for (int i = 0; i < weights.length; i++) {\n18                     sumWts += weights[i];\n19                 }\n20                 if (isBiasCorrected) {\n21                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n22                 } else {\n23                     var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n24                 }\n25             }\n26         }\n27         return var;\n28     }\n", "fixed_code": "    public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n        double var = Double.NaN;\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n                double sumWts = 0;\n                for (int i = begin; i < begin + length; i++) {\n                    sumWts += weights[i];\n                }\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }\n"}
{"bug_id": "Math-17", "buggy_code": "1     public Dfp multiply(final int x) {\n2             return multiplyFast(x);\n3     }\n", "fixed_code": "    public Dfp multiply(final int x) {\n        if (x >= 0 && x < RADIX) {\n            return multiplyFast(x);\n        } else {\n            return multiply(newInstance(x));\n        }\n    }\n"}
{"bug_id": "Math-38", "buggy_code": "1     private void prelim(double[] lowerBound,\n2                         double[] upperBound) {\n3         printMethod(); \n4         final int n = currentBest.getDimension();\n5         final int npt = numberOfInterpolationPoints;\n6         final int ndim = bMatrix.getRowDimension();\n7         final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n8         final double recip = 1d / rhosq;\n9         final int np = n + 1;\n10         for (int j = 0; j < n; j++) {\n11             originShift.setEntry(j, currentBest.getEntry(j));\n12             for (int k = 0; k < npt; k++) {\n13                 interpolationPoints.setEntry(k, j, ZERO);\n14             }\n15             for (int i = 0; i < ndim; i++) {\n16                 bMatrix.setEntry(i, j, ZERO);\n17             }\n18         }\n19         for (int i = 0, max = n * np / 2; i < max; i++) {\n20             modelSecondDerivativesValues.setEntry(i, ZERO);\n21         }\n22         for (int k = 0; k < npt; k++) {\n23             modelSecondDerivativesParameters.setEntry(k, ZERO);\n24             for (int j = 0, max = npt - np; j < max; j++) {\n25                 zMatrix.setEntry(k, j, ZERO);\n26             }\n27         }\n28         int ipt = 0;\n29         int jpt = 0;\n30         double fbeg = Double.NaN;\n31         do {\n32             final int nfm = getEvaluations();\n33             final int nfx = nfm - n;\n34             final int nfmm = nfm - 1;\n35             final int nfxm = nfx - 1;\n36             double stepa = 0;\n37             double stepb = 0;\n38             if (nfm <= 2 * n) {\n39                 if (nfm >= 1 &&\n40                     nfm <= n) {\n41                     stepa = initialTrustRegionRadius;\n42                     if (upperDifference.getEntry(nfmm) == ZERO) {\n43                         stepa = -stepa;\n44                         throw new PathIsExploredException(); \n45                     }\n46                     interpolationPoints.setEntry(nfm, nfmm, stepa);\n47                 } else if (nfm > n) {\n48                     stepa = interpolationPoints.getEntry(nfx, nfxm);\n49                     stepb = -initialTrustRegionRadius;\n50                     if (lowerDifference.getEntry(nfxm) == ZERO) {\n51                         stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n52                         throw new PathIsExploredException(); \n53                     }\n54                     if (upperDifference.getEntry(nfxm) == ZERO) {\n55                         stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n56                         throw new PathIsExploredException(); \n57                     }\n58                     interpolationPoints.setEntry(nfm, nfxm, stepb);\n59                 }\n60             } else {\n61                 final int tmp1 = (nfm - np) / n;\n62                 jpt = nfm - tmp1 * n - n;\n63                 ipt = jpt + tmp1;\n64                 if (ipt > n) {\n65                     final int tmp2 = jpt;\n66                     jpt = ipt - n;\n67                     ipt = tmp2;\n68                     throw new PathIsExploredException(); \n69                 }\n70                 final int iptMinus1 = ipt;\n71                 final int jptMinus1 = jpt;\n72                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n73                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n74             }\n75             for (int j = 0; j < n; j++) {\n76                 currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n77                                                           originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n78                                                  upperBound[j]));\n79                 if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n80                     currentBest.setEntry(j, lowerBound[j]);\n81                 }\n82                 if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n83                     currentBest.setEntry(j, upperBound[j]);\n84                 }\n85             }\n86             final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n87             final double f = isMinimize ? objectiveValue : -objectiveValue;\n88             final int numEval = getEvaluations(); \n89             fAtInterpolationPoints.setEntry(nfm, f);\n90             if (numEval == 1) {\n91                 fbeg = f;\n92                 trustRegionCenterInterpolationPointIndex = 0;\n93             } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n94                 trustRegionCenterInterpolationPointIndex = nfm;\n95             }\n96             if (numEval <= 2 * n + 1) {\n97                 if (numEval >= 2 &&\n98                     numEval <= n + 1) {\n99                     gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n100                     if (npt < numEval + n) {\n101                         final double oneOverStepA = ONE / stepa;\n102                         bMatrix.setEntry(0, nfmm, -oneOverStepA);\n103                         bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n104                         bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n105                         throw new PathIsExploredException(); \n106                     }\n107                 } else if (numEval >= n + 2) {\n108                     final int ih = nfx * (nfx + 1) / 2 - 1;\n109                     final double tmp = (f - fbeg) / stepb;\n110                     final double diff = stepb - stepa;\n111                     modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n112                     gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n113                     if (stepa * stepb < ZERO) {\n114                         if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n115                             fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n116                             fAtInterpolationPoints.setEntry(nfm - n, f);\n117                             if (trustRegionCenterInterpolationPointIndex == nfm) {\n118                                 trustRegionCenterInterpolationPointIndex = nfm - n;\n119                             }\n120                             interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n121                             interpolationPoints.setEntry(nfm, nfxm, stepa);\n122                         }\n123                     }\n124                     bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n125                     bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n126                     bMatrix.setEntry(nfm - n, nfxm,\n127                                   -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n128                     zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n129                     zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n130                     zMatrix.setEntry(nfm - n, nfxm,\n131                                   -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n132                 }\n133             } else {\n134                 zMatrix.setEntry(0, nfxm, recip);\n135                 zMatrix.setEntry(nfm, nfxm, recip);\n136                 zMatrix.setEntry(ipt, nfxm, -recip);\n137                 zMatrix.setEntry(jpt, nfxm, -recip);\n138                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n139                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n140                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n141                 throw new PathIsExploredException(); \n142             }\n143         } while (getEvaluations() < npt);\n144     } \n", "fixed_code": "    private void prelim(double[] lowerBound,\n                        double[] upperBound) {\n        printMethod(); \n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int ndim = bMatrix.getRowDimension();\n        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n        final double recip = 1d / rhosq;\n        final int np = n + 1;\n        for (int j = 0; j < n; j++) {\n            originShift.setEntry(j, currentBest.getEntry(j));\n            for (int k = 0; k < npt; k++) {\n                interpolationPoints.setEntry(k, j, ZERO);\n            }\n            for (int i = 0; i < ndim; i++) {\n                bMatrix.setEntry(i, j, ZERO);\n            }\n        }\n        for (int i = 0, max = n * np / 2; i < max; i++) {\n            modelSecondDerivativesValues.setEntry(i, ZERO);\n        }\n        for (int k = 0; k < npt; k++) {\n            modelSecondDerivativesParameters.setEntry(k, ZERO);\n            for (int j = 0, max = npt - np; j < max; j++) {\n                zMatrix.setEntry(k, j, ZERO);\n            }\n        }\n        int ipt = 0;\n        int jpt = 0;\n        double fbeg = Double.NaN;\n        do {\n            final int nfm = getEvaluations();\n            final int nfx = nfm - n;\n            final int nfmm = nfm - 1;\n            final int nfxm = nfx - 1;\n            double stepa = 0;\n            double stepb = 0;\n            if (nfm <= 2 * n) {\n                if (nfm >= 1 &&\n                    nfm <= n) {\n                    stepa = initialTrustRegionRadius;\n                    if (upperDifference.getEntry(nfmm) == ZERO) {\n                        stepa = -stepa;\n                        throw new PathIsExploredException(); \n                    }\n                    interpolationPoints.setEntry(nfm, nfmm, stepa);\n                } else if (nfm > n) {\n                    stepa = interpolationPoints.getEntry(nfx, nfxm);\n                    stepb = -initialTrustRegionRadius;\n                    if (lowerDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); \n                    }\n                    if (upperDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); \n                    }\n                    interpolationPoints.setEntry(nfm, nfxm, stepb);\n                }\n            } else {\n                final int tmp1 = (nfm - np) / n;\n                jpt = nfm - tmp1 * n - n;\n                ipt = jpt + tmp1;\n                if (ipt > n) {\n                    final int tmp2 = jpt;\n                    jpt = ipt - n;\n                    ipt = tmp2;\n                }\n                final int iptMinus1 = ipt - 1;\n                final int jptMinus1 = jpt - 1;\n                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n            }\n            for (int j = 0; j < n; j++) {\n                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n                                                 upperBound[j]));\n                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                }\n                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                    currentBest.setEntry(j, upperBound[j]);\n                }\n            }\n            final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n            final double f = isMinimize ? objectiveValue : -objectiveValue;\n            final int numEval = getEvaluations(); \n            fAtInterpolationPoints.setEntry(nfm, f);\n            if (numEval == 1) {\n                fbeg = f;\n                trustRegionCenterInterpolationPointIndex = 0;\n            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n                trustRegionCenterInterpolationPointIndex = nfm;\n            }\n            if (numEval <= 2 * n + 1) {\n                if (numEval >= 2 &&\n                    numEval <= n + 1) {\n                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                    if (npt < numEval + n) {\n                        final double oneOverStepA = ONE / stepa;\n                        bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                        throw new PathIsExploredException(); \n                    }\n                } else if (numEval >= n + 2) {\n                    final int ih = nfx * (nfx + 1) / 2 - 1;\n                    final double tmp = (f - fbeg) / stepb;\n                    final double diff = stepb - stepa;\n                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                    if (stepa * stepb < ZERO) {\n                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n                            fAtInterpolationPoints.setEntry(nfm - n, f);\n                            if (trustRegionCenterInterpolationPointIndex == nfm) {\n                                trustRegionCenterInterpolationPointIndex = nfm - n;\n                            }\n                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                            interpolationPoints.setEntry(nfm, nfxm, stepa);\n                        }\n                    }\n                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                    bMatrix.setEntry(nfm - n, nfxm,\n                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n                    zMatrix.setEntry(nfm - n, nfxm,\n                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n                }\n            } else {\n                zMatrix.setEntry(0, nfxm, recip);\n                zMatrix.setEntry(nfm, nfxm, recip);\n                zMatrix.setEntry(ipt, nfxm, -recip);\n                zMatrix.setEntry(jpt, nfxm, -recip);\n                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n            }\n        } while (getEvaluations() < npt);\n    } \n"}
{"bug_id": "Lang-37", "buggy_code": "1     public static <T> T[] addAll(T[] array1, T... array2) {\n2         if (array1 == null) {\n3             return clone(array2);\n4         } else if (array2 == null) {\n5             return clone(array1);\n6         }\n7         final Class<?> type1 = array1.getClass().getComponentType();\n8         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n9         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n10             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n11         return joinedArray;\n12     }\n", "fixed_code": "    public static <T> T[] addAll(T[] array1, T... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        final Class<?> type1 = array1.getClass().getComponentType();\n        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)){\n                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName());\n            }\n            throw ase; \n        }\n        return joinedArray;\n    }\n"}
{"bug_id": "Closure-132", "buggy_code": "1   private Node tryMinimizeIf(Node n) {\n2     Node parent = n.getParent();\n3     Node cond = n.getFirstChild();\n4     if (NodeUtil.isLiteralValue(cond, true)) {\n5       return n;\n6     }\n7     Node thenBranch = cond.getNext();\n8     Node elseBranch = thenBranch.getNext();\n9     if (elseBranch == null) {\n10       if (isFoldableExpressBlock(thenBranch)) {\n11         Node expr = getBlockExpression(thenBranch);\n12         if (!late && isPropertyAssignmentInExpression(expr)) {\n13           return n;\n14         }\n15         if (cond.isNot()) {\n16           if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n17               isLowerPrecedenceInExpression(expr.getFirstChild(),\n18                   OR_PRECEDENCE)) {\n19             return n;\n20           }\n21           Node or = IR.or(\n22               cond.removeFirstChild(),\n23               expr.removeFirstChild()).srcref(n);\n24           Node newExpr = NodeUtil.newExpr(or);\n25           parent.replaceChild(n, newExpr);\n26           reportCodeChange();\n27           return newExpr;\n28         }\n29         if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n30             isLowerPrecedenceInExpression(expr.getFirstChild(),\n31                 AND_PRECEDENCE)) {\n32           return n;\n33         }\n34         n.removeChild(cond);\n35         Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n36         Node newExpr = NodeUtil.newExpr(and);\n37         parent.replaceChild(n, newExpr);\n38         reportCodeChange();\n39         return newExpr;\n40       } else {\n41         if (NodeUtil.isStatementBlock(thenBranch) &&\n42             thenBranch.hasOneChild()) {\n43           Node innerIf = thenBranch.getFirstChild();\n44           if (innerIf.isIf()) {\n45             Node innerCond = innerIf.getFirstChild();\n46             Node innerThenBranch = innerCond.getNext();\n47             Node innerElseBranch = innerThenBranch.getNext();\n48             if (innerElseBranch == null &&\n49                  !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n50                    isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n51               n.detachChildren();\n52               n.addChildToBack(\n53                   IR.and(\n54                       cond,\n55                       innerCond.detachFromParent())\n56                       .srcref(cond));\n57               n.addChildrenToBack(innerThenBranch.detachFromParent());\n58               reportCodeChange();\n59               return n;\n60             }\n61           }\n62         }\n63       }\n64       return n;\n65     }\n66     tryRemoveRepeatedStatements(n);\n67     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n68       n.replaceChild(cond, cond.removeFirstChild());\n69       n.removeChild(thenBranch);\n70       n.addChildToBack(thenBranch);\n71       reportCodeChange();\n72       return n;\n73     }\n74     if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n75       Node thenExpr = getBlockReturnExpression(thenBranch);\n76       Node elseExpr = getBlockReturnExpression(elseBranch);\n77       n.removeChild(cond);\n78       thenExpr.detachFromParent();\n79       elseExpr.detachFromParent();\n80       Node returnNode = IR.returnNode(\n81                             IR.hook(cond, thenExpr, elseExpr)\n82                                 .srcref(n));\n83       parent.replaceChild(n, returnNode);\n84       reportCodeChange();\n85       return returnNode;\n86     }\n87     boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n88     boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n89     if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n90       Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n91       Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n92       if (thenOp.getType() == elseOp.getType()) {\n93         if (NodeUtil.isAssignmentOp(thenOp)) {\n94           Node lhs = thenOp.getFirstChild();\n95           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n96               !mayEffectMutableState(lhs)) {\n97             n.removeChild(cond);\n98             Node assignName = thenOp.removeFirstChild();\n99             Node thenExpr = thenOp.removeFirstChild();\n100             Node elseExpr = elseOp.getLastChild();\n101             elseOp.removeChild(elseExpr);\n102             Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n103             Node assign = new Node(thenOp.getType(), assignName, hookNode)\n104                               .srcref(thenOp);\n105             Node expr = NodeUtil.newExpr(assign);\n106             parent.replaceChild(n, expr);\n107             reportCodeChange();\n108             return expr;\n109           }\n110         }\n111       }\n112       n.removeChild(cond);\n113       thenOp.detachFromParent();\n114       elseOp.detachFromParent();\n115       Node expr = IR.exprResult(\n116           IR.hook(cond, thenOp, elseOp).srcref(n));\n117       parent.replaceChild(n, expr);\n118       reportCodeChange();\n119       return expr;\n120     }\n121     boolean thenBranchIsVar = isVarBlock(thenBranch);\n122     boolean elseBranchIsVar = isVarBlock(elseBranch);\n123     if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n124         getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n125       Node var = getBlockVar(thenBranch);\n126       Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n127       Node name1 = var.getFirstChild();\n128       Node maybeName2 = elseAssign.getFirstChild();\n129       if (name1.hasChildren()\n130           && maybeName2.isName()\n131           && name1.getString().equals(maybeName2.getString())) {\n132         Node thenExpr = name1.removeChildren();\n133         Node elseExpr = elseAssign.getLastChild().detachFromParent();\n134         cond.detachFromParent();\n135         Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n136                             .srcref(n);\n137         var.detachFromParent();\n138         name1.addChildrenToBack(hookNode);\n139         parent.replaceChild(n, var);\n140         reportCodeChange();\n141         return var;\n142       }\n143     } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n144         getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n145       Node var = getBlockVar(elseBranch);\n146       Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n147       Node maybeName1 = thenAssign.getFirstChild();\n148       Node name2 = var.getFirstChild();\n149       if (name2.hasChildren()\n150           && maybeName1.isName()\n151           && maybeName1.getString().equals(name2.getString())) {\n152         Node thenExpr = thenAssign.getLastChild().detachFromParent();\n153         Node elseExpr = name2.removeChildren();\n154         cond.detachFromParent();\n155         Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n156                             .srcref(n);\n157         var.detachFromParent();\n158         name2.addChildrenToBack(hookNode);\n159         parent.replaceChild(n, var);\n160         reportCodeChange();\n161         return var;\n162       }\n163     }\n164     return n;\n165   }\n", "fixed_code": "  private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          return n;\n        }\n        if (cond.isNot()) {\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            return n;\n          }\n          Node or = IR.or(\n              cond.removeFirstChild(),\n              expr.removeFirstChild()).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n          return newExpr;\n        }\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          return n;\n        }\n        n.removeChild(cond);\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n      } else {\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n              n.detachChildren();\n              n.addChildToBack(\n                  IR.and(\n                      cond,\n                      innerCond.detachFromParent())\n                      .srcref(cond));\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\n              reportCodeChange();\n              return n;\n            }\n          }\n        }\n      }\n      return n;\n    }\n    tryRemoveRepeatedStatements(n);\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n    }\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n      Node returnNode = IR.returnNode(\n                            IR.hook(cond, thenExpr, elseExpr)\n                                .srcref(n));\n      parent.replaceChild(n, returnNode);\n      reportCodeChange();\n      return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              !mayEffectMutableState(lhs) &&\n              (!mayHaveSideEffects(cond) ||\n                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n            n.removeChild(cond);\n            Node assignName = thenOp.removeFirstChild();\n            Node thenExpr = thenOp.removeFirstChild();\n            Node elseExpr = elseOp.getLastChild();\n            elseOp.removeChild(elseExpr);\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                              .srcref(thenOp);\n            Node expr = NodeUtil.newExpr(assign);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n            return expr;\n          }\n        }\n      }\n      n.removeChild(cond);\n      thenOp.detachFromParent();\n      elseOp.detachFromParent();\n      Node expr = IR.exprResult(\n          IR.hook(cond, thenOp, elseOp).srcref(n));\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n      Node name1 = var.getFirstChild();\n      Node maybeName2 = elseAssign.getFirstChild();\n      if (name1.hasChildren()\n          && maybeName2.isName()\n          && name1.getString().equals(maybeName2.getString())) {\n        Node thenExpr = name1.removeChildren();\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        var.detachFromParent();\n        name1.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n        return var;\n      }\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n      Node maybeName1 = thenAssign.getFirstChild();\n      Node name2 = var.getFirstChild();\n      if (name2.hasChildren()\n          && maybeName1.isName()\n          && maybeName1.getString().equals(name2.getString())) {\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n        Node elseExpr = name2.removeChildren();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        var.detachFromParent();\n        name2.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n        return var;\n      }\n    }\n    return n;\n  }\n"}
{"bug_id": "Chart-12", "buggy_code": "1     public MultiplePiePlot(CategoryDataset dataset) {\n2         super();\n3         this.dataset = dataset;\n4         PiePlot piePlot = new PiePlot(null);\n5         this.pieChart = new JFreeChart(piePlot);\n6         this.pieChart.removeLegend();\n7         this.dataExtractOrder = TableOrder.BY_COLUMN;\n8         this.pieChart.setBackgroundPaint(null);\n9         TextTitle seriesTitle = new TextTitle(\"Series Title\",\n10                 new Font(\"SansSerif\", Font.BOLD, 12));\n11         seriesTitle.setPosition(RectangleEdge.BOTTOM);\n12         this.pieChart.setTitle(seriesTitle);\n13         this.aggregatedItemsKey = \"Other\";\n14         this.aggregatedItemsPaint = Color.lightGray;\n15         this.sectionPaints = new HashMap();\n16     }\n", "fixed_code": "    public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n        setDataset(dataset);\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }\n"}
{"bug_id": "Closure-125", "buggy_code": "1   private void visitNew(NodeTraversal t, Node n) {\n2     Node constructor = n.getFirstChild();\n3     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n4     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n5       FunctionType fnType = type.toMaybeFunctionType();\n6       if (fnType != null) {\n7         visitParameterList(t, n, fnType);\n8         ensureTyped(t, n, fnType.getInstanceType());\n9       } else {\n10         ensureTyped(t, n);\n11       }\n12     } else {\n13       report(t, n, NOT_A_CONSTRUCTOR);\n14       ensureTyped(t, n);\n15     }\n16   }\n", "fixed_code": "  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null && fnType.hasInstanceType()) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n"}
{"bug_id": "Lang-16", "buggy_code": "1     public static Number createNumber(String str) throws NumberFormatException {\n2         if (str == null) {\n3             return null;\n4         }\n5         if (StringUtils.isBlank(str)) {\n6             throw new NumberFormatException(\"A blank string is not a valid number\");\n7         }  \n8         if (str.startsWith(\"--\")) {\n9             return null;\n10         }\n11         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n12             return createInteger(str);\n13         }   \n14         char lastChar = str.charAt(str.length() - 1);\n15         String mant;\n16         String dec;\n17         String exp;\n18         int decPos = str.indexOf('.');\n19         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n20         if (decPos > -1) {\n21             if (expPos > -1) {\n22                 if (expPos < decPos || expPos > str.length()) {\n23                     throw new NumberFormatException(str + \" is not a valid number.\");\n24                 }\n25                 dec = str.substring(decPos + 1, expPos);\n26             } else {\n27                 dec = str.substring(decPos + 1);\n28             }\n29             mant = str.substring(0, decPos);\n30         } else {\n31             if (expPos > -1) {\n32                 if (expPos > str.length()) {\n33                     throw new NumberFormatException(str + \" is not a valid number.\");\n34                 }\n35                 mant = str.substring(0, expPos);\n36             } else {\n37                 mant = str;\n38             }\n39             dec = null;\n40         }\n41         if (!Character.isDigit(lastChar) && lastChar != '.') {\n42             if (expPos > -1 && expPos < str.length() - 1) {\n43                 exp = str.substring(expPos + 1, str.length() - 1);\n44             } else {\n45                 exp = null;\n46             }\n47             String numeric = str.substring(0, str.length() - 1);\n48             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n49             switch (lastChar) {\n50                 case 'l' :\n51                 case 'L' :\n52                     if (dec == null\n53                         && exp == null\n54                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n55                         try {\n56                             return createLong(numeric);\n57                         } catch (NumberFormatException nfe) { \n58                         }\n59                         return createBigInteger(numeric);\n60                     }\n61                     throw new NumberFormatException(str + \" is not a valid number.\");\n62                 case 'f' :\n63                 case 'F' :\n64                     try {\n65                         Float f = NumberUtils.createFloat(numeric);\n66                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n67                             return f;\n68                         }\n69                     } catch (NumberFormatException nfe) { \n70                     }\n71                 case 'd' :\n72                 case 'D' :\n73                     try {\n74                         Double d = NumberUtils.createDouble(numeric);\n75                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n76                             return d;\n77                         }\n78                     } catch (NumberFormatException nfe) { \n79                     }\n80                     try {\n81                         return createBigDecimal(numeric);\n82                     } catch (NumberFormatException e) { \n83                     }\n84                 default :\n85                     throw new NumberFormatException(str + \" is not a valid number.\");\n86             }\n87         } else {\n88             if (expPos > -1 && expPos < str.length() - 1) {\n89                 exp = str.substring(expPos + 1, str.length());\n90             } else {\n91                 exp = null;\n92             }\n93             if (dec == null && exp == null) {\n94                 try {\n95                     return createInteger(str);\n96                 } catch (NumberFormatException nfe) { \n97                 }\n98                 try {\n99                     return createLong(str);\n100                 } catch (NumberFormatException nfe) { \n101                 }\n102                 return createBigInteger(str);\n103             } else {\n104                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n105                 try {\n106                     Float f = createFloat(str);\n107                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n108                         return f;\n109                     }\n110                 } catch (NumberFormatException nfe) { \n111                 }\n112                 try {\n113                     Double d = createDouble(str);\n114                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n115                         return d;\n116                     }\n117                 } catch (NumberFormatException nfe) { \n118                 }\n119                 return createBigDecimal(str);\n120             }\n121         }\n122     }\n", "fixed_code": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n        if (decPos > -1) {\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { \n                        }\n                        return createBigInteger(numeric);\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (NumberFormatException nfe) { \n                    }\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { \n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { \n                    }\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        } else {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { \n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { \n                }\n                return createBigInteger(str);\n            } else {\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { \n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { \n                }\n                return createBigDecimal(str);\n            }\n        }\n    }\n"}
{"bug_id": "Codec-4", "buggy_code": "1     public Base64() {\n2         this(false);\n3     }\n", "fixed_code": "    public Base64() {\n        this(0);\n    }\n"}
{"bug_id": "JacksonDatabind-28", "buggy_code": "1         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n2         {\n3             if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n4                 p.nextToken();\n5                 return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n6             }\n7             if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n8                 return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n9             }\n10             throw ctxt.mappingException(ObjectNode.class);\n11          }\n", "fixed_code": "        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            if (p.hasToken(JsonToken.END_OBJECT)) {\n                return ctxt.getNodeFactory().objectNode();\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n"}
{"bug_id": "JacksonDatabind-16", "buggy_code": "1     protected final boolean _add(Annotation ann) {\n2         if (_annotations == null) {\n3             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n4         }\n5         Annotation previous = _annotations.put(ann.annotationType(), ann);\n6         return (previous != null) && previous.equals(ann);\n7     }\n", "fixed_code": "    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n        return (previous == null) || !previous.equals(ann);\n    }\n"}
{"bug_id": "JacksonDatabind-88", "buggy_code": "1     protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n2     {\n3         TypeFactory tf = ctxt.getTypeFactory();\n4         if (id.indexOf('<') > 0) {\n5             JavaType t = tf.constructFromCanonical(id);\n6             return t;\n7         }\n8         Class<?> cls;\n9         try {\n10             cls =  tf.findClass(id);\n11         } catch (ClassNotFoundException e) {\n12             if (ctxt instanceof DeserializationContext) {\n13                 DeserializationContext dctxt = (DeserializationContext) ctxt;\n14                 return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n15             }\n16             return null;\n17         } catch (Exception e) {\n18             throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n19         }\n20         return tf.constructSpecializedType(_baseType, cls);\n21     }\n", "fixed_code": "    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n    {\n        TypeFactory tf = ctxt.getTypeFactory();\n        if (id.indexOf('<') > 0) {\n            JavaType t = tf.constructFromCanonical(id);\n            if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType));\n            }\n            return t;\n        }\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n            }\n            return null;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n        }\n        return tf.constructSpecializedType(_baseType, cls);\n    }\n"}
{"bug_id": "Closure-35", "buggy_code": "1   private void inferPropertyTypesToMatchConstraint(\n2       JSType type, JSType constraint) {\n3     if (type == null || constraint == null) {\n4       return;\n5     }\n6     ObjectType constraintObj =\n7         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n8     if (constraintObj != null && constraintObj.isRecordType()) {\n9       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n10       if (objType != null) {\n11         for (String prop : constraintObj.getOwnPropertyNames()) {\n12           JSType propType = constraintObj.getPropertyType(prop);\n13           if (!objType.isPropertyTypeDeclared(prop)) {\n14             JSType typeToInfer = propType;\n15             if (!objType.hasProperty(prop)) {\n16               typeToInfer =\n17                   getNativeType(VOID_TYPE).getLeastSupertype(propType);\n18             }\n19             objType.defineInferredProperty(prop, typeToInfer, null);\n20           }\n21         }\n22       }\n23     }\n24   }\n", "fixed_code": "  private void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (constraintObj != null) {\n      type.matchConstraint(constraintObj);\n    }\n  }\n"}
{"bug_id": "Closure-19", "buggy_code": "1   protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n2     switch (node.getType()) {\n3       case Token.NAME:\n4         scope.inferSlotType(node.getString(), type);\n5         break;\n6       case Token.GETPROP:\n7         String qualifiedName = node.getQualifiedName();\n8         Preconditions.checkNotNull(qualifiedName);\n9         JSType origType = node.getJSType();\n10         origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n11         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n12         break;\n13       default:\n14         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n15             node.toStringTree());\n16     }\n17   }\n", "fixed_code": "  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n      case Token.THIS:\n        break;\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }\n"}
{"bug_id": "Jsoup-76", "buggy_code": "1         boolean process(Token t, HtmlTreeBuilder tb) {\n2             switch (t.type) {\n3                 case Character: {\n4                     Token.Character c = t.asCharacter();\n5                     if (c.getData().equals(nullString)) {\n6                         tb.error(this);\n7                         return false;\n8                     } else if (tb.framesetOk() && isWhitespace(c)) { \n9                         tb.reconstructFormattingElements();\n10                         tb.insert(c);\n11                     } else {\n12                         tb.reconstructFormattingElements();\n13                         tb.insert(c);\n14                         tb.framesetOk(false);\n15                     }\n16                     break;\n17                 }\n18                 case Comment: {\n19                     tb.insert(t.asComment());\n20                     break;\n21                 }\n22                 case Doctype: {\n23                     tb.error(this);\n24                     return false;\n25                 }\n26                 case StartTag:\n27                     Token.StartTag startTag = t.asStartTag();\n28                     String name = startTag.normalName();\n29                     if (name.equals(\"a\")) {\n30                         if (tb.getActiveFormattingElement(\"a\") != null) {\n31                             tb.error(this);\n32                             tb.processEndTag(\"a\");\n33                             Element remainingA = tb.getFromStack(\"a\");\n34                             if (remainingA != null) {\n35                                 tb.removeFromActiveFormattingElements(remainingA);\n36                                 tb.removeFromStack(remainingA);\n37                             }\n38                         }\n39                         tb.reconstructFormattingElements();\n40                         Element a = tb.insert(startTag);\n41                         tb.pushActiveFormattingElements(a);\n42                     } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n43                         tb.reconstructFormattingElements();\n44                         tb.insertEmpty(startTag);\n45                         tb.framesetOk(false);\n46                     } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n47                         if (tb.inButtonScope(\"p\")) {\n48                             tb.processEndTag(\"p\");\n49                         }\n50                         tb.insert(startTag);\n51                     } else if (name.equals(\"span\")) {\n52                         tb.reconstructFormattingElements();\n53                         tb.insert(startTag);\n54                     } else if (name.equals(\"li\")) {\n55                         tb.framesetOk(false);\n56                         ArrayList<Element> stack = tb.getStack();\n57                         for (int i = stack.size() - 1; i > 0; i--) {\n58                             Element el = stack.get(i);\n59                             if (el.nodeName().equals(\"li\")) {\n60                                 tb.processEndTag(\"li\");\n61                                 break;\n62                             }\n63                             if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n64                                 break;\n65                         }\n66                         if (tb.inButtonScope(\"p\")) {\n67                             tb.processEndTag(\"p\");\n68                         }\n69                         tb.insert(startTag);\n70                     } else if (name.equals(\"html\")) {\n71                         tb.error(this);\n72                         Element html = tb.getStack().get(0);\n73                         for (Attribute attribute : startTag.getAttributes()) {\n74                             if (!html.hasAttr(attribute.getKey()))\n75                                 html.attributes().put(attribute);\n76                         }\n77                     } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n78                         return tb.process(t, InHead);\n79                     } else if (name.equals(\"body\")) {\n80                         tb.error(this);\n81                         ArrayList<Element> stack = tb.getStack();\n82                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n83                             return false; \n84                         } else {\n85                             tb.framesetOk(false);\n86                             Element body = stack.get(1);\n87                             for (Attribute attribute : startTag.getAttributes()) {\n88                                 if (!body.hasAttr(attribute.getKey()))\n89                                     body.attributes().put(attribute);\n90                             }\n91                         }\n92                     } else if (name.equals(\"frameset\")) {\n93                         tb.error(this);\n94                         ArrayList<Element> stack = tb.getStack();\n95                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n96                             return false; \n97                         } else if (!tb.framesetOk()) {\n98                             return false; \n99                         } else {\n100                             Element second = stack.get(1);\n101                             if (second.parent() != null)\n102                                 second.remove();\n103                             while (stack.size() > 1)\n104                                 stack.remove(stack.size()-1);\n105                             tb.insert(startTag);\n106                             tb.transition(InFrameset);\n107                         }\n108                     } else if (StringUtil.inSorted(name, Constants.Headings)) {\n109                         if (tb.inButtonScope(\"p\")) {\n110                             tb.processEndTag(\"p\");\n111                         }\n112                         if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n113                             tb.error(this);\n114                             tb.pop();\n115                         }\n116                         tb.insert(startTag);\n117                     } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n118                         if (tb.inButtonScope(\"p\")) {\n119                             tb.processEndTag(\"p\");\n120                         }\n121                         tb.insert(startTag);\n122                         tb.framesetOk(false);\n123                     } else if (name.equals(\"form\")) {\n124                         if (tb.getFormElement() != null) {\n125                             tb.error(this);\n126                             return false;\n127                         }\n128                         if (tb.inButtonScope(\"p\")) {\n129                             tb.processEndTag(\"p\");\n130                         }\n131                         tb.insertForm(startTag, true);\n132                     } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n133                         tb.framesetOk(false);\n134                         ArrayList<Element> stack = tb.getStack();\n135                         for (int i = stack.size() - 1; i > 0; i--) {\n136                             Element el = stack.get(i);\n137                             if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n138                                 tb.processEndTag(el.nodeName());\n139                                 break;\n140                             }\n141                             if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n142                                 break;\n143                         }\n144                         if (tb.inButtonScope(\"p\")) {\n145                             tb.processEndTag(\"p\");\n146                         }\n147                         tb.insert(startTag);\n148                     } else if (name.equals(\"plaintext\")) {\n149                         if (tb.inButtonScope(\"p\")) {\n150                             tb.processEndTag(\"p\");\n151                         }\n152                         tb.insert(startTag);\n153                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n154                     } else if (name.equals(\"button\")) {\n155                         if (tb.inButtonScope(\"button\")) {\n156                             tb.error(this);\n157                             tb.processEndTag(\"button\");\n158                             tb.process(startTag);\n159                         } else {\n160                             tb.reconstructFormattingElements();\n161                             tb.insert(startTag);\n162                             tb.framesetOk(false);\n163                         }\n164                     } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n165                         tb.reconstructFormattingElements();\n166                         Element el = tb.insert(startTag);\n167                         tb.pushActiveFormattingElements(el);\n168                     } else if (name.equals(\"nobr\")) {\n169                         tb.reconstructFormattingElements();\n170                         if (tb.inScope(\"nobr\")) {\n171                             tb.error(this);\n172                             tb.processEndTag(\"nobr\");\n173                             tb.reconstructFormattingElements();\n174                         }\n175                         Element el = tb.insert(startTag);\n176                         tb.pushActiveFormattingElements(el);\n177                     } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n178                         tb.reconstructFormattingElements();\n179                         tb.insert(startTag);\n180                         tb.insertMarkerToFormattingElements();\n181                         tb.framesetOk(false);\n182                     } else if (name.equals(\"table\")) {\n183                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n184                             tb.processEndTag(\"p\");\n185                         }\n186                         tb.insert(startTag);\n187                         tb.framesetOk(false);\n188                         tb.transition(InTable);\n189                     } else if (name.equals(\"input\")) {\n190                         tb.reconstructFormattingElements();\n191                         Element el = tb.insertEmpty(startTag);\n192                         if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n193                             tb.framesetOk(false);\n194                     } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n195                         tb.insertEmpty(startTag);\n196                     } else if (name.equals(\"hr\")) {\n197                         if (tb.inButtonScope(\"p\")) {\n198                             tb.processEndTag(\"p\");\n199                         }\n200                         tb.insertEmpty(startTag);\n201                         tb.framesetOk(false);\n202                     } else if (name.equals(\"image\")) {\n203                         if (tb.getFromStack(\"svg\") == null)\n204                             return tb.process(startTag.name(\"img\")); \n205                         else\n206                             tb.insert(startTag);\n207                     } else if (name.equals(\"isindex\")) {\n208                         tb.error(this);\n209                         if (tb.getFormElement() != null)\n210                             return false;\n211                         tb.processStartTag(\"form\");\n212                         if (startTag.attributes.hasKey(\"action\")) {\n213                             Element form = tb.getFormElement();\n214                             form.attr(\"action\", startTag.attributes.get(\"action\"));\n215                         }\n216                         tb.processStartTag(\"hr\");\n217                         tb.processStartTag(\"label\");\n218                         String prompt = startTag.attributes.hasKey(\"prompt\") ?\n219                                 startTag.attributes.get(\"prompt\") :\n220                                 \"This is a searchable index. Enter search keywords: \";\n221                         tb.process(new Token.Character().data(prompt));\n222                         Attributes inputAttribs = new Attributes();\n223                         for (Attribute attr : startTag.attributes) {\n224                             if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n225                                 inputAttribs.put(attr);\n226                         }\n227                         inputAttribs.put(\"name\", \"isindex\");\n228                         tb.processStartTag(\"input\", inputAttribs);\n229                         tb.processEndTag(\"label\");\n230                         tb.processStartTag(\"hr\");\n231                         tb.processEndTag(\"form\");\n232                     } else if (name.equals(\"textarea\")) {\n233                         tb.insert(startTag);\n234                         tb.tokeniser.transition(TokeniserState.Rcdata);\n235                         tb.markInsertionMode();\n236                         tb.framesetOk(false);\n237                         tb.transition(Text);\n238                     } else if (name.equals(\"xmp\")) {\n239                         if (tb.inButtonScope(\"p\")) {\n240                             tb.processEndTag(\"p\");\n241                         }\n242                         tb.reconstructFormattingElements();\n243                         tb.framesetOk(false);\n244                         handleRawtext(startTag, tb);\n245                     } else if (name.equals(\"iframe\")) {\n246                         tb.framesetOk(false);\n247                         handleRawtext(startTag, tb);\n248                     } else if (name.equals(\"noembed\")) {\n249                         handleRawtext(startTag, tb);\n250                     } else if (name.equals(\"select\")) {\n251                         tb.reconstructFormattingElements();\n252                         tb.insert(startTag);\n253                         tb.framesetOk(false);\n254                         HtmlTreeBuilderState state = tb.state();\n255                         if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n256                             tb.transition(InSelectInTable);\n257                         else\n258                             tb.transition(InSelect);\n259                     } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n260                         if (tb.currentElement().nodeName().equals(\"option\"))\n261                             tb.processEndTag(\"option\");\n262                         tb.reconstructFormattingElements();\n263                         tb.insert(startTag);\n264                     } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n265                         if (tb.inScope(\"ruby\")) {\n266                             tb.generateImpliedEndTags();\n267                             if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n268                                 tb.error(this);\n269                                 tb.popStackToBefore(\"ruby\"); \n270                             }\n271                             tb.insert(startTag);\n272                         }\n273                     } else if (name.equals(\"math\")) {\n274                         tb.reconstructFormattingElements();\n275                         tb.insert(startTag);\n276                     } else if (name.equals(\"svg\")) {\n277                         tb.reconstructFormattingElements();\n278                         tb.insert(startTag);\n279                     } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n280                         tb.error(this);\n281                         return false;\n282                     } else {\n283                         tb.reconstructFormattingElements();\n284                         tb.insert(startTag);\n285                     }\n286                     break;\n287                 case EndTag:\n288                     Token.EndTag endTag = t.asEndTag();\n289                     name = endTag.normalName();\n290                     if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n291                         for (int i = 0; i < 8; i++) {\n292                             Element formatEl = tb.getActiveFormattingElement(name);\n293                             if (formatEl == null)\n294                                 return anyOtherEndTag(t, tb);\n295                             else if (!tb.onStack(formatEl)) {\n296                                 tb.error(this);\n297                                 tb.removeFromActiveFormattingElements(formatEl);\n298                                 return true;\n299                             } else if (!tb.inScope(formatEl.nodeName())) {\n300                                 tb.error(this);\n301                                 return false;\n302                             } else if (tb.currentElement() != formatEl)\n303                                 tb.error(this);\n304                             Element furthestBlock = null;\n305                             Element commonAncestor = null;\n306                             boolean seenFormattingElement = false;\n307                             ArrayList<Element> stack = tb.getStack();\n308                             final int stackSize = stack.size();\n309                             for (int si = 0; si < stackSize && si < 64; si++) {\n310                                 Element el = stack.get(si);\n311                                 if (el == formatEl) {\n312                                     commonAncestor = stack.get(si - 1);\n313                                     seenFormattingElement = true;\n314                                 } else if (seenFormattingElement && tb.isSpecial(el)) {\n315                                     furthestBlock = el;\n316                                     break;\n317                                 }\n318                             }\n319                             if (furthestBlock == null) {\n320                                 tb.popStackToClose(formatEl.nodeName());\n321                                 tb.removeFromActiveFormattingElements(formatEl);\n322                                 return true;\n323                             }\n324                             Element node = furthestBlock;\n325                             Element lastNode = furthestBlock;\n326                             for (int j = 0; j < 3; j++) {\n327                                 if (tb.onStack(node))\n328                                     node = tb.aboveOnStack(node);\n329                                 if (!tb.isInActiveFormattingElements(node)) { \n330                                     tb.removeFromStack(node);\n331                                     continue;\n332                                 } else if (node == formatEl)\n333                                     break;\n334                                 Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n335                                 tb.replaceActiveFormattingElement(node, replacement);\n336                                 tb.replaceOnStack(node, replacement);\n337                                 node = replacement;\n338                                 if (lastNode == furthestBlock) {\n339                                 }\n340                                 if (lastNode.parent() != null)\n341                                     lastNode.remove();\n342                                 node.appendChild(lastNode);\n343                                 lastNode = node;\n344                             }\n345                             if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n346                                 if (lastNode.parent() != null)\n347                                     lastNode.remove();\n348                                 tb.insertInFosterParent(lastNode);\n349                             } else {\n350                                 if (lastNode.parent() != null)\n351                                     lastNode.remove();\n352                                 commonAncestor.appendChild(lastNode);\n353                             }\n354                             Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n355                             adopter.attributes().addAll(formatEl.attributes());\n356                             Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n357                             for (Node childNode : childNodes) {\n358                                 adopter.appendChild(childNode); \n359                             }\n360                             furthestBlock.appendChild(adopter);\n361                             tb.removeFromActiveFormattingElements(formatEl);\n362                             tb.removeFromStack(formatEl);\n363                             tb.insertOnStackAfter(furthestBlock, adopter);\n364                         }\n365                     } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n366                         if (!tb.inScope(name)) {\n367                             tb.error(this);\n368                             return false;\n369                         } else {\n370                             tb.generateImpliedEndTags();\n371                             if (!tb.currentElement().nodeName().equals(name))\n372                                 tb.error(this);\n373                             tb.popStackToClose(name);\n374                         }\n375                     } else if (name.equals(\"span\")) {\n376                         return anyOtherEndTag(t, tb);\n377                     } else if (name.equals(\"li\")) {\n378                         if (!tb.inListItemScope(name)) {\n379                             tb.error(this);\n380                             return false;\n381                         } else {\n382                             tb.generateImpliedEndTags(name);\n383                             if (!tb.currentElement().nodeName().equals(name))\n384                                 tb.error(this);\n385                             tb.popStackToClose(name);\n386                         }\n387                     } else if (name.equals(\"body\")) {\n388                         if (!tb.inScope(\"body\")) {\n389                             tb.error(this);\n390                             return false;\n391                         } else {\n392                             tb.transition(AfterBody);\n393                         }\n394                     } else if (name.equals(\"html\")) {\n395                         boolean notIgnored = tb.processEndTag(\"body\");\n396                         if (notIgnored)\n397                             return tb.process(endTag);\n398                     } else if (name.equals(\"form\")) {\n399                         Element currentForm = tb.getFormElement();\n400                         tb.setFormElement(null);\n401                         if (currentForm == null || !tb.inScope(name)) {\n402                             tb.error(this);\n403                             return false;\n404                         } else {\n405                             tb.generateImpliedEndTags();\n406                             if (!tb.currentElement().nodeName().equals(name))\n407                                 tb.error(this);\n408                             tb.removeFromStack(currentForm);\n409                         }\n410                     } else if (name.equals(\"p\")) {\n411                         if (!tb.inButtonScope(name)) {\n412                             tb.error(this);\n413                             tb.processStartTag(name); \n414                             return tb.process(endTag);\n415                         } else {\n416                             tb.generateImpliedEndTags(name);\n417                             if (!tb.currentElement().nodeName().equals(name))\n418                                 tb.error(this);\n419                             tb.popStackToClose(name);\n420                         }\n421                     } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n422                         if (!tb.inScope(name)) {\n423                             tb.error(this);\n424                             return false;\n425                         } else {\n426                             tb.generateImpliedEndTags(name);\n427                             if (!tb.currentElement().nodeName().equals(name))\n428                                 tb.error(this);\n429                             tb.popStackToClose(name);\n430                         }\n431                     } else if (StringUtil.inSorted(name, Constants.Headings)) {\n432                         if (!tb.inScope(Constants.Headings)) {\n433                             tb.error(this);\n434                             return false;\n435                         } else {\n436                             tb.generateImpliedEndTags(name);\n437                             if (!tb.currentElement().nodeName().equals(name))\n438                                 tb.error(this);\n439                             tb.popStackToClose(Constants.Headings);\n440                         }\n441                     } else if (name.equals(\"sarcasm\")) {\n442                         return anyOtherEndTag(t, tb);\n443                     } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n444                         if (!tb.inScope(\"name\")) {\n445                             if (!tb.inScope(name)) {\n446                                 tb.error(this);\n447                                 return false;\n448                             }\n449                             tb.generateImpliedEndTags();\n450                             if (!tb.currentElement().nodeName().equals(name))\n451                                 tb.error(this);\n452                             tb.popStackToClose(name);\n453                             tb.clearFormattingElementsToLastMarker();\n454                         }\n455                     } else if (name.equals(\"br\")) {\n456                         tb.error(this);\n457                         tb.processStartTag(\"br\");\n458                         return false;\n459                     } else {\n460                         return anyOtherEndTag(t, tb);\n461                     }\n462                     break;\n463                 case EOF:\n464                     break;\n465             }\n466             return true;\n467         }\n", "fixed_code": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.framesetOk() && isWhitespace(c)) { \n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n                    if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.processEndTag(\"a\");\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"span\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.processEndTag(\"li\");\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"html\")) {\n                        tb.error(this);\n                        Element html = tb.getStack().get(0);\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            return false; \n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            return false; \n                        } else if (!tb.framesetOk()) {\n                            return false; \n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.reader.matchConsume(\"\\n\"); \n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.processEndTag(el.nodeName());\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            tb.error(this);\n                            tb.processEndTag(\"button\");\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.processEndTag(\"nobr\");\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        if (tb.getFromStack(\"svg\") == null)\n                            return tb.process(startTag.name(\"img\")); \n                        else\n                            tb.insert(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n                        tb.processStartTag(\"form\");\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.processStartTag(\"hr\");\n                        tb.processStartTag(\"label\");\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n                        tb.process(new Token.Character().data(prompt));\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.processStartTag(\"input\", inputAttribs);\n                        tb.processEndTag(\"label\");\n                        tb.processStartTag(\"hr\");\n                        tb.processEndTag(\"form\");\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); \n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            ArrayList<Element> stack = tb.getStack();\n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { \n                                    tb.removeFromStack(node);\n                                    continue;\n                                } else if (node == formatEl)\n                                    break;\n                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n                                if (lastNode == furthestBlock) {\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n                                lastNode = node;\n                            }\n                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); \n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"span\")) {\n                        return anyOtherEndTag(t, tb);\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.processEndTag(\"body\");\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.processStartTag(name); \n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n                    break;\n                case EOF:\n                    break;\n            }\n            return true;\n        }\n"}
{"bug_id": "Jsoup-82", "buggy_code": "1     static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n2         if (input == null) \n3             return new Document(baseUri);\n4         input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n5         Document doc = null;\n6         boolean fullyRead = false;\n7         input.mark(bufferSize);\n8         ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); \n9         fullyRead = input.read() == -1;\n10         input.reset();\n11         BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n12         if (bomCharset != null)\n13             charsetName = bomCharset.charset;\n14         if (charsetName == null) { \n15             String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n16             doc = parser.parseInput(docData, baseUri);\n17             Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n18             String foundCharset = null; \n19             for (Element meta : metaElements) {\n20                 if (meta.hasAttr(\"http-equiv\"))\n21                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n22                 if (foundCharset == null && meta.hasAttr(\"charset\"))\n23                     foundCharset = meta.attr(\"charset\");\n24                 if (foundCharset != null)\n25                     break;\n26             }\n27             if (foundCharset == null && doc.childNodeSize() > 0) {\n28                 Node first = doc.childNode(0);\n29                 XmlDeclaration decl = null;\n30                 if (first instanceof XmlDeclaration)\n31                     decl = (XmlDeclaration) first;\n32                 else if (first instanceof Comment) {\n33                     Comment comment = (Comment) first;\n34                     if (comment.isXmlDeclaration())\n35                         decl = comment.asXmlDeclaration();\n36                 }\n37                 if (decl != null) {\n38                     if (decl.name().equalsIgnoreCase(\"xml\"))\n39                         foundCharset = decl.attr(\"encoding\");\n40                 }\n41             }\n42             foundCharset = validateCharset(foundCharset);\n43             if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { \n44                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n45                 charsetName = foundCharset;\n46                 doc = null;\n47             } else if (!fullyRead) {\n48                 doc = null;\n49             }\n50         } else { \n51             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n52         }\n53         if (doc == null) {\n54             if (charsetName == null)\n55                 charsetName = defaultCharset;\n56             BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n57             if (bomCharset != null && bomCharset.offset) \n58                 reader.skip(1);\n59             try {\n60                 doc = parser.parseInput(reader, baseUri);\n61             } catch (UncheckedIOException e) {\n62                 throw e.ioException();\n63             }\n64             Charset charset = Charset.forName(charsetName);\n65             doc.outputSettings().charset(charset);\n66         }\n67         input.close();\n68         return doc;\n69     }\n", "fixed_code": "    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) \n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n        Document doc = null;\n        boolean fullyRead = false;\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); \n        fullyRead = input.read() == -1;\n        input.reset();\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n        if (charsetName == null) { \n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; \n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { \n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { \n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) \n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                doc.charset(Charset.forName(defaultCharset));\n            }\n        }\n        input.close();\n        return doc;\n    }\n"}
{"bug_id": "Time-22", "buggy_code": "1     protected BasePeriod(long duration) {\n2         this(duration, null, null);\n3     }\n", "fixed_code": "    protected BasePeriod(long duration) {\n        super();\n        iType = PeriodType.time();\n        int[] values = ISOChronology.getInstanceUTC().get(this, duration);\n        iType = PeriodType.standard();\n        iValues = new int[8];\n        System.arraycopy(values, 0, iValues, 4, 4);\n    }\n"}
{"bug_id": "Closure-164", "buggy_code": "1   public boolean isSubtype(JSType other) {\n2     if (!(other instanceof ArrowType)) {\n3       return false;\n4     }\n5     ArrowType that = (ArrowType) other;\n6     if (!this.returnType.isSubtype(that.returnType)) {\n7       return false;\n8     }\n9     Node thisParam = parameters.getFirstChild();\n10     Node thatParam = that.parameters.getFirstChild();\n11     while (thisParam != null && thatParam != null) {\n12       JSType thisParamType = thisParam.getJSType();\n13       JSType thatParamType = thatParam.getJSType();\n14       if (thisParamType != null) {\n15         if (thatParamType == null ||\n16             !thatParamType.isSubtype(thisParamType)) {\n17           return false;\n18         }\n19       }\n20       boolean thisIsVarArgs = thisParam.isVarArgs();\n21       boolean thatIsVarArgs = thatParam.isVarArgs();\n22       if (!thisIsVarArgs) {\n23         thisParam = thisParam.getNext();\n24       }\n25       if (!thatIsVarArgs) {\n26         thatParam = thatParam.getNext();\n27       }\n28       if (thisIsVarArgs && thatIsVarArgs) {\n29         thisParam = null;\n30         thatParam = null;\n31       }\n32     }\n33     return true;\n34   }\n", "fixed_code": "  public boolean isSubtype(JSType other) {\n    if (!(other instanceof ArrowType)) {\n      return false;\n    }\n    ArrowType that = (ArrowType) other;\n    if (!this.returnType.isSubtype(that.returnType)) {\n      return false;\n    }\n    Node thisParam = parameters.getFirstChild();\n    Node thatParam = that.parameters.getFirstChild();\n    while (thisParam != null && thatParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType thatParamType = thatParam.getJSType();\n      if (thisParamType != null) {\n        if (thatParamType == null ||\n            !thatParamType.isSubtype(thisParamType)) {\n          return false;\n        }\n      }\n      boolean thisIsVarArgs = thisParam.isVarArgs();\n      boolean thatIsVarArgs = thatParam.isVarArgs();\n      boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg();\n      boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg();\n      if (!thisIsOptional && thatIsOptional) {\n        boolean isTopFunction =\n            thatIsVarArgs &&\n            (thatParamType == null ||\n             thatParamType.isUnknownType() ||\n             thatParamType.isNoType());\n        if (!isTopFunction) {\n          return false;\n        }\n      }\n      if (!thisIsVarArgs) {\n        thisParam = thisParam.getNext();\n      }\n      if (!thatIsVarArgs) {\n        thatParam = thatParam.getNext();\n      }\n      if (thisIsVarArgs && thatIsVarArgs) {\n        thisParam = null;\n        thatParam = null;\n      }\n    }\n    if (thisParam != null\n        && !thisParam.isOptionalArg() && !thisParam.isVarArgs()\n        && thatParam == null) {\n      return false;\n    }\n    return true;\n  }\n"}
{"bug_id": "Math-11", "buggy_code": "1     public double density(final double[] vals) throws DimensionMismatchException {\n2         final int dim = getDimension();\n3         if (vals.length != dim) {\n4             throw new DimensionMismatchException(vals.length, dim);\n5         }\n6         return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n7             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n8             getExponentTerm(vals);\n9     }\n", "fixed_code": "    public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }\n"}
{"bug_id": "Closure-160", "buggy_code": "1   public void initOptions(CompilerOptions options) {\n2     this.options = options;\n3     if (errorManager == null) {\n4       if (outStream == null) {\n5         setErrorManager(\n6             new LoggerErrorManager(createMessageFormatter(), logger));\n7       } else {\n8         PrintStreamErrorManager printer =\n9             new PrintStreamErrorManager(createMessageFormatter(), outStream);\n10         printer.setSummaryDetailLevel(options.summaryDetailLevel);\n11         setErrorManager(printer);\n12       }\n13     }\n14     if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n15       options.checkTypes = true;\n16     } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n17       options.checkTypes = false;\n18     } else if (!options.checkTypes) {\n19       options.setWarningLevel(\n20           DiagnosticGroup.forType(\n21               RhinoErrorReporter.TYPE_PARSE_ERROR),\n22           CheckLevel.OFF);\n23     }\n24     if (options.checkGlobalThisLevel.isOn()) {\n25       options.setWarningLevel(\n26           DiagnosticGroups.GLOBAL_THIS,\n27           options.checkGlobalThisLevel);\n28     }\n29     List<WarningsGuard> guards = Lists.newArrayList();\n30     guards.add(\n31         new SuppressDocWarningsGuard(\n32             getDiagnosticGroups().getRegisteredGroups()));\n33     guards.add(options.getWarningsGuard());\n34     if (!options.checkSymbols &&\n35         (warningsGuard == null || !warningsGuard.disables(\n36             DiagnosticGroups.CHECK_VARIABLES))) {\n37       guards.add(new DiagnosticGroupWarningsGuard(\n38           DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n39     }\n40     this.warningsGuard = new ComposeWarningsGuard(guards);\n41   }\n", "fixed_code": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n    this.warningsGuard = composedGuards;\n  }\n"}
{"bug_id": "Closure-50", "buggy_code": "1   private Node tryFoldArrayJoin(Node n) {\n2     Node callTarget = n.getFirstChild();\n3     if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n4       return n;\n5     }\n6     Node right = callTarget.getNext();\n7     if (right != null) {\n8       if (!NodeUtil.isImmutableValue(right)) {\n9         return n;\n10       }\n11     }\n12     Node arrayNode = callTarget.getFirstChild();\n13     Node functionName = arrayNode.getNext();\n14     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n15         !functionName.getString().equals(\"join\")) {\n16       return n;\n17     }\n18     String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n19     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n20     StringBuilder sb = null;\n21     int foldedSize = 0;\n22     Node prev = null;\n23     Node elem = arrayNode.getFirstChild();\n24     while (elem != null) {\n25       if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n26         if (sb == null) {\n27           sb = new StringBuilder();\n28         } else {\n29           sb.append(joinString);\n30         }\n31         sb.append(NodeUtil.getArrayElementStringValue(elem));\n32       } else {\n33         if (sb != null) {\n34           Preconditions.checkNotNull(prev);\n35           foldedSize += sb.length() + 2;\n36           arrayFoldedChildren.add(\n37               Node.newString(sb.toString()).copyInformationFrom(prev));\n38           sb = null;\n39         }\n40         foldedSize += InlineCostEstimator.getCost(elem);\n41         arrayFoldedChildren.add(elem);\n42       }\n43       prev = elem;\n44       elem = elem.getNext();\n45     }\n46     if (sb != null) {\n47       Preconditions.checkNotNull(prev);\n48       foldedSize += sb.length() + 2;\n49       arrayFoldedChildren.add(\n50           Node.newString(sb.toString()).copyInformationFrom(prev));\n51     }\n52     foldedSize += arrayFoldedChildren.size() - 1;\n53     int originalSize = InlineCostEstimator.getCost(n);\n54     switch (arrayFoldedChildren.size()) {\n55       case 0:\n56         Node emptyStringNode = Node.newString(\"\");\n57         n.getParent().replaceChild(n, emptyStringNode);\n58         reportCodeChange();\n59         return emptyStringNode;\n60       case 1:\n61         Node foldedStringNode = arrayFoldedChildren.remove(0);\n62         if (foldedSize > originalSize) {\n63           return n;\n64         }\n65         arrayNode.detachChildren();\n66         if (foldedStringNode.getType() != Token.STRING) {\n67           Node replacement = new Node(Token.ADD,\n68               Node.newString(\"\").copyInformationFrom(n),\n69               foldedStringNode);\n70           foldedStringNode = replacement;\n71         }\n72         n.getParent().replaceChild(n, foldedStringNode);\n73         reportCodeChange();\n74         return foldedStringNode;\n75       default:\n76         if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n77           return n;\n78         }\n79         int kJoinOverhead = \"[].join()\".length();\n80         foldedSize += kJoinOverhead;\n81         foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n82         if (foldedSize > originalSize) {\n83           return n;\n84         }\n85         arrayNode.detachChildren();\n86         for (Node node : arrayFoldedChildren) {\n87           arrayNode.addChildToBack(node);\n88         }\n89         reportCodeChange();\n90         break;\n91     }\n92     return n;\n93   }\n", "fixed_code": "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n    Node right = callTarget.getNext();\n    if (right != null) {\n      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {\n        return n;\n      }\n    }\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n    if (right != null && right.getType() == Token.STRING\n        && \",\".equals(right.getString())) {\n      n.removeChild(right);\n      reportCodeChange();\n    }\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize += arrayFoldedChildren.size() - 1;\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n    return n;\n  }\n"}
{"bug_id": "Time-19", "buggy_code": "1     public int getOffsetFromLocal(long instantLocal) {\n2         final int offsetLocal = getOffset(instantLocal);\n3         final long instantAdjusted = instantLocal - offsetLocal;\n4         final int offsetAdjusted = getOffset(instantAdjusted);\n5         if (offsetLocal != offsetAdjusted) {\n6             if ((offsetLocal - offsetAdjusted) < 0) {\n7                 long nextLocal = nextTransition(instantAdjusted);\n8                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n9                 if (nextLocal != nextAdjusted) {\n10                     return offsetLocal;\n11                 }\n12             }\n13         } else if (offsetLocal > 0) {\n14             long prev = previousTransition(instantAdjusted);\n15             if (prev < instantAdjusted) {\n16                 int offsetPrev = getOffset(prev);\n17                 int diff = offsetPrev - offsetLocal;\n18                 if (instantAdjusted - prev <= diff) {\n19                     return offsetPrev;\n20                 }\n21             }\n22         }\n23         return offsetAdjusted;\n24     }\n", "fixed_code": "    public int getOffsetFromLocal(long instantLocal) {\n        final int offsetLocal = getOffset(instantLocal);\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        if (offsetLocal != offsetAdjusted) {\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n"}
{"bug_id": "Math-95", "buggy_code": "1     protected double getInitialDomain(double p) {\n2         double ret;\n3         double d = getDenominatorDegreesOfFreedom();\n4             ret = d / (d - 2.0);\n5         return ret;\n6     }\n", "fixed_code": "    protected double getInitialDomain(double p) {\n        double ret = 1.0;\n        double d = getDenominatorDegreesOfFreedom();\n        if (d > 2.0) {\n            ret = d / (d - 2.0);\n        }\n        return ret;\n    }\n"}
{"bug_id": "JacksonCore-11", "buggy_code": "1     private void _verifySharing()\n2     {\n3         if (_hashShared) {\n4             _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n5             _names = Arrays.copyOf(_names, _names.length);\n6             _hashShared = false;\n7         }\n8         if (_needRehash) {\n9             rehash();\n10         }\n11     }\n", "fixed_code": "    private void _verifySharing()\n    {\n        if (_hashShared) {\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n            _verifyNeedForRehash();\n        }\n        if (_needRehash) {\n            rehash();\n        }\n    }\n"}
{"bug_id": "Math-91", "buggy_code": "1     public int compareTo(Fraction object) {\n2         double nOd = doubleValue();\n3         double dOn = object.doubleValue();\n4         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n5     }\n", "fixed_code": "    public int compareTo(Fraction object) {\n        long nOd = ((long) numerator) * object.denominator;\n        long dOn = ((long) denominator) * object.numerator;\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }\n"}
{"bug_id": "Math-73", "buggy_code": "1     public double solve(final UnivariateRealFunction f,\n2                         final double min, final double max, final double initial)\n3         throws MaxIterationsExceededException, FunctionEvaluationException {\n4         clearResult();\n5         verifySequence(min, initial, max);\n6         double yInitial = f.value(initial);\n7         if (Math.abs(yInitial) <= functionValueAccuracy) {\n8             setResult(initial, 0);\n9             return result;\n10         }\n11         double yMin = f.value(min);\n12         if (Math.abs(yMin) <= functionValueAccuracy) {\n13             setResult(yMin, 0);\n14             return result;\n15         }\n16         if (yInitial * yMin < 0) {\n17             return solve(f, min, yMin, initial, yInitial, min, yMin);\n18         }\n19         double yMax = f.value(max);\n20         if (Math.abs(yMax) <= functionValueAccuracy) {\n21             setResult(yMax, 0);\n22             return result;\n23         }\n24         if (yInitial * yMax < 0) {\n25             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n26         }\n27         return solve(f, min, yMin, max, yMax, initial, yInitial);\n28     }\n", "fixed_code": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        verifySequence(min, initial, max);\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n    }\n"}
{"bug_id": "Closure-17", "buggy_code": "1     private JSType getDeclaredType(String sourceName, JSDocInfo info,\n2         Node lValue, @Nullable Node rValue) {\n3       if (info != null && info.hasType()) {\n4         return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n5       } else if (rValue != null && rValue.isFunction() &&\n6           shouldUseFunctionLiteralType(\n7               JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n8         return rValue.getJSType();\n9       } else if (info != null) {\n10         if (info.hasEnumParameterType()) {\n11           if (rValue != null && rValue.isObjectLit()) {\n12             return rValue.getJSType();\n13           } else {\n14             return createEnumTypeFromNodes(\n15                 rValue, lValue.getQualifiedName(), info, lValue);\n16           }\n17         } else if (info.isConstructor() || info.isInterface()) {\n18           return createFunctionTypeFromNodes(\n19               rValue, lValue.getQualifiedName(), info, lValue);\n20         } else {\n21           if (info.isConstant()) {\n22             JSType knownType = null;\n23             if (rValue != null) {\n24               if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n25                 return rValue.getJSType();\n26               } else if (rValue.isOr()) {\n27                 Node firstClause = rValue.getFirstChild();\n28                 Node secondClause = firstClause.getNext();\n29                 boolean namesMatch = firstClause.isName()\n30                     && lValue.isName()\n31                     && firstClause.getString().equals(lValue.getString());\n32                 if (namesMatch && secondClause.getJSType() != null\n33                     && !secondClause.getJSType().isUnknownType()) {\n34                   return secondClause.getJSType();\n35                 }\n36               }\n37             }\n38           }\n39         }\n40       }\n41       return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n42     }\n", "fixed_code": "    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      } else if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n      } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.isObjectLit()) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n          if (info.isConstant()) {\n            JSType knownType = null;\n            if (rValue != null) {\n              JSDocInfo rValueInfo = rValue.getJSDocInfo();\n              if (rValueInfo != null && rValueInfo.hasType()) {\n                return rValueInfo.getType().evaluate(scope, typeRegistry);\n              } else if (rValue.getJSType() != null\n                  && !rValue.getJSType().isUnknownType()) {\n                return rValue.getJSType();\n              } else if (rValue.isOr()) {\n                Node firstClause = rValue.getFirstChild();\n                Node secondClause = firstClause.getNext();\n                boolean namesMatch = firstClause.isName()\n                    && lValue.isName()\n                    && firstClause.getString().equals(lValue.getString());\n                if (namesMatch && secondClause.getJSType() != null\n                    && !secondClause.getJSType().isUnknownType()) {\n                  return secondClause.getJSType();\n                }\n              }\n            }\n          }\n        }\n      }\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }\n"}
{"bug_id": "Gson-10", "buggy_code": "1   private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n2       final Gson context, final Field field, final String name,\n3       final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n4     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n5     JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n6     TypeAdapter<?> mapped = null;\n7     if (annotation != null) {\n8       mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n9     }\n10     final boolean jsonAdapterPresent = mapped != null;\n11     if (mapped == null) mapped = context.getAdapter(fieldType);\n12     final TypeAdapter<?> typeAdapter = mapped;\n13     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n14       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n15       @Override void write(JsonWriter writer, Object value)\n16           throws IOException, IllegalAccessException {\n17         Object fieldValue = field.get(value);\n18         TypeAdapter t =\n19           new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n20         t.write(writer, fieldValue);\n21       }\n22       @Override void read(JsonReader reader, Object value)\n23           throws IOException, IllegalAccessException {\n24         Object fieldValue = typeAdapter.read(reader);\n25         if (fieldValue != null || !isPrimitive) {\n26           field.set(value, fieldValue);\n27         }\n28       }\n29       @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n30         if (!serialized) return false;\n31         Object fieldValue = field.get(value);\n32         return fieldValue != value; \n33       }\n34     };\n35   }\n", "fixed_code": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t = jsonAdapterPresent ? typeAdapter\n            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; \n      }\n    };\n  }\n"}
{"bug_id": "JacksonDatabind-33", "buggy_code": "1     public PropertyName findNameForSerialization(Annotated a)\n2     {\n3         String name = null;\n4         JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n5         if (jg != null) {\n6             name = jg.value();\n7         } else {\n8             JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n9             if (pann != null) {\n10                 name = pann.value();\n11             } else if (_hasAnnotation(a, JsonSerialize.class)\n12                     || _hasAnnotation(a, JsonView.class)\n13                     || _hasAnnotation(a, JsonRawValue.class)) {\n14                 name = \"\";\n15             } else {\n16                 return null;\n17             }\n18         }\n19         return PropertyName.construct(name);\n20     }\n", "fixed_code": "    public PropertyName findNameForSerialization(Annotated a)\n    {\n        String name = null;\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            name = jg.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n            } else if (_hasAnnotation(a, JsonSerialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonRawValue.class)\n                    || _hasAnnotation(a, JsonUnwrapped.class)\n                    || _hasAnnotation(a, JsonBackReference.class)\n                    || _hasAnnotation(a, JsonManagedReference.class)) {\n                name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }\n"}
{"bug_id": "Closure-104", "buggy_code": "1   JSType meet(JSType that) {\n2     UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n3     for (JSType alternate : alternates) {\n4       if (alternate.isSubtype(that)) {\n5         builder.addAlternate(alternate);\n6       }\n7     }\n8     if (that instanceof UnionType) {\n9       for (JSType otherAlternate : ((UnionType) that).alternates) {\n10         if (otherAlternate.isSubtype(this)) {\n11           builder.addAlternate(otherAlternate);\n12         }\n13       }\n14     } else if (that.isSubtype(this)) {\n15       builder.addAlternate(that);\n16     }\n17     JSType result = builder.build();\n18     if (result != null) {\n19       return result;\n20     } else if (this.isObject() && that.isObject()) {\n21       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n22     } else {\n23       return getNativeType(JSTypeNative.NO_TYPE);\n24     }\n25   }\n", "fixed_code": "  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    JSType result = builder.build();\n    if (!result.isNoType()) {\n      return result;\n    } else if (this.isObject() && that.isObject()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }\n"}
{"bug_id": "JacksonDatabind-42", "buggy_code": "1         protected Object _deserializeFromEmptyString() throws IOException {\n2             if (_kind == STD_URI) {\n3                 return URI.create(\"\");\n4             }\n5             return super._deserializeFromEmptyString();\n6         }\n", "fixed_code": "        protected Object _deserializeFromEmptyString() throws IOException {\n            if (_kind == STD_URI) {\n                return URI.create(\"\");\n            }\n            if (_kind == STD_LOCALE) {\n                return Locale.ROOT;\n            }\n            return super._deserializeFromEmptyString();\n        }\n"}
{"bug_id": "Math-9", "buggy_code": "1     public Line revert() {\n2         final Line reverted = new Line(zero, zero.subtract(direction));\n3         return reverted;\n4     }\n", "fixed_code": "    public Line revert() {\n        final Line reverted = new Line(this);\n        reverted.direction = reverted.direction.negate();\n        return reverted;\n    }\n"}
{"bug_id": "JacksonDatabind-96", "buggy_code": "1     protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n2             BeanDescription beanDesc, CreatorCollector creators,\n3             CreatorCandidate candidate)\n4         throws JsonMappingException\n5     {\n6         if (1 != candidate.paramCount()) {\n7             int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n8             if (oneNotInjected >= 0) {\n9                 if (candidate.paramName(oneNotInjected) == null) {\n10                     _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n11                     return;\n12                 }\n13             }\n14             _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n15             return;\n16         }\n17         AnnotatedParameter param = candidate.parameter(0);\n18         JacksonInject.Value injectId = candidate.injection(0);\n19         PropertyName paramName = candidate.explicitParamName(0);\n20         BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n21         boolean useProps = (paramName != null) || (injectId != null);\n22         if (!useProps && (paramDef != null)) {\n23             paramName = candidate.findImplicitParamName(0);\n24             useProps = (paramName != null) && paramDef.couldSerialize();\n25         }\n26         if (useProps) {\n27             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n28                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n29             };\n30             creators.addPropertyCreator(candidate.creator(), true, properties);\n31             return;\n32         }\n33         _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n34         if (paramDef != null) {\n35             ((POJOPropertyBuilder) paramDef).removeConstructors();\n36         }\n37     }\n", "fixed_code": "    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        if (1 != candidate.paramCount()) {\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            paramName = candidate.paramName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n"}
{"bug_id": "Cli-11", "buggy_code": "1     private static void appendOption(final StringBuffer buff, \n2                                      final Option option, \n3                                      final boolean required)\n4     {\n5         if (!required)\n6         {\n7             buff.append(\"[\");\n8         }\n9         if (option.getOpt() != null)\n10         {\n11             buff.append(\"-\").append(option.getOpt());\n12         }\n13         else\n14         {\n15             buff.append(\"--\").append(option.getLongOpt());\n16         }\n17         if (option.hasArg() && (option.getArgName() != null))\n18         {\n19             buff.append(\" <\").append(option.getArgName()).append(\">\");\n20         }\n21         if (!required)\n22         {\n23             buff.append(\"]\");\n24         }\n25     }\n", "fixed_code": "    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n"}
{"bug_id": "Closure-2", "buggy_code": "1   private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n2       String functionName, HashMap<String, ObjectType> properties,\n3       HashMap<String, ObjectType> currentProperties,\n4       ObjectType interfaceType) {\n5     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n6     Set<String> currentPropertyNames;\n7       currentPropertyNames = implicitProto.getOwnPropertyNames();\n8     for (String name : currentPropertyNames) {\n9       ObjectType oType = properties.get(name);\n10       if (oType != null) {\n11         if (!interfaceType.getPropertyType(name).isEquivalentTo(\n12             oType.getPropertyType(name))) {\n13           compiler.report(\n14               t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n15                   functionName, name, oType.toString(),\n16                   interfaceType.toString()));\n17         }\n18       }\n19       currentProperties.put(name, interfaceType);\n20     }\n21     for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n22       checkInterfaceConflictProperties(t, n, functionName, properties,\n23           currentProperties, iType);\n24     }\n25   }\n", "fixed_code": "  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n    if (implicitProto == null) {\n      currentPropertyNames = ImmutableSet.of();\n    } else {\n      currentPropertyNames = implicitProto.getOwnPropertyNames();\n    }\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n      checkInterfaceConflictProperties(t, n, functionName, properties,\n          currentProperties, iType);\n    }\n  }\n"}
{"bug_id": "Math-21", "buggy_code": "1     public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n2         throws NonPositiveDefiniteMatrixException {\n3         final int order = matrix.getRowDimension();\n4         final double[][] c = matrix.getData();\n5         final double[][] b = new double[order][order];\n6         int[] swap  = new int[order];\n7         int[] index = new int[order];\n8         for (int i = 0; i < order; ++i) {\n9             index[i] = i;\n10         }\n11         int r = 0;\n12         for (boolean loop = true; loop;) {\n13             swap[r] = r;\n14             for (int i = r + 1; i < order; ++i) {\n15                 int ii  = index[i];\n16                 int isi = index[swap[i]];\n17                 if (c[ii][ii] > c[isi][isi]) {\n18                     swap[r] = i;\n19                 }\n20             }\n21             if (swap[r] != r) {\n22                 int tmp = index[r];\n23                 index[r] = index[swap[r]];\n24                 index[swap[r]] = tmp;\n25             }\n26             int ir = index[r];\n27             if (c[ir][ir] < small) {\n28                 if (r == 0) {\n29                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n30                 }\n31                 for (int i = r; i < order; ++i) {\n32                     if (c[index[i]][index[i]] < -small) {\n33                         throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n34                     }\n35                 }\n36                 ++r;\n37                 loop = false;\n38             } else {\n39                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n40                 b[r][r] = sqrt;\n41                 final double inverse  = 1 / sqrt;\n42                 for (int i = r + 1; i < order; ++i) {\n43                     final int ii = index[i];\n44                     final double e = inverse * c[ii][ir];\n45                     b[i][r] = e;\n46                     c[ii][ii] -= e * e;\n47                     for (int j = r + 1; j < i; ++j) {\n48                         final int ij = index[j];\n49                         final double f = c[ii][ij] - e * b[j][r];\n50                         c[ii][ij] = f;\n51                         c[ij][ii] = f;\n52                     }\n53                 }\n54                 loop = ++r < order;\n55             }\n56         }\n57         rank = r;\n58         root = MatrixUtils.createRealMatrix(order, r);\n59         for (int i = 0; i < order; ++i) {\n60             for (int j = 0; j < r; ++j) {\n61                 root.setEntry(index[i], j, b[i][j]);\n62             }\n63         }\n64     }\n", "fixed_code": "    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        for (boolean loop = true; loop;) {\n            int swapR = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isr = index[swapR];\n                if (c[ii][ii] > c[isr][isr]) {\n                    swapR = i;\n                }\n            }\n            if (swapR != r) {\n                final int tmpIndex    = index[r];\n                index[r]              = index[swapR];\n                index[swapR]          = tmpIndex;\n                final double[] tmpRow = b[r];\n                b[r]                  = b[swapR];\n                b[swapR]              = tmpRow;\n            }\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n                for (int i = r; i < order; ++i) {\n                    if (c[index[i]][index[i]] < -small) {\n                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n                    }\n                }\n                ++r;\n                loop = false;\n            } else {\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt;\n                final double inverse  = 1 / sqrt;\n                final double inverse2 = 1 / c[ir][ir];\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i];\n                    final double e = inverse * c[ii][ir];\n                    b[i][r] = e;\n                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n                loop = ++r < order;\n            }\n        }\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }\n"}
{"bug_id": "Jsoup-10", "buggy_code": "1     public String absUrl(String attributeKey) {\n2         Validate.notEmpty(attributeKey);\n3         String relUrl = attr(attributeKey);\n4         if (!hasAttr(attributeKey)) {\n5             return \"\"; \n6         } else {\n7             URL base;\n8             try {\n9                 try {\n10                     base = new URL(baseUri);\n11                 } catch (MalformedURLException e) {\n12                     URL abs = new URL(relUrl);\n13                     return abs.toExternalForm();\n14                 }\n15                 URL abs = new URL(base, relUrl);\n16                 return abs.toExternalForm();\n17             } catch (MalformedURLException e) {\n18                 return \"\";\n19             }\n20         }\n21     }\n", "fixed_code": "    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; \n        } else {\n            URL base;\n            try {\n                try {\n                    base = new URL(baseUri);\n                } catch (MalformedURLException e) {\n                    URL abs = new URL(relUrl);\n                    return abs.toExternalForm();\n                }\n                if (relUrl.startsWith(\"?\"))\n                    relUrl = base.getPath() + relUrl;\n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\";\n            }\n        }\n    }\n"}
{"bug_id": "Math-101", "buggy_code": "1     public Complex parse(String source, ParsePosition pos) {\n2         int initialIndex = pos.getIndex();\n3         parseAndIgnoreWhitespace(source, pos);\n4         Number re = parseNumber(source, getRealFormat(), pos);\n5         if (re == null) {\n6             pos.setIndex(initialIndex);\n7             return null;\n8         }\n9         int startIndex = pos.getIndex();\n10         char c = parseNextCharacter(source, pos);\n11         int sign = 0;\n12         switch (c) {\n13         case 0 :\n14             return new Complex(re.doubleValue(), 0.0);\n15         case '-' :\n16             sign = -1;\n17             break;\n18         case '+' :\n19             sign = 1;\n20             break;\n21         default :\n22             pos.setIndex(initialIndex);\n23             pos.setErrorIndex(startIndex);\n24             return null;\n25         }\n26         parseAndIgnoreWhitespace(source, pos);\n27         Number im = parseNumber(source, getRealFormat(), pos);\n28         if (im == null) {\n29             pos.setIndex(initialIndex);\n30             return null;\n31         }\n32         int n = getImaginaryCharacter().length();\n33         startIndex = pos.getIndex();\n34         int endIndex = startIndex + n;\n35         if (\n36             source.substring(startIndex, endIndex).compareTo(\n37             getImaginaryCharacter()) != 0) {\n38             pos.setIndex(initialIndex);\n39             pos.setErrorIndex(startIndex);\n40             return null;\n41         }\n42         pos.setIndex(endIndex);\n43         return new Complex(re.doubleValue(), im.doubleValue() * sign);\n44     }\n", "fixed_code": "    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n        parseAndIgnoreWhitespace(source, pos);\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        parseAndIgnoreWhitespace(source, pos);\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if ((startIndex >= source.length()) ||\n            (endIndex > source.length()) ||\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n"}
{"bug_id": "Codec-10", "buggy_code": "1     public String caverphone(String txt) {\n2         if( txt == null || txt.length() == 0 ) {\n3             return \"1111111111\";\n4         }\n5         txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n6         txt = txt.replaceAll(\"[^a-z]\", \"\");\n7         txt = txt.replaceAll(\"e$\", \"\");             \n8         txt = txt.replaceAll(\"^cough\", \"cou2f\");\n9         txt = txt.replaceAll(\"^rough\", \"rou2f\");\n10         txt = txt.replaceAll(\"^tough\", \"tou2f\");\n11         txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n12         txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n13         txt = txt.replaceAll(\"^gn\", \"2n\");\n14         txt = txt.replaceAll(\"^mb\", \"m2\");\n15         txt = txt.replaceAll(\"cq\", \"2q\");\n16         txt = txt.replaceAll(\"ci\", \"si\");\n17         txt = txt.replaceAll(\"ce\", \"se\");\n18         txt = txt.replaceAll(\"cy\", \"sy\");\n19         txt = txt.replaceAll(\"tch\", \"2ch\");\n20         txt = txt.replaceAll(\"c\", \"k\");\n21         txt = txt.replaceAll(\"q\", \"k\");\n22         txt = txt.replaceAll(\"x\", \"k\");\n23         txt = txt.replaceAll(\"v\", \"f\");\n24         txt = txt.replaceAll(\"dg\", \"2g\");\n25         txt = txt.replaceAll(\"tio\", \"sio\");\n26         txt = txt.replaceAll(\"tia\", \"sia\");\n27         txt = txt.replaceAll(\"d\", \"t\");\n28         txt = txt.replaceAll(\"ph\", \"fh\");\n29         txt = txt.replaceAll(\"b\", \"p\");\n30         txt = txt.replaceAll(\"sh\", \"s2\");\n31         txt = txt.replaceAll(\"z\", \"s\");\n32         txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n33         txt = txt.replaceAll(\"[aeiou]\", \"3\");\n34         txt = txt.replaceAll(\"j\", \"y\");        \n35         txt = txt.replaceAll(\"^y3\", \"Y3\");     \n36         txt = txt.replaceAll(\"^y\", \"A\");       \n37         txt = txt.replaceAll(\"y\", \"3\");        \n38         txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n39         txt = txt.replaceAll(\"gh\", \"22\");\n40         txt = txt.replaceAll(\"g\", \"k\");\n41         txt = txt.replaceAll(\"s+\", \"S\");\n42         txt = txt.replaceAll(\"t+\", \"T\");\n43         txt = txt.replaceAll(\"p+\", \"P\");\n44         txt = txt.replaceAll(\"k+\", \"K\");\n45         txt = txt.replaceAll(\"f+\", \"F\");\n46         txt = txt.replaceAll(\"m+\", \"M\");\n47         txt = txt.replaceAll(\"n+\", \"N\");\n48         txt = txt.replaceAll(\"w3\", \"W3\");\n49         txt = txt.replaceAll(\"wh3\", \"Wh3\");\n50         txt = txt.replaceAll(\"w$\", \"3\");       \n51         txt = txt.replaceAll(\"w\", \"2\");\n52         txt = txt.replaceAll(\"^h\", \"A\");\n53         txt = txt.replaceAll(\"h\", \"2\");\n54         txt = txt.replaceAll(\"r3\", \"R3\");\n55         txt = txt.replaceAll(\"r$\", \"3\");       \n56         txt = txt.replaceAll(\"r\", \"2\");\n57         txt = txt.replaceAll(\"l3\", \"L3\");\n58         txt = txt.replaceAll(\"l$\", \"3\");       \n59         txt = txt.replaceAll(\"l\", \"2\");\n60         txt = txt.replaceAll(\"2\", \"\");\n61         txt = txt.replaceAll(\"3$\", \"A\");       \n62         txt = txt.replaceAll(\"3\", \"\");\n63         txt = txt + \"111111\" + \"1111\";        \n64         return txt.substring(0, 10);          \n65     }\n", "fixed_code": "    public String caverphone(String txt) {\n        if( txt == null || txt.length() == 0 ) {\n            return \"1111111111\";\n        }\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n        txt = txt.replaceAll(\"e$\", \"\");             \n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n        txt = txt.replaceAll(\"^gn\", \"2n\");\n        txt = txt.replaceAll(\"mb$\", \"m2\");\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"j\", \"y\");        \n        txt = txt.replaceAll(\"^y3\", \"Y3\");     \n        txt = txt.replaceAll(\"^y\", \"A\");       \n        txt = txt.replaceAll(\"y\", \"3\");        \n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"w$\", \"3\");       \n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"r$\", \"3\");       \n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"l$\", \"3\");       \n        txt = txt.replaceAll(\"l\", \"2\");\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3$\", \"A\");       \n        txt = txt.replaceAll(\"3\", \"\");\n        txt = txt + \"111111\" + \"1111\";        \n        return txt.substring(0, 10);          \n    }\n"}
{"bug_id": "Compress-30", "buggy_code": "1     public int read(final byte[] dest, final int offs, final int len)\n2         throws IOException {\n3         if (offs < 0) {\n4             throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n5         }\n6         if (len < 0) {\n7             throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n8         }\n9         if (offs + len > dest.length) {\n10             throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n11                                                 + len + \") > dest.length(\" + dest.length + \").\");\n12         }\n13         if (this.in == null) {\n14             throw new IOException(\"stream closed\");\n15         }\n16         final int hi = offs + len;\n17         int destOffs = offs;\n18         int b;\n19         while (destOffs < hi && ((b = read0()) >= 0)) {\n20             dest[destOffs++] = (byte) b;\n21             count(1);\n22         }\n23         int c = (destOffs == offs) ? -1 : (destOffs - offs);\n24         return c;\n25     }\n", "fixed_code": "    public int read(final byte[] dest, final int offs, final int len)\n        throws IOException {\n        if (offs < 0) {\n            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n        }\n        if (len < 0) {\n            throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n        }\n        if (offs + len > dest.length) {\n            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n                                                + len + \") > dest.length(\" + dest.length + \").\");\n        }\n        if (this.in == null) {\n            throw new IOException(\"stream closed\");\n        }\n        if (len == 0) {\n            return 0;\n        }\n        final int hi = offs + len;\n        int destOffs = offs;\n        int b;\n        while (destOffs < hi && ((b = read0()) >= 0)) {\n            dest[destOffs++] = (byte) b;\n            count(1);\n        }\n        int c = (destOffs == offs) ? -1 : (destOffs - offs);\n        return c;\n    }\n"}
{"bug_id": "Math-5", "buggy_code": "1     public Complex reciprocal() {\n2         if (isNaN) {\n3             return NaN;\n4         }\n5         if (real == 0.0 && imaginary == 0.0) {\n6             return NaN;\n7         }\n8         if (isInfinite) {\n9             return ZERO;\n10         }\n11         if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n12             double q = real / imaginary;\n13             double scale = 1. / (real * q + imaginary);\n14             return createComplex(scale * q, -scale);\n15         } else {\n16             double q = imaginary / real;\n17             double scale = 1. / (imaginary * q + real);\n18             return createComplex(scale, -scale * q);\n19         }\n20     }\n", "fixed_code": "    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n        if (real == 0.0 && imaginary == 0.0) {\n            return INF;\n        }\n        if (isInfinite) {\n            return ZERO;\n        }\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }\n"}
{"bug_id": "Closure-55", "buggy_code": "1   private static boolean isReduceableFunctionExpression(Node n) {\n2     return NodeUtil.isFunctionExpression(n);\n3   }\n", "fixed_code": "  private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n)\n        && !NodeUtil.isGetOrSetKey(n.getParent());\n  }\n"}
{"bug_id": "Closure-67", "buggy_code": "1     private boolean isPrototypePropertyAssign(Node assign) {\n2       Node n = assign.getFirstChild();\n3       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n4           && n.getType() == Token.GETPROP\n5           ) {\n6         boolean isChainedProperty =\n7             n.getFirstChild().getType() == Token.GETPROP;\n8         if (isChainedProperty) {\n9           Node child = n.getFirstChild().getFirstChild().getNext();\n10           if (child.getType() == Token.STRING &&\n11               child.getString().equals(\"prototype\")) {\n12             return true;\n13           }\n14         }\n15       }\n16       return false;\n17     }\n", "fixed_code": "    private boolean isPrototypePropertyAssign(Node assign) {\n      Node n = assign.getFirstChild();\n      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n          && n.getType() == Token.GETPROP\n          && assign.getParent().getType() == Token.EXPR_RESULT) {\n        boolean isChainedProperty =\n            n.getFirstChild().getType() == Token.GETPROP;\n        if (isChainedProperty) {\n          Node child = n.getFirstChild().getFirstChild().getNext();\n          if (child.getType() == Token.STRING &&\n              child.getString().equals(\"prototype\")) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n"}
{"bug_id": "Closure-168", "buggy_code": "1     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n2       if (t.inGlobalScope()) {\n3         return;\n4       }\n5       if (n.isReturn() && n.getFirstChild() != null) {\n6         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n7       }\n8       if (t.getScopeDepth() <= 2) {\n9         return;\n10       }\n11       if (n.isName() && NodeUtil.isLValue(n) &&\n12           !NodeUtil.isBleedingFunctionName(n)) {\n13         String name = n.getString();\n14         Scope scope = t.getScope();\n15         Var var = scope.getVar(name);\n16         if (var != null) {\n17           Scope ownerScope = var.getScope();\n18           if (ownerScope.isLocal()) {\n19             data.get(ownerScope.getRootNode()).recordAssignedName(name);\n20           }\n21           if (scope != ownerScope && ownerScope.isLocal()) {\n22             data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n23           }\n24         }\n25       } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n26           NodeUtil.isLValue(n)) {\n27         String name = NodeUtil.getRootOfQualifiedName(n).getString();\n28         Scope scope = t.getScope();\n29         Var var = scope.getVar(name);\n30         if (var != null) {\n31           Scope ownerScope = var.getScope();\n32           if (scope != ownerScope && ownerScope.isLocal()) {\n33             data.get(ownerScope.getRootNode())\n34                 .recordEscapedQualifiedName(n.getQualifiedName());\n35           }\n36         }\n37       }\n38     }\n", "fixed_code": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n      if (t.getScopeDepth() <= 1) {\n        return;\n      }\n      if (n.isName() && NodeUtil.isLValue(n) &&\n          !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n          }\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n          }\n        }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n          NodeUtil.isLValue(n)) {\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode())\n                .recordEscapedQualifiedName(n.getQualifiedName());\n          }\n        }\n      }\n    }\n"}
{"bug_id": "Closure-39", "buggy_code": "1   String toStringHelper(boolean forAnnotations) {\n2     if (hasReferenceName()) {\n3       return getReferenceName();\n4     } else if (prettyPrint) {\n5       prettyPrint = false;\n6       Set<String> propertyNames = Sets.newTreeSet();\n7       for (ObjectType current = this;\n8            current != null && !current.isNativeObjectType() &&\n9                propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n10            current = current.getImplicitPrototype()) {\n11         propertyNames.addAll(current.getOwnPropertyNames());\n12       }\n13       StringBuilder sb = new StringBuilder();\n14       sb.append(\"{\");\n15       int i = 0;\n16       for (String property : propertyNames) {\n17         if (i > 0) {\n18           sb.append(\", \");\n19         }\n20         sb.append(property);\n21         sb.append(\": \");\n22         sb.append(getPropertyType(property).toString());\n23         ++i;\n24         if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n25           sb.append(\", ...\");\n26           break;\n27         }\n28       }\n29       sb.append(\"}\");\n30       prettyPrint = true;\n31       return sb.toString();\n32     } else {\n33       return \"{...}\";\n34     }\n35   }\n", "fixed_code": "  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      prettyPrint = false;\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n      int i = 0;\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n        sb.append(property);\n        sb.append(\": \");\n        sb.append(getPropertyType(property).toStringHelper(forAnnotations));\n        ++i;\n        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {\n          sb.append(\", ...\");\n          break;\n        }\n      }\n      sb.append(\"}\");\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      return forAnnotations ? \"?\" : \"{...}\";\n    }\n  }\n"}
{"bug_id": "Lang-53", "buggy_code": "1     private static void modify(Calendar val, int field, boolean round) {\n2         if (val.get(Calendar.YEAR) > 280000000) {\n3             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n4         }\n5         if (field == Calendar.MILLISECOND) {\n6             return;\n7         }\n8         Date date = val.getTime();\n9         long time = date.getTime();\n10         boolean done = false;\n11         int millisecs = val.get(Calendar.MILLISECOND);\n12         if (!round || millisecs < 500) {\n13             time = time - millisecs;\n14         if (field == Calendar.SECOND) {\n15             done = true;\n16             }\n17         }\n18         int seconds = val.get(Calendar.SECOND);\n19         if (!done && (!round || seconds < 30)) {\n20             time = time - (seconds * 1000L);\n21         if (field == Calendar.MINUTE) {\n22             done = true;\n23             }\n24         }\n25         int minutes = val.get(Calendar.MINUTE);\n26         if (!done && (!round || minutes < 30)) {\n27             time = time - (minutes * 60000L);\n28         }\n29         if (date.getTime() != time) {\n30             date.setTime(time);\n31             val.setTime(date);\n32         }\n33         boolean roundUp = false;\n34         for (int i = 0; i < fields.length; i++) {\n35             for (int j = 0; j < fields[i].length; j++) {\n36                 if (fields[i][j] == field) {\n37                     if (round && roundUp) {\n38                         if (field == DateUtils.SEMI_MONTH) {\n39                             if (val.get(Calendar.DATE) == 1) {\n40                                 val.add(Calendar.DATE, 15);\n41                             } else {\n42                                 val.add(Calendar.DATE, -15);\n43                                 val.add(Calendar.MONTH, 1);\n44                             }\n45                         } else {\n46                             val.add(fields[i][0], 1);\n47                         }\n48                     }\n49                     return;\n50                 }\n51             }\n52             int offset = 0;\n53             boolean offsetSet = false;\n54             switch (field) {\n55                 case DateUtils.SEMI_MONTH:\n56                     if (fields[i][0] == Calendar.DATE) {\n57                         offset = val.get(Calendar.DATE) - 1;\n58                         if (offset >= 15) {\n59                             offset -= 15;\n60                         }\n61                         roundUp = offset > 7;\n62                         offsetSet = true;\n63                     }\n64                     break;\n65                 case Calendar.AM_PM:\n66                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n67                         offset = val.get(Calendar.HOUR_OF_DAY);\n68                         if (offset >= 12) {\n69                             offset -= 12;\n70                         }\n71                         roundUp = offset > 6;\n72                         offsetSet = true;\n73                     }\n74                     break;\n75             }\n76             if (!offsetSet) {\n77                 int min = val.getActualMinimum(fields[i][0]);\n78                 int max = val.getActualMaximum(fields[i][0]);\n79                 offset = val.get(fields[i][0]) - min;\n80                 roundUp = offset > ((max - min) / 2);\n81             }\n82             if (offset != 0) {\n83                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n84             }\n85         }\n86         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n87     }\n", "fixed_code": "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n        }\n        if (field == Calendar.SECOND) {\n            done = true;\n        }\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        }\n        if (field == Calendar.MINUTE) {\n            done = true;\n        }\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            int offset = 0;\n            boolean offsetSet = false;\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        offset = val.get(Calendar.DATE) - 1;\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                offset = val.get(fields[i][0]) - min;\n                roundUp = offset > ((max - min) / 2);\n            }\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n"}
{"bug_id": "Csv-1", "buggy_code": "1     public int read() throws IOException {\n2         int current = super.read();\n3         if (current == '\\n') {\n4             lineCounter++;\n5         }\n6         lastChar = current;\n7         return lastChar;\n8     }\n", "fixed_code": "    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }\n"}
{"bug_id": "JacksonDatabind-35", "buggy_code": "1     private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n2     {\n3         if (p.canReadTypeId()) {\n4             Object typeId = p.getTypeId();\n5             if (typeId != null) {\n6                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n7             }\n8         }\n9         if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n10             throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n11                     \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n12         }\n13             if (p.nextToken() != JsonToken.FIELD_NAME) {\n14                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n15                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n16             }\n17         final String typeId = p.getText();\n18         JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n19         p.nextToken();\n20         if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n21             TokenBuffer tb = new TokenBuffer(null, false);\n22             tb.writeStartObject(); \n23             tb.writeFieldName(_typePropertyName);\n24             tb.writeString(typeId);\n25             p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n26             p.nextToken();\n27         }\n28         Object value = deser.deserialize(p, ctxt);\n29         if (p.nextToken() != JsonToken.END_OBJECT) {\n30             throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n31                     \"expected closing END_OBJECT after type information and deserialized value\");\n32         }\n33         return value;\n34     }\n", "fixed_code": "    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        if (p.canReadTypeId()) {\n            Object typeId = p.getTypeId();\n            if (typeId != null) {\n                return _deserializeWithNativeTypeId(p, ctxt, typeId);\n            }\n        }\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            if (p.nextToken() != JsonToken.FIELD_NAME) {\n                throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                        \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n            }\n        } else if (t != JsonToken.FIELD_NAME) {\n            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n        }\n        final String typeId = p.getText();\n        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n        p.nextToken();\n        if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n            TokenBuffer tb = new TokenBuffer(null, false);\n            tb.writeStartObject(); \n            tb.writeFieldName(_typePropertyName);\n            tb.writeString(typeId);\n            p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n            p.nextToken();\n        }\n        Object value = deser.deserialize(p, ctxt);\n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                    \"expected closing END_OBJECT after type information and deserialized value\");\n        }\n        return value;\n    }\n"}
{"bug_id": "JacksonDatabind-64", "buggy_code": "1     protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n2             BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n3             TypeSerializer typeSer, TypeSerializer contentTypeSer,\n4             AnnotatedMember am, boolean defaultUseStaticTyping)\n5         throws JsonMappingException\n6     {\n7         JavaType serializationType;\n8         try {\n9             serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n10         } catch (JsonMappingException e) {\n11             return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n12         }\n13         if (contentTypeSer != null) {\n14             if (serializationType == null) {\n15                 serializationType = declaredType;\n16             }\n17             JavaType ct = serializationType.getContentType();\n18             if (ct == null) {\n19                 prov.reportBadPropertyDefinition(_beanDesc, propDef,\n20                         \"serialization type \"+serializationType+\" has no content\");\n21             }\n22             serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n23             ct = serializationType.getContentType();\n24         }\n25         Object valueToSuppress = null;\n26         boolean suppressNulls = false;\n27         JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n28         JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n29                 _defaultInclusion);\n30         inclV = inclV.withOverrides(propDef.findInclusion());\n31         JsonInclude.Include inclusion = inclV.getValueInclusion();\n32         if (inclusion == JsonInclude.Include.USE_DEFAULTS) { \n33             inclusion = JsonInclude.Include.ALWAYS;\n34         }\n35         switch (inclusion) {\n36         case NON_DEFAULT:\n37             if (_useRealPropertyDefaults) {\n38                 if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n39                     am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n40                 }\n41                 valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n42             } else {\n43                 valueToSuppress = getDefaultValue(actualType);\n44                 suppressNulls = true;\n45             }\n46             if (valueToSuppress == null) {\n47                 suppressNulls = true;\n48             } else {\n49                 if (valueToSuppress.getClass().isArray()) {\n50                     valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n51                 }\n52             }\n53             break;\n54         case NON_ABSENT: \n55             suppressNulls = true;\n56             if (actualType.isReferenceType()) {\n57                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n58             }\n59             break;\n60         case NON_EMPTY:\n61             suppressNulls = true;\n62             valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n63             break;\n64         case NON_NULL:\n65             suppressNulls = true;\n66         case ALWAYS: \n67         default:\n68             if (actualType.isContainerType()\n69                     && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n70                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n71             }\n72             break;\n73         }\n74         BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n75                 am, _beanDesc.getClassAnnotations(), declaredType,\n76                 ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n77         Object serDef = _annotationIntrospector.findNullSerializer(am);\n78         if (serDef != null) {\n79             bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n80         }\n81         NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n82         if (unwrapper != null) {\n83             bpw = bpw.unwrappingWriter(unwrapper);\n84         }\n85         return bpw;\n86     }\n", "fixed_code": "    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n        }\n        if (contentTypeSer != null) {\n            if (serializationType == null) {\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            if (ct == null) {\n                prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                        \"serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n                _defaultInclusion);\n        inclV = inclV.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { \n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        switch (inclusion) {\n        case NON_DEFAULT:\n            Object defaultBean;\n            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                try {\n                    valueToSuppress = am.getValue(defaultBean);\n                } catch (Exception e) {\n                    _throwWrapped(e, propDef.getName(), defaultBean);\n                }\n            } else {\n                valueToSuppress = getDefaultValue(actualType);\n                suppressNulls = true;\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case NON_ABSENT: \n            suppressNulls = true;\n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            suppressNulls = true;\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n        case ALWAYS: \n        default:\n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }\n"}
{"bug_id": "Closure-15", "buggy_code": "1       public boolean apply(Node n) {\n2         if (n == null) {\n3           return false;\n4         }\n5         if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n6           return true;\n7         }\n8         if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n9           return true;\n10         }\n11         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n12           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n13             return true;\n14           }\n15         }\n16         return false;\n17       }\n", "fixed_code": "      public boolean apply(Node n) {\n        if (n == null) {\n          return false;\n        }\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n        if (n.isDelProp()) {\n          return true;\n        }\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n"}
{"bug_id": "Math-75", "buggy_code": "1     public double getPct(Object v) {\n2         return getCumPct((Comparable<?>) v);\n3     }\n", "fixed_code": "    public double getPct(Object v) {\n        return getPct((Comparable<?>) v);\n    }\n"}
{"bug_id": "Jsoup-33", "buggy_code": "1     Element insert(Token.StartTag startTag) {\n2         if (startTag.isSelfClosing()) {\n3             Element el = insertEmpty(startTag);\n4             stack.add(el);\n5             tokeniser.emit(new Token.EndTag(el.tagName()));  \n6             return el;\n7         }\n8         Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n9         insert(el);\n10         return el;\n11     }\n", "fixed_code": "    Element insert(Token.StartTag startTag) {\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); \n            tokeniser.emit(new Token.EndTag(el.tagName()));  \n            return el;\n        }\n        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n        insert(el);\n        return el;\n    }\n"}
{"bug_id": "Mockito-24", "buggy_code": "1     public Object answer(InvocationOnMock invocation) {\n2         if (methodsGuru.isToString(invocation.getMethod())) {\n3             Object mock = invocation.getMock();\n4             MockName name = mockUtil.getMockName(mock);\n5             if (name.isDefault()) {\n6                 return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n7             } else {\n8                 return name.toString();\n9             }\n10         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n11             return 1;\n12         }\n13         Class<?> returnType = invocation.getMethod().getReturnType();\n14         return returnValueFor(returnType);\n15     }\n", "fixed_code": "    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n        }\n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n"}
{"bug_id": "JacksonDatabind-11", "buggy_code": "1     protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n2     {\n3         final String name = type.getName();\n4         if (context == null) {\n5             return _unknownType();\n6         } else {\n7             JavaType actualType = context.findType(name);\n8             if (actualType != null) {\n9                 return actualType;\n10             }\n11         }\n12         Type[] bounds = type.getBounds();\n13         context._addPlaceholder(name);\n14         return _constructType(bounds[0], context);\n15     }\n", "fixed_code": "    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        if (context == null) {\n            context = new TypeBindings(this, (Class<?>) null);\n        } else {\n            JavaType actualType = context.findType(name, false);\n            if (actualType != null) {\n                return actualType;\n            }\n        }\n        Type[] bounds = type.getBounds();\n        context._addPlaceholder(name);\n        return _constructType(bounds[0], context);\n    }\n"}
{"bug_id": "Closure-94", "buggy_code": "1   static boolean isValidDefineValue(Node val, Set<String> defines) {\n2     switch (val.getType()) {\n3       case Token.STRING:\n4       case Token.NUMBER:\n5       case Token.TRUE:\n6       case Token.FALSE:\n7         return true;\n8       case Token.BITAND:\n9       case Token.BITNOT:\n10       case Token.BITOR:\n11       case Token.BITXOR:\n12       case Token.NOT:\n13       case Token.NEG:\n14         return isValidDefineValue(val.getFirstChild(), defines);\n15       case Token.NAME:\n16       case Token.GETPROP:\n17         if (val.isQualifiedName()) {\n18           return defines.contains(val.getQualifiedName());\n19         }\n20     }\n21     return false;\n22   }\n", "fixed_code": "  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return isValidDefineValue(val.getFirstChild(), defines)\n            && isValidDefineValue(val.getLastChild(), defines);\n      case Token.NOT:\n      case Token.NEG:\n      case Token.POS:\n        return isValidDefineValue(val.getFirstChild(), defines);\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n    }\n    return false;\n  }\n"}
{"bug_id": "Jsoup-20", "buggy_code": "1     static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n2         String docData;\n3         Document doc = null;\n4         if (charsetName == null) { \n5             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n6             doc = parser.parseInput(docData, baseUri);\n7             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n8             if (meta != null) { \n9                 String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n10                 if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { \n11                     charsetName = foundCharset;\n12                     byteData.rewind();\n13                     docData = Charset.forName(foundCharset).decode(byteData).toString();\n14                     doc = null;\n15                 }\n16             }\n17         } else { \n18             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n19             docData = Charset.forName(charsetName).decode(byteData).toString();\n20         }\n21         if (doc == null) {\n22             doc = parser.parseInput(docData, baseUri);\n23             doc.outputSettings().charset(charsetName);\n24         }\n25         return doc;\n26     }\n", "fixed_code": "    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { \n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { \n                String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { \n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { \n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            if (docData.charAt(0) == 65279)\n                docData = docData.substring(1);\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n"}
{"bug_id": "Cli-9", "buggy_code": "1     protected void checkRequiredOptions()\n2         throws MissingOptionException\n3     {\n4         if (getRequiredOptions().size() > 0)\n5         {\n6             Iterator iter = getRequiredOptions().iterator();\n7             StringBuffer buff = new StringBuffer(\"Missing required option\");\n8             buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n9             buff.append(\": \");\n10             while (iter.hasNext())\n11             {\n12                 buff.append(iter.next());\n13             }\n14             throw new MissingOptionException(buff.toString());\n15         }\n16     }\n", "fixed_code": "    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n                buff.append(\", \");\n            }\n            throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n        }\n    }\n"}
{"bug_id": "Time-25", "buggy_code": "1     public int getOffsetFromLocal(long instantLocal) {\n2         final int offsetLocal = getOffset(instantLocal);\n3         final long instantAdjusted = instantLocal - offsetLocal;\n4         final int offsetAdjusted = getOffset(instantAdjusted);\n5         if (offsetLocal != offsetAdjusted) {\n6             if ((offsetLocal - offsetAdjusted) < 0) {\n7                 long nextLocal = nextTransition(instantAdjusted);\n8                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n9                 if (nextLocal != nextAdjusted) {\n10                     return offsetLocal;\n11                 }\n12             }\n13         }\n14         return offsetAdjusted;\n15     }\n", "fixed_code": "    public int getOffsetFromLocal(long instantLocal) {\n        final int offsetLocal = getOffset(instantLocal);\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        if (offsetLocal != offsetAdjusted) {\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n"}
{"bug_id": "Math-25", "buggy_code": "1         private void guessAOmega() {\n2             double sx2 = 0;\n3             double sy2 = 0;\n4             double sxy = 0;\n5             double sxz = 0;\n6             double syz = 0;\n7             double currentX = observations[0].getX();\n8             double currentY = observations[0].getY();\n9             double f2Integral = 0;\n10             double fPrime2Integral = 0;\n11             final double startX = currentX;\n12             for (int i = 1; i < observations.length; ++i) {\n13                 final double previousX = currentX;\n14                 final double previousY = currentY;\n15                 currentX = observations[i].getX();\n16                 currentY = observations[i].getY();\n17                 final double dx = currentX - previousX;\n18                 final double dy = currentY - previousY;\n19                 final double f2StepIntegral =\n20                     dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n21                 final double fPrime2StepIntegral = dy * dy / dx;\n22                 final double x = currentX - startX;\n23                 f2Integral += f2StepIntegral;\n24                 fPrime2Integral += fPrime2StepIntegral;\n25                 sx2 += x * x;\n26                 sy2 += f2Integral * f2Integral;\n27                 sxy += x * f2Integral;\n28                 sxz += x * fPrime2Integral;\n29                 syz += f2Integral * fPrime2Integral;\n30             }\n31             double c1 = sy2 * sxz - sxy * syz;\n32             double c2 = sxy * sxz - sx2 * syz;\n33             double c3 = sx2 * sy2 - sxy * sxy;\n34             if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n35                 final int last = observations.length - 1;\n36                 final double xRange = observations[last].getX() - observations[0].getX();\n37                 if (xRange == 0) {\n38                     throw new ZeroException();\n39                 }\n40                 omega = 2 * Math.PI / xRange;\n41                 double yMin = Double.POSITIVE_INFINITY;\n42                 double yMax = Double.NEGATIVE_INFINITY;\n43                 for (int i = 1; i < observations.length; ++i) {\n44                     final double y = observations[i].getY();\n45                     if (y < yMin) {\n46                         yMin = y;\n47                     }\n48                     if (y > yMax) {\n49                         yMax = y;\n50                     }\n51                 }\n52                 a = 0.5 * (yMax - yMin);\n53             } else {\n54                 a = FastMath.sqrt(c1 / c2);\n55                 omega = FastMath.sqrt(c2 / c3);\n56             }\n57         }\n", "fixed_code": "        private void guessAOmega() {\n            double sx2 = 0;\n            double sy2 = 0;\n            double sxy = 0;\n            double sxz = 0;\n            double syz = 0;\n            double currentX = observations[0].getX();\n            double currentY = observations[0].getY();\n            double f2Integral = 0;\n            double fPrime2Integral = 0;\n            final double startX = currentX;\n            for (int i = 1; i < observations.length; ++i) {\n                final double previousX = currentX;\n                final double previousY = currentY;\n                currentX = observations[i].getX();\n                currentY = observations[i].getY();\n                final double dx = currentX - previousX;\n                final double dy = currentY - previousY;\n                final double f2StepIntegral =\n                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n                final double fPrime2StepIntegral = dy * dy / dx;\n                final double x = currentX - startX;\n                f2Integral += f2StepIntegral;\n                fPrime2Integral += fPrime2StepIntegral;\n                sx2 += x * x;\n                sy2 += f2Integral * f2Integral;\n                sxy += x * f2Integral;\n                sxz += x * fPrime2Integral;\n                syz += f2Integral * fPrime2Integral;\n            }\n            double c1 = sy2 * sxz - sxy * syz;\n            double c2 = sxy * sxz - sx2 * syz;\n            double c3 = sx2 * sy2 - sxy * sxy;\n            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n                final int last = observations.length - 1;\n                final double xRange = observations[last].getX() - observations[0].getX();\n                if (xRange == 0) {\n                    throw new ZeroException();\n                }\n                omega = 2 * Math.PI / xRange;\n                double yMin = Double.POSITIVE_INFINITY;\n                double yMax = Double.NEGATIVE_INFINITY;\n                for (int i = 1; i < observations.length; ++i) {\n                    final double y = observations[i].getY();\n                    if (y < yMin) {\n                        yMin = y;\n                    }\n                    if (y > yMax) {\n                        yMax = y;\n                    }\n                }\n                a = 0.5 * (yMax - yMin);\n            } else {\n                if (c2 == 0) {\n                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n                }\n                a = FastMath.sqrt(c1 / c2);\n                omega = FastMath.sqrt(c2 / c3);\n            }\n        }\n"}
{"bug_id": "Mockito-27", "buggy_code": "1     public <T> void resetMock(T mock) {\n2         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n3         MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n4         MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n5         ((Factory) mock).setCallback(0, newFilter);\n6     }\n", "fixed_code": "    public <T> void resetMock(T mock) {\n        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\n        ((Factory) mock).setCallback(0, newFilter);\n    }\n"}
{"bug_id": "JacksonDatabind-7", "buggy_code": "1     public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n2     {\n3             copyCurrentStructure(jp);\n4         return this;\n5     }\n", "fixed_code": "    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n            copyCurrentStructure(jp);\n            return this;\n        }\n        JsonToken t;\n        writeStartObject();\n        do {\n            copyCurrentStructure(jp);\n        } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME);\n        if (t != JsonToken.END_OBJECT) {\n            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n        }\n        writeEndObject();\n        return this;\n    }\n"}
{"bug_id": "Jsoup-57", "buggy_code": "1     public void removeIgnoreCase(String key) {\n2         Validate.notEmpty(key);\n3         if (attributes == null)\n4             return;\n5         for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n6             String attrKey = it.next();\n7             if (attrKey.equalsIgnoreCase(key))\n8                 attributes.remove(attrKey);\n9         }\n10     }\n", "fixed_code": "    public void removeIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n            String attrKey = it.next();\n            if (attrKey.equalsIgnoreCase(key))\n                it.remove();\n        }\n    }\n"}
{"bug_id": "Lang-27", "buggy_code": "1     public static Number createNumber(String str) throws NumberFormatException {\n2         if (str == null) {\n3             return null;\n4         }\n5         if (StringUtils.isBlank(str)) {\n6             throw new NumberFormatException(\"A blank string is not a valid number\");\n7         }  \n8         if (str.startsWith(\"--\")) {\n9             return null;\n10         }\n11         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n12             return createInteger(str);\n13         }   \n14         char lastChar = str.charAt(str.length() - 1);\n15         String mant;\n16         String dec;\n17         String exp;\n18         int decPos = str.indexOf('.');\n19         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n20         if (decPos > -1) {\n21             if (expPos > -1) {\n22                 if (expPos < decPos) {\n23                     throw new NumberFormatException(str + \" is not a valid number.\");\n24                 }\n25                 dec = str.substring(decPos + 1, expPos);\n26             } else {\n27                 dec = str.substring(decPos + 1);\n28             }\n29             mant = str.substring(0, decPos);\n30         } else {\n31             if (expPos > -1) {\n32                 mant = str.substring(0, expPos);\n33             } else {\n34                 mant = str;\n35             }\n36             dec = null;\n37         }\n38         if (!Character.isDigit(lastChar) && lastChar != '.') {\n39             if (expPos > -1 && expPos < str.length() - 1) {\n40                 exp = str.substring(expPos + 1, str.length() - 1);\n41             } else {\n42                 exp = null;\n43             }\n44             String numeric = str.substring(0, str.length() - 1);\n45             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n46             switch (lastChar) {\n47                 case 'l' :\n48                 case 'L' :\n49                     if (dec == null\n50                         && exp == null\n51                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n52                         try {\n53                             return createLong(numeric);\n54                         } catch (NumberFormatException nfe) {\n55                         }\n56                         return createBigInteger(numeric);\n57                     }\n58                     throw new NumberFormatException(str + \" is not a valid number.\");\n59                 case 'f' :\n60                 case 'F' :\n61                     try {\n62                         Float f = NumberUtils.createFloat(numeric);\n63                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n64                             return f;\n65                         }\n66                     } catch (NumberFormatException nfe) {\n67                     }\n68                 case 'd' :\n69                 case 'D' :\n70                     try {\n71                         Double d = NumberUtils.createDouble(numeric);\n72                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n73                             return d;\n74                         }\n75                     } catch (NumberFormatException nfe) {\n76                     }\n77                     try {\n78                         return createBigDecimal(numeric);\n79                     } catch (NumberFormatException e) {\n80                     }\n81                 default :\n82                     throw new NumberFormatException(str + \" is not a valid number.\");\n83             }\n84         } else {\n85             if (expPos > -1 && expPos < str.length() - 1) {\n86                 exp = str.substring(expPos + 1, str.length());\n87             } else {\n88                 exp = null;\n89             }\n90             if (dec == null && exp == null) {\n91                 try {\n92                     return createInteger(str);\n93                 } catch (NumberFormatException nfe) {\n94                 }\n95                 try {\n96                     return createLong(str);\n97                 } catch (NumberFormatException nfe) {\n98                 }\n99                 return createBigInteger(str);\n100             } else {\n101                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n102                 try {\n103                     Float f = createFloat(str);\n104                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n105                         return f;\n106                     }\n107                 } catch (NumberFormatException nfe) {\n108                 }\n109                 try {\n110                     Double d = createDouble(str);\n111                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n112                         return d;\n113                     }\n114                 } catch (NumberFormatException nfe) {\n115                 }\n116                 return createBigDecimal(str);\n117             }\n118         }\n119     }\n", "fixed_code": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n        if (decPos > -1) {\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                        }\n                        return createBigInteger(numeric);\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                    }\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        } else {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigInteger(str);\n            } else {\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigDecimal(str);\n            }\n        }\n    }\n"}
{"bug_id": "Lang-22", "buggy_code": "1     private static int greatestCommonDivisor(int u, int v) {\n2         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n3             return 1;\n4         }\n5         if (u>0) { u=-u; } \n6         if (v>0) { v=-v; } \n7         int k=0;\n8         while ((u&1)==0 && (v&1)==0 && k<31) { \n9             u/=2; v/=2; k++; \n10         }\n11         if (k==31) {\n12             throw new ArithmeticException(\"overflow: gcd is 2^31\");\n13         }\n14         int t = ((u&1)==1) ? v : -(u/2);\n15         do {\n16             while ((t&1)==0) { \n17                 t/=2; \n18             }\n19             if (t>0) {\n20                 u = -t;\n21             } else {\n22                 v = t;\n23             }\n24             t = (v - u)/2;\n25         } while (t!=0);\n26         return -u*(1<<k); \n27     }\n", "fixed_code": "    private static int greatestCommonDivisor(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            return Math.abs(u) + Math.abs(v);\n        }\n        if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n            return 1;\n        }\n        if (u>0) { u=-u; } \n        if (v>0) { v=-v; } \n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { \n            u/=2; v/=2; k++; \n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        int t = ((u&1)==1) ? v : -(u/2);\n        do {\n            while ((t&1)==0) { \n                t/=2; \n            }\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            t = (v - u)/2;\n        } while (t!=0);\n        return -u*(1<<k); \n    }\n"}
{"bug_id": "Cli-5", "buggy_code": "1     static String stripLeadingHyphens(String str)\n2     {\n3         if (str.startsWith(\"--\"))\n4         {\n5             return str.substring(2, str.length());\n6         }\n7         else if (str.startsWith(\"-\"))\n8         {\n9             return str.substring(1, str.length());\n10         }\n11         return str;\n12     }\n", "fixed_code": "    static String stripLeadingHyphens(String str)\n    {\n        if (str == null) {\n            return null;\n        }\n        if (str.startsWith(\"--\"))\n        {\n            return str.substring(2, str.length());\n        }\n        else if (str.startsWith(\"-\"))\n        {\n            return str.substring(1, str.length());\n        }\n        return str;\n    }\n"}
{"bug_id": "Codec-6", "buggy_code": "1     public int read(byte b[], int offset, int len) throws IOException {\n2         if (b == null) {\n3             throw new NullPointerException();\n4         } else if (offset < 0 || len < 0) {\n5             throw new IndexOutOfBoundsException();\n6         } else if (offset > b.length || offset + len > b.length) {\n7             throw new IndexOutOfBoundsException();\n8         } else if (len == 0) {\n9             return 0;\n10         } else {\n11                 if (!base64.hasData()) {\n12                     byte[] buf = new byte[doEncode ? 4096 : 8192];\n13                     int c = in.read(buf);\n14                     if (c > 0 && b.length == len) {\n15                         base64.setInitialBuffer(b, offset, len);\n16                     }\n17                     if (doEncode) {\n18                         base64.encode(buf, 0, c);\n19                     } else {\n20                         base64.decode(buf, 0, c);\n21                     }\n22                 }\n23             return base64.readResults(b, offset, len);\n24         }\n25     }\n", "fixed_code": "    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n"}
{"bug_id": "Math-50", "buggy_code": "1     protected final double doSolve() {\n2         double x0 = getMin();\n3         double x1 = getMax();\n4         double f0 = computeObjectiveValue(x0);\n5         double f1 = computeObjectiveValue(x1);\n6         if (f0 == 0.0) {\n7             return x0;\n8         }\n9         if (f1 == 0.0) {\n10             return x1;\n11         }\n12         verifyBracketing(x0, x1);\n13         final double ftol = getFunctionValueAccuracy();\n14         final double atol = getAbsoluteAccuracy();\n15         final double rtol = getRelativeAccuracy();\n16         boolean inverted = false;\n17         while (true) {\n18             final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n19             final double fx = computeObjectiveValue(x);\n20             if (fx == 0.0) {\n21                 return x;\n22             }\n23             if (f1 * fx < 0) {\n24                 x0 = x1;\n25                 f0 = f1;\n26                 inverted = !inverted;\n27             } else {\n28                 switch (method) {\n29                 case ILLINOIS:\n30                     f0 *= 0.5;\n31                     break;\n32                 case PEGASUS:\n33                     f0 *= f1 / (f1 + fx);\n34                     break;\n35                 case REGULA_FALSI:\n36                     if (x == x1) {\n37                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n38                         f0 = computeObjectiveValue(x0);\n39                     }\n40                     break;\n41                 default:\n42                     throw new MathInternalError();\n43                 }\n44             }\n45             x1 = x;\n46             f1 = fx;\n47             if (FastMath.abs(f1) <= ftol) {\n48                 switch (allowed) {\n49                 case ANY_SIDE:\n50                     return x1;\n51                 case LEFT_SIDE:\n52                     if (inverted) {\n53                         return x1;\n54                     }\n55                     break;\n56                 case RIGHT_SIDE:\n57                     if (!inverted) {\n58                         return x1;\n59                     }\n60                     break;\n61                 case BELOW_SIDE:\n62                     if (f1 <= 0) {\n63                         return x1;\n64                     }\n65                     break;\n66                 case ABOVE_SIDE:\n67                     if (f1 >= 0) {\n68                         return x1;\n69                     }\n70                     break;\n71                 default:\n72                     throw new MathInternalError();\n73                 }\n74             }\n75             if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n76                                                      atol)) {\n77                 switch (allowed) {\n78                 case ANY_SIDE:\n79                     return x1;\n80                 case LEFT_SIDE:\n81                     return inverted ? x1 : x0;\n82                 case RIGHT_SIDE:\n83                     return inverted ? x0 : x1;\n84                 case BELOW_SIDE:\n85                     return (f1 <= 0) ? x1 : x0;\n86                 case ABOVE_SIDE:\n87                     return (f1 >= 0) ? x1 : x0;\n88                 default:\n89                     throw new MathInternalError();\n90                 }\n91             }\n92         }\n93     }\n", "fixed_code": "    protected final double doSolve() {\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n        boolean inverted = false;\n        while (true) {\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n            if (fx == 0.0) {\n                return x;\n            }\n            if (f1 * fx < 0) {\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            x1 = x;\n            f1 = fx;\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"}
{"bug_id": "Math-39", "buggy_code": "1   public void integrate(final ExpandableStatefulODE equations, final double t)\n2       throws MathIllegalStateException, MathIllegalArgumentException {\n3     sanityChecks(equations, t);\n4     setEquations(equations);\n5     final boolean forward = t > equations.getTime();\n6     final double[] y0  = equations.getCompleteState();\n7     final double[] y = y0.clone();\n8     final int stages = c.length + 1;\n9     final double[][] yDotK = new double[stages][y.length];\n10     final double[] yTmp    = y0.clone();\n11     final double[] yDotTmp = new double[y.length];\n12     final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n13     interpolator.reinitialize(this, yTmp, yDotK, forward,\n14                               equations.getPrimaryMapper(), equations.getSecondaryMappers());\n15     interpolator.storeTime(equations.getTime());\n16     stepStart         = equations.getTime();\n17     double  hNew      = 0;\n18     boolean firstTime = true;\n19     initIntegration(equations.getTime(), y0, t);\n20     isLastStep = false;\n21     do {\n22       interpolator.shift();\n23       double error = 10;\n24       while (error >= 1.0) {\n25         if (firstTime || !fsal) {\n26           computeDerivatives(stepStart, y, yDotK[0]);\n27         }\n28         if (firstTime) {\n29           final double[] scale = new double[mainSetDimension];\n30           if (vecAbsoluteTolerance == null) {\n31               for (int i = 0; i < scale.length; ++i) {\n32                 scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n33               }\n34           } else {\n35               for (int i = 0; i < scale.length; ++i) {\n36                 scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n37               }\n38           }\n39           hNew = initializeStep(forward, getOrder(), scale,\n40                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n41           firstTime = false;\n42         }\n43         stepSize = hNew;\n44         for (int k = 1; k < stages; ++k) {\n45           for (int j = 0; j < y0.length; ++j) {\n46             double sum = a[k-1][0] * yDotK[0][j];\n47             for (int l = 1; l < k; ++l) {\n48               sum += a[k-1][l] * yDotK[l][j];\n49             }\n50             yTmp[j] = y[j] + stepSize * sum;\n51           }\n52           computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n53         }\n54         for (int j = 0; j < y0.length; ++j) {\n55           double sum    = b[0] * yDotK[0][j];\n56           for (int l = 1; l < stages; ++l) {\n57             sum    += b[l] * yDotK[l][j];\n58           }\n59           yTmp[j] = y[j] + stepSize * sum;\n60         }\n61         error = estimateError(yDotK, y, yTmp, stepSize);\n62         if (error >= 1.0) {\n63           final double factor =\n64               FastMath.min(maxGrowth,\n65                            FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n66           hNew = filterStep(stepSize * factor, forward, false);\n67         }\n68       }\n69       interpolator.storeTime(stepStart + stepSize);\n70       System.arraycopy(yTmp, 0, y, 0, y0.length);\n71       System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n72       stepStart = acceptStep(interpolator, y, yDotTmp, t);\n73       System.arraycopy(y, 0, yTmp, 0, y.length);\n74       if (!isLastStep) {\n75           interpolator.storeTime(stepStart);\n76           if (fsal) {\n77               System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n78           }\n79           final double factor =\n80               FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n81           final double  scaledH    = stepSize * factor;\n82           final double  nextT      = stepStart + scaledH;\n83           final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n84           hNew = filterStep(scaledH, forward, nextIsLast);\n85           final double  filteredNextT      = stepStart + hNew;\n86           final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n87           if (filteredNextIsLast) {\n88               hNew = t - stepStart;\n89           }\n90       }\n91     } while (!isLastStep);\n92     equations.setTime(stepStart);\n93     equations.setCompleteState(y);\n94     resetInternalState();\n95   }\n", "fixed_code": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n    final double[] y0  = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n    stepStart         = equations.getTime();\n    double  hNew      = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n    isLastStep = false;\n    do {\n      interpolator.shift();\n      double error = 10;\n      while (error >= 1.0) {\n        if (firstTime || !fsal) {\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n        if (firstTime) {\n          final double[] scale = new double[mainSetDimension];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n              }\n          } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n              }\n          }\n          hNew = initializeStep(forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n        stepSize = hNew;\n        if (forward) {\n            if (stepStart + stepSize >= t) {\n                stepSize = t - stepStart;\n            }\n        } else {\n            if (stepStart + stepSize <= t) {\n                stepSize = t - stepStart;\n            }\n        }\n        for (int k = 1; k < stages; ++k) {\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n        }\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error >= 1.0) {\n          final double factor =\n              FastMath.min(maxGrowth,\n                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n      }\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n      System.arraycopy(y, 0, yTmp, 0, y.length);\n      if (!isLastStep) {\n          interpolator.storeTime(stepStart);\n          if (fsal) {\n              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n          }\n          final double factor =\n              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          final double  scaledH    = stepSize * factor;\n          final double  nextT      = stepStart + scaledH;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n          hNew = filterStep(scaledH, forward, nextIsLast);\n          final double  filteredNextT      = stepStart + hNew;\n          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n          if (filteredNextIsLast) {\n              hNew = t - stepStart;\n          }\n      }\n    } while (!isLastStep);\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n    resetInternalState();\n  }\n"}
{"bug_id": "JacksonDatabind-5", "buggy_code": "1     protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n2             Class<?> mixInCls, AnnotatedMethodMap mixIns)\n3     {\n4         List<Class<?>> parents = new ArrayList<Class<?>>();\n5         parents.add(mixInCls);\n6         ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n7         for (Class<?> mixin : parents) {\n8             for (Method m : mixin.getDeclaredMethods()) {\n9                 if (!_isIncludableMemberMethod(m)) {\n10                     continue;\n11                 }\n12                 AnnotatedMethod am = methods.find(m);\n13                 if (am != null) {\n14                     _addMixUnders(m, am);\n15                 } else {\n16                         mixIns.add(_constructMethod(m));\n17                 }\n18             }\n19         }\n20     }\n", "fixed_code": "    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                if (am != null) {\n                    _addMixUnders(m, am);\n                } else {\n                    am = mixIns.find(m);\n                    if (am != null) {\n                        _addMixUnders(m, am);\n                    } else {\n                        mixIns.add(_constructMethod(m));\n                    }\n                }\n            }\n        }\n    }\n"}
{"bug_id": "Closure-69", "buggy_code": "1   private void visitCall(NodeTraversal t, Node n) {\n2     Node child = n.getFirstChild();\n3     JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n4     if (!childType.canBeCalled()) {\n5       report(t, n, NOT_CALLABLE, childType.toString());\n6       ensureTyped(t, n);\n7       return;\n8     }\n9     if (childType instanceof FunctionType) {\n10       FunctionType functionType = (FunctionType) childType;\n11       boolean isExtern = false;\n12       JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n13       if(functionJSDocInfo != null) {\n14         String sourceName = functionJSDocInfo.getSourceName();\n15         CompilerInput functionSource = compiler.getInput(sourceName);\n16         isExtern = functionSource.isExtern();\n17       }\n18       if (functionType.isConstructor() &&\n19           !functionType.isNativeObjectType() &&\n20           (functionType.getReturnType().isUnknownType() ||\n21            functionType.getReturnType().isVoidType() ||\n22            !isExtern)) {\n23         report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n24       }\n25       visitParameterList(t, n, functionType);\n26       ensureTyped(t, n, functionType.getReturnType());\n27     } else {\n28       ensureTyped(t, n);\n29     }\n30   }\n", "fixed_code": "  private void visitCall(NodeTraversal t, Node n) {\n    Node child = n.getFirstChild();\n    JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n    if (!childType.canBeCalled()) {\n      report(t, n, NOT_CALLABLE, childType.toString());\n      ensureTyped(t, n);\n      return;\n    }\n    if (childType instanceof FunctionType) {\n      FunctionType functionType = (FunctionType) childType;\n      boolean isExtern = false;\n      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n      if(functionJSDocInfo != null) {\n        String sourceName = functionJSDocInfo.getSourceName();\n        CompilerInput functionSource = compiler.getInput(sourceName);\n        isExtern = functionSource.isExtern();\n      }\n      if (functionType.isConstructor() &&\n          !functionType.isNativeObjectType() &&\n          (functionType.getReturnType().isUnknownType() ||\n           functionType.getReturnType().isVoidType() ||\n           !isExtern)) {\n        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n      }\n      if (functionType.isOrdinaryFunction() &&\n          !functionType.getTypeOfThis().isUnknownType() &&\n          !functionType.getTypeOfThis().isNativeObjectType() &&\n          !(child.getType() == Token.GETELEM ||\n            child.getType() == Token.GETPROP)) {\n        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n      }\n      visitParameterList(t, n, functionType);\n      ensureTyped(t, n, functionType.getReturnType());\n    } else {\n      ensureTyped(t, n);\n    }\n  }\n"}
{"bug_id": "Jsoup-27", "buggy_code": "1     static String getCharsetFromContentType(String contentType) {\n2         if (contentType == null) return null;\n3         Matcher m = charsetPattern.matcher(contentType);\n4         if (m.find()) {\n5             String charset = m.group(1).trim();\n6             charset = charset.toUpperCase(Locale.ENGLISH);\n7             return charset;\n8         }\n9         return null;\n10     }\n", "fixed_code": "    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            if (Charset.isSupported(charset)) return charset;\n            charset = charset.toUpperCase(Locale.ENGLISH);\n            if (Charset.isSupported(charset)) return charset;\n        }\n        return null;\n    }\n"}
{"bug_id": "Gson-6", "buggy_code": "1   static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n2       TypeToken<?> fieldType, JsonAdapter annotation) {\n3     Class<?> value = annotation.value();\n4     TypeAdapter<?> typeAdapter;\n5     if (TypeAdapter.class.isAssignableFrom(value)) {\n6       Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n7       typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n8     } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n9       Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n10       typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n11           .construct()\n12           .create(gson, fieldType);\n13     } else {\n14       throw new IllegalArgumentException(\n15           \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n16     }\n17       typeAdapter = typeAdapter.nullSafe();\n18     return typeAdapter;\n19   }\n", "fixed_code": "  static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> fieldType, JsonAdapter annotation) {\n    Class<?> value = annotation.value();\n    TypeAdapter<?> typeAdapter;\n    if (TypeAdapter.class.isAssignableFrom(value)) {\n      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n          .construct()\n          .create(gson, fieldType);\n    } else {\n      throw new IllegalArgumentException(\n          \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n    }\n    if (typeAdapter != null) {\n      typeAdapter = typeAdapter.nullSafe();\n    }\n    return typeAdapter;\n  }\n"}
{"bug_id": "Lang-38", "buggy_code": "1     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n2         if (mTimeZoneForced) {\n3             calendar = (Calendar) calendar.clone();\n4             calendar.setTimeZone(mTimeZone);\n5         }\n6         return applyRules(calendar, buf);\n7     }\n", "fixed_code": "    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n        if (mTimeZoneForced) {\n            calendar.getTime(); \n            calendar = (Calendar) calendar.clone();\n            calendar.setTimeZone(mTimeZone);\n        }\n        return applyRules(calendar, buf);\n    }\n"}
{"bug_id": "Mockito-38", "buggy_code": "1     private boolean toStringEquals(Matcher m, Object arg) {\n2         return StringDescription.toString(m).equals(arg.toString());\n3     }\n", "fixed_code": "    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\n    }\n"}
{"bug_id": "JacksonXml-4", "buggy_code": "1     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n2     {\n3         if (jgen instanceof ToXmlGenerator) {\n4             _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n5         }\n6         super.serializeValue(jgen, null);\n7     }\n", "fixed_code": "    protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n    {\n        QName rootName = _rootNameFromConfig();\n        if (rootName == null) {\n            rootName = ROOT_NAME_FOR_NULL;\n        }\n        if (jgen instanceof ToXmlGenerator) {\n            _initWithRootName((ToXmlGenerator) jgen, rootName);\n        }\n        super.serializeValue(jgen, null);\n    }\n"}
{"bug_id": "JacksonDatabind-67", "buggy_code": "1     public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n2             JavaType type)\n3         throws JsonMappingException\n4     {\n5         final DeserializationConfig config = ctxt.getConfig();\n6         KeyDeserializer deser = null;\n7         if (_factoryConfig.hasKeyDeserializers()) {\n8             BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n9             for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n10                 deser = d.findKeyDeserializer(type, config, beanDesc);\n11                 if (deser != null) {\n12                     break;\n13                 }\n14             }\n15         }\n16         if (deser == null) {\n17             if (type.isEnumType()) {\n18                 return _createEnumKeyDeserializer(ctxt, type);\n19             }\n20             deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n21         }\n22         if (deser != null) {\n23             if (_factoryConfig.hasDeserializerModifiers()) {\n24                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n25                     deser = mod.modifyKeyDeserializer(config, type, deser);\n26                 }\n27             }\n28         }\n29         return deser;\n30     }\n", "fixed_code": "    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        if (deser == null) {\n            if (type.isEnumType()) {\n                deser = _createEnumKeyDeserializer(ctxt, type);\n            } else {\n                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n            }\n        }\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n"}
{"bug_id": "Closure-13", "buggy_code": "1   private void traverse(Node node) {\n2     if (!shouldVisit(node)) {\n3       return;\n4     }\n5     int visits = 0;\n6     do {\n7       Node c = node.getFirstChild();\n8       while(c != null) {\n9         traverse(c);\n10         Node next = c.getNext();\n11         c = next;\n12       }\n13       visit(node);\n14       visits++;\n15       Preconditions.checkState(visits < 10000, \"too many interations\");\n16     } while (shouldRetraverse(node));\n17     exitNode(node);\n18   }\n", "fixed_code": "  private void traverse(Node node) {\n    if (!shouldVisit(node)) {\n      return;\n    }\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n        Node next = c.getNext();\n        traverse(c);\n        c = next;\n      }\n      visit(node);\n      visits++;\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n    exitNode(node);\n  }\n"}
{"bug_id": "Csv-5", "buggy_code": "1     public void println() throws IOException {\n2         final String recordSeparator = format.getRecordSeparator();\n3             out.append(recordSeparator);\n4         newRecord = true;\n5     }\n", "fixed_code": "    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n"}
{"bug_id": "Csv-6", "buggy_code": "1     <M extends Map<String, String>> M putIn(final M map) {\n2         for (final Entry<String, Integer> entry : mapping.entrySet()) {\n3             final int col = entry.getValue().intValue();\n4                 map.put(entry.getKey(), values[col]);\n5         }\n6         return map;\n7     }\n", "fixed_code": "    <M extends Map<String, String>> M putIn(final M map) {\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n"}
{"bug_id": "Chart-1", "buggy_code": "1     public LegendItemCollection getLegendItems() {\n2         LegendItemCollection result = new LegendItemCollection();\n3         if (this.plot == null) {\n4             return result;\n5         }\n6         int index = this.plot.getIndexOf(this);\n7         CategoryDataset dataset = this.plot.getDataset(index);\n8         if (dataset != null) {\n9             return result;\n10         }\n11         int seriesCount = dataset.getRowCount();\n12         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n13             for (int i = 0; i < seriesCount; i++) {\n14                 if (isSeriesVisibleInLegend(i)) {\n15                     LegendItem item = getLegendItem(index, i);\n16                     if (item != null) {\n17                         result.add(item);\n18                     }\n19                 }\n20             }\n21         }\n22         else {\n23             for (int i = seriesCount - 1; i >= 0; i--) {\n24                 if (isSeriesVisibleInLegend(i)) {\n25                     LegendItem item = getLegendItem(index, i);\n26                     if (item != null) {\n27                         result.add(item);\n28                     }\n29                 }\n30             }\n31         }\n32         return result;\n33     }\n", "fixed_code": "    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset == null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n"}
{"bug_id": "Math-97", "buggy_code": "1     public double solve(double min, double max) throws MaxIterationsExceededException, \n2         FunctionEvaluationException {\n3         clearResult();\n4         verifyInterval(min, max);\n5         double ret = Double.NaN;\n6         double yMin = f.value(min);\n7         double yMax = f.value(max);\n8         double sign = yMin * yMax;\n9         if (sign >= 0) {\n10                 throw new IllegalArgumentException\n11                 (\"Function values at endpoints do not have different signs.\" +\n12                         \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n13                         \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n14         } else {\n15             ret = solve(min, yMin, max, yMax, min, yMin);\n16         }\n17         return ret;\n18     }\n", "fixed_code": "    public double solve(double min, double max) throws MaxIterationsExceededException, \n        FunctionEvaluationException {\n        clearResult();\n        verifyInterval(min, max);\n        double ret = Double.NaN;\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        double sign = yMin * yMax;\n        if (sign > 0) {\n            if (Math.abs(yMin) <= functionValueAccuracy) {\n                setResult(min, 0);\n                ret = min;\n            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n                setResult(max, 0);\n                ret = max;\n            } else {\n                throw new IllegalArgumentException\n                (\"Function values at endpoints do not have different signs.\" +\n                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n            }\n        } else if (sign < 0){\n            ret = solve(min, yMin, max, yMax, min, yMin);\n        } else {\n            if (yMin == 0.0) {\n                ret = min;\n            } else {\n                ret = max;\n            }\n        }\n        return ret;\n    }\n"}
{"bug_id": "Math-10", "buggy_code": "1     public void atan2(final double[] y, final int yOffset,\n2                       final double[] x, final int xOffset,\n3                       final double[] result, final int resultOffset) {\n4         double[] tmp1 = new double[getSize()];\n5         multiply(x, xOffset, x, xOffset, tmp1, 0);      \n6         double[] tmp2 = new double[getSize()];\n7         multiply(y, yOffset, y, yOffset, tmp2, 0);      \n8         add(tmp1, 0, tmp2, 0, tmp2, 0);                 \n9         rootN(tmp2, 0, 2, tmp1, 0);                     \n10         if (x[xOffset] >= 0) {\n11             add(tmp1, 0, x, xOffset, tmp2, 0);          \n12             divide(y, yOffset, tmp2, 0, tmp1, 0);       \n13             atan(tmp1, 0, tmp2, 0);                     \n14             for (int i = 0; i < tmp2.length; ++i) {\n15                 result[resultOffset + i] = 2 * tmp2[i]; \n16             }\n17         } else {\n18             subtract(tmp1, 0, x, xOffset, tmp2, 0);     \n19             divide(y, yOffset, tmp2, 0, tmp1, 0);       \n20             atan(tmp1, 0, tmp2, 0);                     \n21             result[resultOffset] =\n22                     ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; \n23             for (int i = 1; i < tmp2.length; ++i) {\n24                 result[resultOffset + i] = -2 * tmp2[i]; \n25             }\n26         }\n27     }\n", "fixed_code": "    public void atan2(final double[] y, final int yOffset,\n                      final double[] x, final int xOffset,\n                      final double[] result, final int resultOffset) {\n        double[] tmp1 = new double[getSize()];\n        multiply(x, xOffset, x, xOffset, tmp1, 0);      \n        double[] tmp2 = new double[getSize()];\n        multiply(y, yOffset, y, yOffset, tmp2, 0);      \n        add(tmp1, 0, tmp2, 0, tmp2, 0);                 \n        rootN(tmp2, 0, 2, tmp1, 0);                     \n        if (x[xOffset] >= 0) {\n            add(tmp1, 0, x, xOffset, tmp2, 0);          \n            divide(y, yOffset, tmp2, 0, tmp1, 0);       \n            atan(tmp1, 0, tmp2, 0);                     \n            for (int i = 0; i < tmp2.length; ++i) {\n                result[resultOffset + i] = 2 * tmp2[i]; \n            }\n        } else {\n            subtract(tmp1, 0, x, xOffset, tmp2, 0);     \n            divide(y, yOffset, tmp2, 0, tmp1, 0);       \n            atan(tmp1, 0, tmp2, 0);                     \n            result[resultOffset] =\n                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; \n            for (int i = 1; i < tmp2.length; ++i) {\n                result[resultOffset + i] = -2 * tmp2[i]; \n            }\n        }\n        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n    }\n"}
{"bug_id": "Cli-14", "buggy_code": "1     public void validate(final WriteableCommandLine commandLine)\n2         throws OptionException {\n3         int present = 0;\n4         Option unexpected = null;\n5         for (final Iterator i = options.iterator(); i.hasNext();) {\n6             final Option option = (Option) i.next();\n7             boolean validate = option.isRequired() || option instanceof Group;\n8             if (validate) {\n9                 option.validate(commandLine);\n10             }\n11             if (commandLine.hasOption(option)) {\n12                 if (++present > maximum) {\n13                     unexpected = option;\n14                     break;\n15                 }\n16                 option.validate(commandLine);\n17             }\n18         }\n19         if (unexpected != null) {\n20             throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n21                                       unexpected.getPreferredName());\n22         }\n23         if (present < minimum) {\n24             throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n25         }\n26         for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n27             final Option option = (Option) i.next();\n28             option.validate(commandLine);\n29         }\n30     }\n", "fixed_code": "    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        int present = 0;\n        Option unexpected = null;\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            boolean validate = option.isRequired() || option instanceof Group;\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n                    break;\n                }\n                validate = true;\n            }\n            if (validate) {\n                option.validate(commandLine);\n            }\n        }\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }\n"}
{"bug_id": "JxPath-21", "buggy_code": "1     public int getLength() {\n2         return ValueUtils.getLength(getBaseValue());\n3     }\n", "fixed_code": "    public int getLength() {\n        Object baseValue = getBaseValue();\n        return baseValue == null ? 1 : ValueUtils.getLength(baseValue);\n    }\n"}
{"bug_id": "Jsoup-72", "buggy_code": "1     private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n2         if (count > maxStringCacheLen)\n3             return new String(charBuf, start, count);\n4         int hash = 0;\n5         int offset = start;\n6         for (int i = 0; i < count; i++) {\n7             hash = 31 * hash + charBuf[offset++];\n8         }\n9         final int index = hash & stringCache.length - 1;\n10         String cached = stringCache[index];\n11         if (cached == null) { \n12             cached = new String(charBuf, start, count);\n13             stringCache[index] = cached;\n14         } else { \n15             if (rangeEquals(charBuf, start, count, cached)) { \n16                 return cached;\n17             } else { \n18                 cached = new String(charBuf, start, count);\n19                 stringCache[index] = cached; \n20             }\n21         }\n22         return cached;\n23     }\n", "fixed_code": "    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n        if (cached == null) { \n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { \n            if (rangeEquals(charBuf, start, count, cached)) { \n                return cached;\n            } else { \n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; \n            }\n        }\n        return cached;\n    }\n"}
{"bug_id": "Closure-48", "buggy_code": "1     void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n2         Node n, Node parent, Node rhsValue) {\n3       Node ownerNode = n.getFirstChild();\n4       String ownerName = ownerNode.getQualifiedName();\n5       String qName = n.getQualifiedName();\n6       String propName = n.getLastChild().getString();\n7       Preconditions.checkArgument(qName != null && ownerName != null);\n8       JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n9       if (valueType == null && rhsValue != null) {\n10         valueType = rhsValue.getJSType();\n11       }\n12       if (\"prototype\".equals(propName)) {\n13         Var qVar = scope.getVar(qName);\n14         if (qVar != null) {\n15           ObjectType qVarType = ObjectType.cast(qVar.getType());\n16           if (qVarType != null &&\n17               rhsValue != null &&\n18               rhsValue.isObjectLit()) {\n19             typeRegistry.resetImplicitPrototype(\n20                 rhsValue.getJSType(), qVarType.getImplicitPrototype());\n21           } else if (!qVar.isTypeInferred()) {\n22             return;\n23           }\n24           if (qVar.getScope() == scope) {\n25             scope.undeclare(qVar);\n26           }\n27         }\n28       }\n29       if (valueType == null) {\n30         if (parent.isExprResult()) {\n31           stubDeclarations.add(new StubDeclaration(\n32               n,\n33               t.getInput() != null && t.getInput().isExtern(),\n34               ownerName));\n35         }\n36         return;\n37       }\n38       boolean inferred = true;\n39       if (info != null) {\n40         inferred = !(info.hasType()\n41             || info.hasEnumParameterType()\n42             || (info.isConstant() && valueType != null\n43                 && !valueType.isUnknownType())\n44             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n45       }\n46       if (inferred) {\n47         inferred = !(rhsValue != null &&\n48             rhsValue.isFunction() &&\n49             (info != null || !scope.isDeclared(qName, false)));\n50       }\n51       if (!inferred) {\n52         ObjectType ownerType = getObjectSlot(ownerName);\n53         if (ownerType != null) {\n54           boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n55           if ((!ownerType.hasOwnProperty(propName) ||\n56                ownerType.isPropertyTypeInferred(propName)) &&\n57               ((isExtern && !ownerType.isNativeObjectType()) ||\n58                !ownerType.isInstanceType())) {\n59             ownerType.defineDeclaredProperty(propName, valueType, n);\n60           }\n61         }\n62         defineSlot(n, parent, valueType, inferred);\n63       } else if (rhsValue != null && rhsValue.isTrue()) {\n64         FunctionType ownerType =\n65             JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n66         if (ownerType != null) {\n67           JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n68           String delegateName = codingConvention.getDelegateSuperclassName();\n69           JSType delegateType = delegateName == null ?\n70               null : typeRegistry.getType(delegateName);\n71           if (delegateType != null &&\n72               ownerTypeOfThis.isSubtype(delegateType)) {\n73             defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n74           }\n75         }\n76       }\n77     }\n", "fixed_code": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          inferred = false;\n        } else if (!scope.isDeclared(qName, false) &&\n                   n.isUnscopedQualifiedName()) {\n          inferred = false;\n        }\n      }\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n"}
{"bug_id": "JacksonDatabind-54", "buggy_code": "1     protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n2             BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n3             TypeSerializer typeSer, TypeSerializer contentTypeSer,\n4             AnnotatedMember am, boolean defaultUseStaticTyping)\n5         throws JsonMappingException\n6     {\n7         JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n8         if (contentTypeSer != null) {\n9             if (serializationType == null) {\n10                 serializationType = declaredType;\n11             }\n12             JavaType ct = serializationType.getContentType();\n13             if (ct == null) {\n14                 throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n15                         +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n16             }\n17             serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n18             ct = serializationType.getContentType();\n19         }\n20         Object valueToSuppress = null;\n21         boolean suppressNulls = false;\n22         JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n23         JsonInclude.Include inclusion = inclV.getValueInclusion();\n24         if (inclusion == JsonInclude.Include.USE_DEFAULTS) { \n25             inclusion = JsonInclude.Include.ALWAYS;\n26         }\n27         JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n28         switch (inclusion) {\n29         case NON_DEFAULT:\n30             if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n31                 valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n32             } else {\n33                 valueToSuppress = getDefaultValue(actualType);\n34             }\n35             if (valueToSuppress == null) {\n36                 suppressNulls = true;\n37             } else {\n38                 if (valueToSuppress.getClass().isArray()) {\n39                     valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n40                 }\n41             }\n42             break;\n43         case NON_ABSENT: \n44             suppressNulls = true;\n45             if (declaredType.isReferenceType()) {\n46                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n47             }\n48             break;\n49         case NON_EMPTY:\n50             suppressNulls = true;\n51             valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n52             break;\n53         case NON_NULL:\n54             suppressNulls = true;\n55         case ALWAYS: \n56         default:\n57             if (declaredType.isContainerType()\n58                     && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n59                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n60             }\n61             break;\n62         }\n63         BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n64                 am, _beanDesc.getClassAnnotations(), declaredType,\n65                 ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n66         Object serDef = _annotationIntrospector.findNullSerializer(am);\n67         if (serDef != null) {\n68             bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n69         }\n70         NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n71         if (unwrapper != null) {\n72             bpw = bpw.unwrappingWriter(unwrapper);\n73         }\n74         return bpw;\n75     }\n", "fixed_code": "    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        if (contentTypeSer != null) {\n            if (serializationType == null) {\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            if (ct == null) {\n                throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                        +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n        JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { \n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        switch (inclusion) {\n        case NON_DEFAULT:\n            if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n            } else {\n                valueToSuppress = getDefaultValue(actualType);\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case NON_ABSENT: \n            suppressNulls = true;\n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            suppressNulls = true;\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n        case ALWAYS: \n        default:\n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }\n"}
{"bug_id": "Lang-9", "buggy_code": "1     private void init() {\n2         thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n3         nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n4         StringBuilder regex= new StringBuilder();\n5         List<Strategy> collector = new ArrayList<Strategy>();\n6         Matcher patternMatcher= formatPattern.matcher(pattern);\n7         if(!patternMatcher.lookingAt()) {\n8             throw new IllegalArgumentException(\"Invalid pattern\");\n9         }\n10         currentFormatField= patternMatcher.group();\n11         Strategy currentStrategy= getStrategy(currentFormatField);\n12         for(;;) {\n13             patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n14             if(!patternMatcher.lookingAt()) {\n15                 nextStrategy = null;\n16                 break;\n17             }\n18             String nextFormatField= patternMatcher.group();\n19             nextStrategy = getStrategy(nextFormatField);\n20             if(currentStrategy.addRegex(this, regex)) {\n21                 collector.add(currentStrategy);\n22             }\n23             currentFormatField= nextFormatField;\n24             currentStrategy= nextStrategy;\n25         }\n26         if(currentStrategy.addRegex(this, regex)) {\n27             collector.add(currentStrategy);\n28         }\n29         currentFormatField= null;\n30         strategies= collector.toArray(new Strategy[collector.size()]);\n31         parsePattern= Pattern.compile(regex.toString());\n32     }\n", "fixed_code": "    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {\n            throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }\n"}
{"bug_id": "Lang-54", "buggy_code": "1     public static Locale toLocale(String str) {\n2         if (str == null) {\n3             return null;\n4         }\n5         int len = str.length();\n6         if (len != 2 && len != 5 && len < 7) {\n7             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n8         }\n9         char ch0 = str.charAt(0);\n10         char ch1 = str.charAt(1);\n11         if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n12             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n13         }\n14         if (len == 2) {\n15             return new Locale(str, \"\");\n16         } else {\n17             if (str.charAt(2) != '_') {\n18                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n19             }\n20             char ch3 = str.charAt(3);\n21             char ch4 = str.charAt(4);\n22             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n23                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n24             }\n25             if (len == 5) {\n26                 return new Locale(str.substring(0, 2), str.substring(3, 5));\n27             } else {\n28                 if (str.charAt(5) != '_') {\n29                     throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n30                 }\n31                 return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n32             }\n33         }\n34     }\n", "fixed_code": "    public static Locale toLocale(String str) {\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len != 2 && len != 5 && len < 7) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch0 = str.charAt(0);\n        char ch1 = str.charAt(1);\n        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 2) {\n            return new Locale(str, \"\");\n        } else {\n            if (str.charAt(2) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            char ch3 = str.charAt(3);\n            if (ch3 == '_') {\n                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n            }\n            char ch4 = str.charAt(4);\n            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 5) {\n                return new Locale(str.substring(0, 2), str.substring(3, 5));\n            } else {\n                if (str.charAt(5) != '_') {\n                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n                }\n                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n            }\n        }\n    }\n"}
{"bug_id": "JacksonDatabind-9", "buggy_code": "1     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n2         String str;\n3         if (value instanceof Date) {\n4             provider.defaultSerializeDateKey((Date) value, jgen);\n5             return;\n6         } else {\n7             str = value.toString();\n8         }\n9         jgen.writeFieldName(str);\n10     }\n", "fixed_code": "    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n        String str;\n        Class<?> cls = value.getClass();\n        if (cls == String.class) {\n            str = (String) value;\n        } else if (Date.class.isAssignableFrom(cls)) {\n            provider.defaultSerializeDateKey((Date) value, jgen);\n            return;\n        } else if (cls == Class.class) {\n            str = ((Class<?>) value).getName();\n        } else {\n            str = value.toString();\n        }\n        jgen.writeFieldName(str);\n    }\n"}
{"bug_id": "Closure-107", "buggy_code": "1   protected CompilerOptions createOptions() {\n2     CompilerOptions options = new CompilerOptions();\n3     if (flags.processJqueryPrimitives) {\n4       options.setCodingConvention(new JqueryCodingConvention());\n5     } else {\n6       options.setCodingConvention(new ClosureCodingConvention());\n7     }\n8     options.setExtraAnnotationNames(flags.extraAnnotationName);\n9     CompilationLevel level = flags.compilationLevel;\n10     level.setOptionsForCompilationLevel(options);\n11     if (flags.debug) {\n12       level.setDebugOptionsForCompilationLevel(options);\n13     }\n14     if (flags.useTypesForOptimization) {\n15       level.setTypeBasedOptimizationOptions(options);\n16     }\n17     if (flags.generateExports) {\n18       options.setGenerateExports(flags.generateExports);\n19     }\n20     WarningLevel wLevel = flags.warningLevel;\n21     wLevel.setOptionsForWarningLevel(options);\n22     for (FormattingOption formattingOption : flags.formatting) {\n23       formattingOption.applyToOptions(options);\n24     }\n25     options.closurePass = flags.processClosurePrimitives;\n26     options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n27         flags.processJqueryPrimitives;\n28     options.angularPass = flags.angularPass;\n29     if (!flags.translationsFile.isEmpty()) {\n30       try {\n31         options.messageBundle = new XtbMessageBundle(\n32             new FileInputStream(flags.translationsFile),\n33             flags.translationsProject);\n34       } catch (IOException e) {\n35         throw new RuntimeException(\"Reading XTB file\", e);\n36       }\n37     } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n38       options.messageBundle = new EmptyMessageBundle();\n39     }\n40     return options;\n41   }\n", "fixed_code": "  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    if (flags.processJqueryPrimitives) {\n      options.setCodingConvention(new JqueryCodingConvention());\n    } else {\n      options.setCodingConvention(new ClosureCodingConvention());\n    }\n    options.setExtraAnnotationNames(flags.extraAnnotationName);\n    CompilationLevel level = flags.compilationLevel;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n    if (flags.useTypesForOptimization) {\n      level.setTypeBasedOptimizationOptions(options);\n    }\n    if (flags.generateExports) {\n      options.setGenerateExports(flags.generateExports);\n    }\n    WarningLevel wLevel = flags.warningLevel;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n    options.closurePass = flags.processClosurePrimitives;\n    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n        flags.processJqueryPrimitives;\n    options.angularPass = flags.angularPass;\n    if (!flags.translationsFile.isEmpty()) {\n      try {\n        options.messageBundle = new XtbMessageBundle(\n            new FileInputStream(flags.translationsFile),\n            flags.translationsProject);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Reading XTB file\", e);\n      }\n    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n      options.messageBundle = new EmptyMessageBundle();\n      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);\n    }\n    return options;\n  }\n"}
{"bug_id": "Closure-1", "buggy_code": "1   private void removeUnreferencedFunctionArgs(Scope fnScope) {\n2     Node function = fnScope.getRootNode();\n3     Preconditions.checkState(function.isFunction());\n4     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n5       return;\n6     }\n7     Node argList = getFunctionArgList(function);\n8     boolean modifyCallers = modifyCallSites\n9         && callSiteOptimizer.canModifyCallers(function);\n10     if (!modifyCallers) {\n11       Node lastArg;\n12       while ((lastArg = argList.getLastChild()) != null) {\n13         Var var = fnScope.getVar(lastArg.getString());\n14         if (!referenced.contains(var)) {\n15           argList.removeChild(lastArg);\n16           compiler.reportCodeChange();\n17         } else {\n18           break;\n19         }\n20       }\n21     } else {\n22       callSiteOptimizer.optimize(fnScope, referenced);\n23     }\n24   }\n", "fixed_code": "  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    if (!removeGlobals) {\n      return;\n    }\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }\n"}
{"bug_id": "Closure-120", "buggy_code": "1     boolean isAssignedOnceInLifetime() {\n2       Reference ref = getOneAndOnlyAssignment();\n3       if (ref == null) {\n4         return false;\n5       }\n6       for (BasicBlock block = ref.getBasicBlock();\n7            block != null; block = block.getParent()) {\n8         if (block.isFunction) {\n9           break;\n10         } else if (block.isLoop) {\n11           return false;\n12         }\n13       }\n14       return true;\n15     }\n", "fixed_code": "    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          if (ref.getSymbol().getScope() != ref.scope) {\n            return false;\n          }\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }\n      return true;\n    }\n"}
{"bug_id": "Compress-28", "buggy_code": "1     public int read(byte[] buf, int offset, int numToRead) throws IOException {\n2     \tint totalRead = 0;\n3         if (hasHitEOF || entryOffset >= entrySize) {\n4             return -1;\n5         }\n6         if (currEntry == null) {\n7             throw new IllegalStateException(\"No current tar entry\");\n8         }\n9         numToRead = Math.min(numToRead, available());\n10         totalRead = is.read(buf, offset, numToRead);\n11         count(totalRead);\n12         if (totalRead == -1) {\n13             hasHitEOF = true;\n14         } else {\n15             entryOffset += totalRead;\n16         }\n17         return totalRead;\n18     }\n", "fixed_code": "    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n    \tint totalRead = 0;\n        if (hasHitEOF || entryOffset >= entrySize) {\n            return -1;\n        }\n        if (currEntry == null) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n        numToRead = Math.min(numToRead, available());\n        totalRead = is.read(buf, offset, numToRead);\n        if (totalRead == -1) {\n            if (numToRead > 0) {\n                throw new IOException(\"Truncated TAR archive\");\n            }\n            hasHitEOF = true;\n        } else {\n            count(totalRead);\n            entryOffset += totalRead;\n        }\n        return totalRead;\n    }\n"}
{"bug_id": "Math-102", "buggy_code": "1     public double chiSquare(double[] expected, long[] observed)\n2         throws IllegalArgumentException {\n3         if ((expected.length < 2) || (expected.length != observed.length)) {\n4             throw new IllegalArgumentException(\n5                     \"observed, expected array lengths incorrect\");\n6         }\n7         if (!isPositive(expected) || !isNonNegative(observed)) {\n8             throw new IllegalArgumentException(\n9                 \"observed counts must be non-negative and expected counts must be postive\");\n10         }\n11         double sumSq = 0.0d;\n12         double dev = 0.0d;\n13         for (int i = 0; i < observed.length; i++) {\n14                 dev = ((double) observed[i] - expected[i]);\n15                 sumSq += dev * dev / expected[i];\n16         }\n17         return sumSq;\n18     }\n", "fixed_code": "    public double chiSquare(double[] expected, long[] observed)\n        throws IllegalArgumentException {\n        if ((expected.length < 2) || (expected.length != observed.length)) {\n            throw new IllegalArgumentException(\n                    \"observed, expected array lengths incorrect\");\n        }\n        if (!isPositive(expected) || !isNonNegative(observed)) {\n            throw new IllegalArgumentException(\n                \"observed counts must be non-negative and expected counts must be postive\");\n        }\n        double sumExpected = 0d;\n        double sumObserved = 0d;\n        for (int i = 0; i < observed.length; i++) {\n            sumExpected += expected[i];\n            sumObserved += observed[i];\n        }\n        double ratio = 1.0d;\n        boolean rescale = false;\n        if (Math.abs(sumExpected - sumObserved) > 10E-6) {\n            ratio = sumObserved / sumExpected;\n            rescale = true;\n        }\n        double sumSq = 0.0d;\n        double dev = 0.0d;\n        for (int i = 0; i < observed.length; i++) {\n            if (rescale) {\n                dev = ((double) observed[i] - ratio * expected[i]);\n                sumSq += dev * dev / (ratio * expected[i]);\n            } else {\n                dev = ((double) observed[i] - expected[i]);\n                sumSq += dev * dev / expected[i];\n            }\n        }\n        return sumSq;\n    }\n"}
{"bug_id": "Closure-82", "buggy_code": "1   public final boolean isEmptyType() {\n2     return isNoType() || isNoObjectType() || isNoResolvedType();\n3   }\n", "fixed_code": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n        (registry.getNativeFunctionType(\n             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n  }\n"}
{"bug_id": "Lang-42", "buggy_code": "1     public void escape(Writer writer, String str) throws IOException {\n2         int len = str.length();\n3         for (int i = 0; i < len; i++) {\n4             char c = str.charAt(i);\n5             String entityName = this.entityName(c);\n6             if (entityName == null) {\n7                 if (c > 0x7F) {\n8                     writer.write(\"&#\");\n9                     writer.write(Integer.toString(c, 10));\n10                     writer.write(';');\n11                 } else {\n12                     writer.write(c);\n13                 }\n14             } else {\n15                 writer.write('&');\n16                 writer.write(entityName);\n17                 writer.write(';');\n18             }\n19         }\n20     }\n", "fixed_code": "    public void escape(Writer writer, String str) throws IOException {\n        int len = str.length();\n        for (int i = 0; i < len; i++) {\n            int c = Character.codePointAt(str, i); \n            String entityName = this.entityName(c);\n            if (entityName == null) {\n                if (c >= 0x010000 && i < len - 1) {\n                    writer.write(\"&#\");\n                    writer.write(Integer.toString(c, 10));\n                    writer.write(';');\n                    i++;\n                } else if (c > 0x7F) { \n                    writer.write(\"&#\");\n                    writer.write(Integer.toString(c, 10));\n                    writer.write(';');\n                } else {\n                    writer.write(c);\n                }\n            } else {\n                writer.write('&');\n                writer.write(entityName);\n                writer.write(';');\n            }\n        }\n    }\n"}
{"bug_id": "Lang-61", "buggy_code": "1     public int indexOf(String str, int startIndex) {\n2         startIndex = (startIndex < 0 ? 0 : startIndex);\n3         if (str == null || startIndex >= size) {\n4             return -1;\n5         }\n6         int strLen = str.length();\n7         if (strLen == 1) {\n8             return indexOf(str.charAt(0), startIndex);\n9         }\n10         if (strLen == 0) {\n11             return startIndex;\n12         }\n13         if (strLen > size) {\n14             return -1;\n15         }\n16         char[] thisBuf = buffer;\n17         int len = thisBuf.length - strLen;\n18         outer:\n19         for (int i = startIndex; i < len; i++) {\n20             for (int j = 0; j < strLen; j++) {\n21                 if (str.charAt(j) != thisBuf[i + j]) {\n22                     continue outer;\n23                 }\n24             }\n25             return i;\n26         }\n27         return -1;\n28     }\n", "fixed_code": "    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        int len = size - strLen + 1;\n        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n"}
{"bug_id": "Closure-33", "buggy_code": "1   public void matchConstraint(ObjectType constraintObj) {\n2     if (constraintObj.isRecordType()) {\n3       for (String prop : constraintObj.getOwnPropertyNames()) {\n4         JSType propType = constraintObj.getPropertyType(prop);\n5         if (!isPropertyTypeDeclared(prop)) {\n6           JSType typeToInfer = propType;\n7           if (!hasProperty(prop)) {\n8             typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n9                 .getLeastSupertype(propType);\n10           }\n11           defineInferredProperty(prop, typeToInfer, null);\n12         }\n13       }\n14     }\n15   }\n", "fixed_code": "  public void matchConstraint(ObjectType constraintObj) {\n    if (hasReferenceName()) {\n      return;\n    }\n    if (constraintObj.isRecordType()) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!hasProperty(prop)) {\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                .getLeastSupertype(propType);\n          }\n          defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n"}
{"bug_id": "JacksonDatabind-102", "buggy_code": "1     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n2             BeanProperty property) throws JsonMappingException\n3     {\n4         if (property == null) {\n5             return this;\n6         }\n7         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n8         if (format == null) {\n9             return this;\n10         }\n11         JsonFormat.Shape shape = format.getShape();\n12         if (shape.isNumeric()) {\n13             return withFormat(Boolean.TRUE, null);\n14         }\n15         if (format.hasPattern()) {\n16             final Locale loc = format.hasLocale()\n17                             ? format.getLocale()\n18                             : serializers.getLocale();\n19             SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n20             TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n21                     : serializers.getTimeZone();\n22             df.setTimeZone(tz);\n23             return withFormat(Boolean.FALSE, df);\n24         }\n25         final boolean hasLocale = format.hasLocale();\n26         final boolean hasTZ = format.hasTimeZone();\n27         final boolean asString = (shape == JsonFormat.Shape.STRING);\n28         if (!hasLocale && !hasTZ && !asString) {\n29             return this;\n30         }\n31         DateFormat df0 = serializers.getConfig().getDateFormat();\n32         if (df0 instanceof StdDateFormat) {\n33             StdDateFormat std = (StdDateFormat) df0;\n34             if (format.hasLocale()) {\n35                 std = std.withLocale(format.getLocale());\n36             }\n37             if (format.hasTimeZone()) {\n38                 std = std.withTimeZone(format.getTimeZone());\n39             }\n40             return withFormat(Boolean.FALSE, std);\n41         }\n42         if (!(df0 instanceof SimpleDateFormat)) {\n43             serializers.reportBadDefinition(handledType(), String.format(\n44 \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\n45 df0.getClass().getName()));\n46         }\n47         SimpleDateFormat df = (SimpleDateFormat) df0;\n48         if (hasLocale) {\n49             df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n50         } else {\n51             df = (SimpleDateFormat) df.clone();\n52         }\n53         TimeZone newTz = format.getTimeZone();\n54         boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n55         if (changeTZ) {\n56             df.setTimeZone(newTz);\n57         }\n58         return withFormat(Boolean.FALSE, df);\n59     }\n", "fixed_code": "    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n        if (format.hasPattern()) {\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n                    : serializers.getTimeZone();\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n        final boolean hasLocale = format.hasLocale();\n        final boolean hasTZ = format.hasTimeZone();\n        final boolean asString = (shape == JsonFormat.Shape.STRING);\n        if (!hasLocale && !hasTZ && !asString) {\n            return this;\n        }\n        DateFormat df0 = serializers.getConfig().getDateFormat();\n        if (df0 instanceof StdDateFormat) {\n            StdDateFormat std = (StdDateFormat) df0;\n            if (format.hasLocale()) {\n                std = std.withLocale(format.getLocale());\n            }\n            if (format.hasTimeZone()) {\n                std = std.withTimeZone(format.getTimeZone());\n            }\n            return withFormat(Boolean.FALSE, std);\n        }\n        if (!(df0 instanceof SimpleDateFormat)) {\n            serializers.reportBadDefinition(handledType(), String.format(\n\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\ndf0.getClass().getName()));\n        }\n        SimpleDateFormat df = (SimpleDateFormat) df0;\n        if (hasLocale) {\n            df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n        } else {\n            df = (SimpleDateFormat) df.clone();\n        }\n        TimeZone newTz = format.getTimeZone();\n        boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n        if (changeTZ) {\n            df.setTimeZone(newTz);\n        }\n        return withFormat(Boolean.FALSE, df);\n    }\n"}
{"bug_id": "Compress-36", "buggy_code": "1     private InputStream getCurrentStream() throws IOException {\n2         if (deferredBlockStreams.isEmpty()) {\n3             throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n4         }\n5         while (deferredBlockStreams.size() > 1) {\n6             final InputStream stream = deferredBlockStreams.remove(0);\n7             IOUtils.skip(stream, Long.MAX_VALUE);\n8             stream.close();\n9         }\n10         return deferredBlockStreams.get(0);\n11     }\n", "fixed_code": "    private InputStream getCurrentStream() throws IOException {\n        if (archive.files[currentEntryIndex].getSize() == 0) {\n            return new ByteArrayInputStream(new byte[0]);\n        }\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n        while (deferredBlockStreams.size() > 1) {\n            final InputStream stream = deferredBlockStreams.remove(0);\n            IOUtils.skip(stream, Long.MAX_VALUE);\n            stream.close();\n        }\n        return deferredBlockStreams.get(0);\n    }\n"}
{"bug_id": "Chart-3", "buggy_code": "1     public TimeSeries createCopy(int start, int end)\n2             throws CloneNotSupportedException {\n3         if (start < 0) {\n4             throw new IllegalArgumentException(\"Requires start >= 0.\");\n5         }\n6         if (end < start) {\n7             throw new IllegalArgumentException(\"Requires start <= end.\");\n8         }\n9         TimeSeries copy = (TimeSeries) super.clone();\n10         copy.data = new java.util.ArrayList();\n11         if (this.data.size() > 0) {\n12             for (int index = start; index <= end; index++) {\n13                 TimeSeriesDataItem item\n14                         = (TimeSeriesDataItem) this.data.get(index);\n15                 TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n16                 try {\n17                     copy.add(clone);\n18                 }\n19                 catch (SeriesException e) {\n20                     e.printStackTrace();\n21                 }\n22             }\n23         }\n24         return copy;\n25     }\n", "fixed_code": "    public TimeSeries createCopy(int start, int end)\n            throws CloneNotSupportedException {\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.minY = Double.NaN;\n        copy.maxY = Double.NaN;\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                        = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n"}
{"bug_id": "Cli-37", "buggy_code": "1     private boolean isShortOption(String token)\n2     {\n3         return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n4     }\n", "fixed_code": "    private boolean isShortOption(String token)\n    {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        return options.hasShortOption(optName);\n    }\n"}
{"bug_id": "Math-44", "buggy_code": "1     protected double acceptStep(final AbstractStepInterpolator interpolator,\n2                                 final double[] y, final double[] yDot, final double tEnd)\n3         throws MathIllegalStateException {\n4             double previousT = interpolator.getGlobalPreviousTime();\n5             final double currentT = interpolator.getGlobalCurrentTime();\n6             resetOccurred = false;\n7             if (! statesInitialized) {\n8                 for (EventState state : eventsStates) {\n9                     state.reinitializeBegin(interpolator);\n10                 }\n11                 statesInitialized = true;\n12             }\n13             final int orderingSign = interpolator.isForward() ? +1 : -1;\n14             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n15                 public int compare(EventState es0, EventState es1) {\n16                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n17                 }\n18             });\n19             for (final EventState state : eventsStates) {\n20                 if (state.evaluateStep(interpolator)) {\n21                     occuringEvents.add(state);\n22                 }\n23             }\n24             while (!occuringEvents.isEmpty()) {\n25                 final Iterator<EventState> iterator = occuringEvents.iterator();\n26                 final EventState currentEvent = iterator.next();\n27                 iterator.remove();\n28                 final double eventT = currentEvent.getEventTime();\n29                 interpolator.setSoftPreviousTime(previousT);\n30                 interpolator.setSoftCurrentTime(eventT);\n31                 interpolator.setInterpolatedTime(eventT);\n32                 final double[] eventY = interpolator.getInterpolatedState();\n33                 currentEvent.stepAccepted(eventT, eventY);\n34                 isLastStep = currentEvent.stop();\n35                 for (final StepHandler handler : stepHandlers) {\n36                     handler.handleStep(interpolator, isLastStep);\n37                 }\n38                 if (isLastStep) {\n39                     System.arraycopy(eventY, 0, y, 0, y.length);\n40                     return eventT;\n41                 }\n42                 if (currentEvent.reset(eventT, eventY)) {\n43                     System.arraycopy(eventY, 0, y, 0, y.length);\n44                     computeDerivatives(eventT, y, yDot);\n45                     resetOccurred = true;\n46                     return eventT;\n47                 }\n48                 previousT = eventT;\n49                 interpolator.setSoftPreviousTime(eventT);\n50                 interpolator.setSoftCurrentTime(currentT);\n51                 if (currentEvent.evaluateStep(interpolator)) {\n52                     occuringEvents.add(currentEvent);\n53                 }\n54             }\n55             interpolator.setInterpolatedTime(currentT);\n56             final double[] currentY = interpolator.getInterpolatedState();\n57             for (final EventState state : eventsStates) {\n58                 state.stepAccepted(currentT, currentY);\n59                 isLastStep = isLastStep || state.stop();\n60             }\n61             isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n62             for (StepHandler handler : stepHandlers) {\n63                 handler.handleStep(interpolator, isLastStep);\n64             }\n65             return currentT;\n66     }\n", "fixed_code": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState();\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n                if (isLastStep) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n                if (currentEvent.reset(eventT, eventY)) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n"}
{"bug_id": "Csv-9", "buggy_code": "1     <M extends Map<String, String>> M putIn(final M map) {\n2         for (final Entry<String, Integer> entry : mapping.entrySet()) {\n3             final int col = entry.getValue().intValue();\n4             if (col < values.length) {\n5                 map.put(entry.getKey(), values[col]);\n6             }\n7         }\n8         return map;\n9     }\n", "fixed_code": "    <M extends Map<String, String>> M putIn(final M map) {\n        if (mapping == null) {\n            return map;\n        }\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n"}
{"bug_id": "Closure-170", "buggy_code": "1     private void getNumUseInUseCfgNode(final Node cfgNode) {\n2       numUsesWithinCfgNode = 0;\n3       AbstractCfgNodeTraversalCallback gatherCb =\n4           new AbstractCfgNodeTraversalCallback() {\n5         @Override\n6         public void visit(NodeTraversal t, Node n, Node parent) {\n7           if (n.isName() && n.getString().equals(varName) &&\n8               !(parent.isAssign() &&\n9                (parent.getFirstChild() == n))) {\n10               numUsesWithinCfgNode++;\n11           }\n12         }\n13       };\n14       NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n15     }\n", "fixed_code": "    private void getNumUseInUseCfgNode(final Node cfgNode) {\n      numUsesWithinCfgNode = 0;\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName() && n.getString().equals(varName)) {\n            if (parent.isAssign() && (parent.getFirstChild() == n)\n                && isAssignChain(parent, cfgNode)) {\n              return;\n            } else {\n              numUsesWithinCfgNode++;\n            }\n          }\n        }\n        private boolean isAssignChain(Node child, Node ancestor) {\n          for (Node n = child; n != ancestor; n = n.getParent()) {\n            if (!n.isAssign()) {\n              return false;\n            }\n          }\n          return true;\n        }\n      };\n      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n    }\n"}
{"bug_id": "Lang-18", "buggy_code": "1     protected List<Rule> parsePattern() {\n2         DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n3         List<Rule> rules = new ArrayList<Rule>();\n4         String[] ERAs = symbols.getEras();\n5         String[] months = symbols.getMonths();\n6         String[] shortMonths = symbols.getShortMonths();\n7         String[] weekdays = symbols.getWeekdays();\n8         String[] shortWeekdays = symbols.getShortWeekdays();\n9         String[] AmPmStrings = symbols.getAmPmStrings();\n10         int length = mPattern.length();\n11         int[] indexRef = new int[1];\n12         for (int i = 0; i < length; i++) {\n13             indexRef[0] = i;\n14             String token = parseToken(mPattern, indexRef);\n15             i = indexRef[0];\n16             int tokenLen = token.length();\n17             if (tokenLen == 0) {\n18                 break;\n19             }\n20             Rule rule;\n21             char c = token.charAt(0);\n22             switch (c) {\n23             case 'G': \n24                 rule = new TextField(Calendar.ERA, ERAs);\n25                 break;\n26             case 'y': \n27                 if (tokenLen >= 4) {\n28                     rule = selectNumberRule(Calendar.YEAR, tokenLen);\n29                 } else {\n30                     rule = TwoDigitYearField.INSTANCE;\n31                 }\n32                 break;\n33             case 'M': \n34                 if (tokenLen >= 4) {\n35                     rule = new TextField(Calendar.MONTH, months);\n36                 } else if (tokenLen == 3) {\n37                     rule = new TextField(Calendar.MONTH, shortMonths);\n38                 } else if (tokenLen == 2) {\n39                     rule = TwoDigitMonthField.INSTANCE;\n40                 } else {\n41                     rule = UnpaddedMonthField.INSTANCE;\n42                 }\n43                 break;\n44             case 'd': \n45                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n46                 break;\n47             case 'h': \n48                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n49                 break;\n50             case 'H': \n51                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n52                 break;\n53             case 'm': \n54                 rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n55                 break;\n56             case 's': \n57                 rule = selectNumberRule(Calendar.SECOND, tokenLen);\n58                 break;\n59             case 'S': \n60                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n61                 break;\n62             case 'E': \n63                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n64                 break;\n65             case 'D': \n66                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n67                 break;\n68             case 'F': \n69                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n70                 break;\n71             case 'w': \n72                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n73                 break;\n74             case 'W': \n75                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n76                 break;\n77             case 'a': \n78                 rule = new TextField(Calendar.AM_PM, AmPmStrings);\n79                 break;\n80             case 'k': \n81                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n82                 break;\n83             case 'K': \n84                 rule = selectNumberRule(Calendar.HOUR, tokenLen);\n85                 break;\n86             case 'z': \n87                 if (tokenLen >= 4) {\n88                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n89                 } else {\n90                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n91                 }\n92                 break;\n93             case 'Z': \n94                 if (tokenLen == 1) {\n95                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n96                 } else {\n97                     rule = TimeZoneNumberRule.INSTANCE_COLON;\n98                 }\n99                 break;\n100             case '\\'': \n101                 String sub = token.substring(1);\n102                 if (sub.length() == 1) {\n103                     rule = new CharacterLiteral(sub.charAt(0));\n104                 } else {\n105                     rule = new StringLiteral(sub);\n106                 }\n107                 break;\n108             default:\n109                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n110             }\n111             rules.add(rule);\n112         }\n113         return rules;\n114     }\n", "fixed_code": "    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            Rule rule;\n            char c = token.charAt(0);\n            switch (c) {\n            case 'G': \n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': \n                if (tokenLen == 2) {\n                    rule = TwoDigitYearField.INSTANCE;\n                } else {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n                }\n                break;\n            case 'M': \n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': \n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': \n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': \n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': \n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': \n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': \n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': \n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': \n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': \n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': \n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': \n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': \n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': \n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': \n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': \n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': \n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': \n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n            rules.add(rule);\n        }\n        return rules;\n    }\n"}
{"bug_id": "Closure-115", "buggy_code": "1   private CanInlineResult canInlineReferenceDirectly(\n2       Node callNode, Node fnNode) {\n3     if (!isDirectCallNodeReplacementPossible(fnNode)) {\n4       return CanInlineResult.NO;\n5     }\n6     Node block = fnNode.getLastChild();\n7     boolean hasSideEffects = false;\n8     if (block.hasChildren()) {\n9       Preconditions.checkState(block.hasOneChild());\n10       Node stmt = block.getFirstChild();\n11       if (stmt.isReturn()) {\n12         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n13       }\n14     }\n15     Node cArg = callNode.getFirstChild().getNext();\n16     if (!callNode.getFirstChild().isName()) {\n17       if (NodeUtil.isFunctionObjectCall(callNode)) {\n18         if (cArg == null || !cArg.isThis()) {\n19           return CanInlineResult.NO;\n20         }\n21         cArg = cArg.getNext();\n22       } else {\n23         Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n24       }\n25     }\n26     Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n27     while (cArg != null || fnParam != null) {\n28       if (fnParam != null) {\n29         if (cArg != null) {\n30           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n31             return CanInlineResult.NO;\n32           }\n33           if (NodeUtil.mayEffectMutableState(cArg, compiler)\n34               && NodeUtil.getNameReferenceCount(\n35                   block, fnParam.getString()) > 1) {\n36             return CanInlineResult.NO;\n37           }\n38         }\n39         fnParam = fnParam.getNext();\n40       }\n41       if (cArg != null) {\n42         if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n43           return CanInlineResult.NO;\n44         }\n45         cArg = cArg.getNext();\n46       }\n47     }\n48     return CanInlineResult.YES;\n49   }\n", "fixed_code": "  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n    Node block = fnNode.getLastChild();\n    Node cArg = callNode.getFirstChild().getNext();\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      if (fnParam != null) {\n        if (cArg != null) {\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n        fnParam = fnParam.getNext();\n      }\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n    return CanInlineResult.YES;\n  }\n"}
{"bug_id": "Closure-159", "buggy_code": "1   private void findCalledFunctions(\n2       Node node, Set<String> changed) {\n3     Preconditions.checkArgument(changed != null);\n4     if (node.getType() == Token.CALL) {\n5       Node child = node.getFirstChild();\n6       if (child.getType() == Token.NAME) {\n7         changed.add(child.getString());\n8       }\n9     }\n10     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n11       findCalledFunctions(c, changed);\n12     }\n13   }\n", "fixed_code": "  private void findCalledFunctions(\n      Node node, Set<String> changed) {\n    Preconditions.checkArgument(changed != null);\n    if (node.getType() == Token.NAME) {\n      if (isCandidateUsage(node)) {\n        changed.add(node.getString());\n      }\n    }\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      findCalledFunctions(c, changed);\n    }\n  }\n"}
{"bug_id": "Chart-7", "buggy_code": "1     private void updateBounds(TimePeriod period, int index) {\n2         long start = period.getStart().getTime();\n3         long end = period.getEnd().getTime();\n4         long middle = start + ((end - start) / 2);\n5         if (this.minStartIndex >= 0) {\n6             long minStart = getDataItem(this.minStartIndex).getPeriod()\n7                 .getStart().getTime();\n8             if (start < minStart) {\n9                 this.minStartIndex = index;           \n10             }\n11         }\n12         else {\n13             this.minStartIndex = index;\n14         }\n15         if (this.maxStartIndex >= 0) {\n16             long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n17                 .getStart().getTime();\n18             if (start > maxStart) {\n19                 this.maxStartIndex = index;           \n20             }\n21         }\n22         else {\n23             this.maxStartIndex = index;\n24         }\n25         if (this.minMiddleIndex >= 0) {\n26             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n27                 .getTime();\n28             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n29                 .getTime();\n30             long minMiddle = s + (e - s) / 2;\n31             if (middle < minMiddle) {\n32                 this.minMiddleIndex = index;           \n33             }\n34         }\n35         else {\n36             this.minMiddleIndex = index;\n37         }\n38         if (this.maxMiddleIndex >= 0) {\n39             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n40                 .getTime();\n41             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n42                 .getTime();\n43             long maxMiddle = s + (e - s) / 2;\n44             if (middle > maxMiddle) {\n45                 this.maxMiddleIndex = index;           \n46             }\n47         }\n48         else {\n49             this.maxMiddleIndex = index;\n50         }\n51         if (this.minEndIndex >= 0) {\n52             long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n53                 .getTime();\n54             if (end < minEnd) {\n55                 this.minEndIndex = index;           \n56             }\n57         }\n58         else {\n59             this.minEndIndex = index;\n60         }\n61         if (this.maxEndIndex >= 0) {\n62             long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n63                 .getTime();\n64             if (end > maxEnd) {\n65                 this.maxEndIndex = index;           \n66             }\n67         }\n68         else {\n69             this.maxEndIndex = index;\n70         }\n71     }\n", "fixed_code": "    private void updateBounds(TimePeriod period, int index) {\n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n    }\n"}
{"bug_id": "Jsoup-48", "buggy_code": "1         void processResponseHeaders(Map<String, List<String>> resHeaders) {\n2             for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n3                 String name = entry.getKey();\n4                 if (name == null)\n5                     continue; \n6                 List<String> values = entry.getValue();\n7                 if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n8                     for (String value : values) {\n9                         if (value == null)\n10                             continue;\n11                         TokenQueue cd = new TokenQueue(value);\n12                         String cookieName = cd.chompTo(\"=\").trim();\n13                         String cookieVal = cd.consumeTo(\";\").trim();\n14                         if (cookieName.length() > 0)\n15                             cookie(cookieName, cookieVal);\n16                     }\n17                 } else { \n18                     if (!values.isEmpty())\n19                         header(name, values.get(0));\n20                 }\n21             }\n22         }\n", "fixed_code": "        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; \n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                } else { \n                    if (values.size() == 1)\n                        header(name, values.get(0));\n                    else if (values.size() > 1) {\n                        StringBuilder accum = new StringBuilder();\n                        for (int i = 0; i < values.size(); i++) {\n                            final String val = values.get(i);\n                            if (i != 0)\n                                accum.append(\", \");\n                            accum.append(val);\n                        }\n                        header(name, accum.toString());\n                    }\n                }\n            }\n        }\n"}
{"bug_id": "Closure-109", "buggy_code": "1   private Node parseContextTypeExpression(JsDocToken token) {\n2           return parseTypeName(token);\n3   }\n", "fixed_code": "  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      return newNode(Token.QMARK);\n    } else {\n      return parseBasicTypeExpression(token);\n    }\n  }\n"}
{"bug_id": "Closure-70", "buggy_code": "1     private void declareArguments(Node functionNode) {\n2       Node astParameters = functionNode.getFirstChild().getNext();\n3       Node body = astParameters.getNext();\n4       FunctionType functionType = (FunctionType) functionNode.getJSType();\n5       if (functionType != null) {\n6         Node jsDocParameters = functionType.getParametersNode();\n7         if (jsDocParameters != null) {\n8           Node jsDocParameter = jsDocParameters.getFirstChild();\n9           for (Node astParameter : astParameters.children()) {\n10             if (jsDocParameter != null) {\n11               defineSlot(astParameter, functionNode,\n12                   jsDocParameter.getJSType(), true);\n13               jsDocParameter = jsDocParameter.getNext();\n14             } else {\n15               defineSlot(astParameter, functionNode, null, true);\n16             }\n17           }\n18         }\n19       }\n20     } \n", "fixed_code": "    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      FunctionType functionType = (FunctionType) functionNode.getJSType();\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), false);\n              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } \n"}
{"bug_id": "Closure-129", "buggy_code": "1     private void annotateCalls(Node n) {\n2       Preconditions.checkState(n.isCall());\n3       Node first = n.getFirstChild();\n4       if (!NodeUtil.isGet(first)) {\n5         n.putBooleanProp(Node.FREE_CALL, true);\n6       }\n7       if (first.isName() &&\n8           \"eval\".equals(first.getString())) {\n9         first.putBooleanProp(Node.DIRECT_EVAL, true);\n10       }\n11     }\n", "fixed_code": "    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.isCall());\n      Node first = n.getFirstChild();\n      while (first.isCast()) {\n        first = first.getFirstChild();\n      }\n      if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n      if (first.isName() &&\n          \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }\n"}
{"bug_id": "Gson-17", "buggy_code": "1   public Date read(JsonReader in) throws IOException {\n2     if (in.peek() != JsonToken.STRING) {\n3       throw new JsonParseException(\"The date should be a string value\");\n4     }\n5     Date date = deserializeToDate(in.nextString());\n6     if (dateType == Date.class) {\n7       return date;\n8     } else if (dateType == Timestamp.class) {\n9       return new Timestamp(date.getTime());\n10     } else if (dateType == java.sql.Date.class) {\n11       return new java.sql.Date(date.getTime());\n12     } else {\n13       throw new AssertionError();\n14     }\n15   }\n", "fixed_code": "  public Date read(JsonReader in) throws IOException {\n    if (in.peek() == JsonToken.NULL) {\n      in.nextNull();\n      return null;\n    }\n    Date date = deserializeToDate(in.nextString());\n    if (dateType == Date.class) {\n      return date;\n    } else if (dateType == Timestamp.class) {\n      return new Timestamp(date.getTime());\n    } else if (dateType == java.sql.Date.class) {\n      return new java.sql.Date(date.getTime());\n    } else {\n      throw new AssertionError();\n    }\n  }\n"}
{"bug_id": "Compress-32", "buggy_code": "1     private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n2         for (Entry<String, String> ent : headers.entrySet()){\n3             String key = ent.getKey();\n4             String val = ent.getValue();\n5             if (\"path\".equals(key)){\n6                 currEntry.setName(val);\n7             } else if (\"linkpath\".equals(key)){\n8                 currEntry.setLinkName(val);\n9             } else if (\"gid\".equals(key)){\n10                 currEntry.setGroupId(Integer.parseInt(val));\n11             } else if (\"gname\".equals(key)){\n12                 currEntry.setGroupName(val);\n13             } else if (\"uid\".equals(key)){\n14                 currEntry.setUserId(Integer.parseInt(val));\n15             } else if (\"uname\".equals(key)){\n16                 currEntry.setUserName(val);\n17             } else if (\"size\".equals(key)){\n18                 currEntry.setSize(Long.parseLong(val));\n19             } else if (\"mtime\".equals(key)){\n20                 currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n21             } else if (\"SCHILY.devminor\".equals(key)){\n22                 currEntry.setDevMinor(Integer.parseInt(val));\n23             } else if (\"SCHILY.devmajor\".equals(key)){\n24                 currEntry.setDevMajor(Integer.parseInt(val));\n25             }\n26         }\n27     }\n", "fixed_code": "    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Long.parseLong(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Long.parseLong(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            } else if (\"mtime\".equals(key)){\n                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n            } else if (\"SCHILY.devminor\".equals(key)){\n                currEntry.setDevMinor(Integer.parseInt(val));\n            } else if (\"SCHILY.devmajor\".equals(key)){\n                currEntry.setDevMajor(Integer.parseInt(val));\n            }\n        }\n    }\n"}
{"bug_id": "JacksonDatabind-51", "buggy_code": "1     protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n2             String typeId) throws IOException\n3     {\n4         JsonDeserializer<Object> deser = _deserializers.get(typeId);\n5         if (deser == null) {\n6             JavaType type = _idResolver.typeFromId(ctxt, typeId);\n7             if (type == null) {\n8                 deser = _findDefaultImplDeserializer(ctxt);\n9                 if (deser == null) {\n10                     JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n11                     if (actual == null) { \n12                         return null;\n13                     }\n14                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n15                 }\n16             } else {\n17                 if ((_baseType != null)\n18                         && _baseType.getClass() == type.getClass()) {\n19                         type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n20                 }\n21                 deser = ctxt.findContextualValueDeserializer(type, _property);\n22             }\n23             _deserializers.put(typeId, deser);\n24         }\n25         return deser;\n26     }\n", "fixed_code": "    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                    if (actual == null) { \n                        return null;\n                    }\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    if (!type.hasGenericTypes()) {\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                    }\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n"}
{"bug_id": "Jsoup-5", "buggy_code": "1     private Attribute parseAttribute() {\n2         tq.consumeWhitespace();\n3         String key = tq.consumeAttributeKey();\n4         String value = \"\";\n5         tq.consumeWhitespace();\n6         if (tq.matchChomp(\"=\")) {\n7             tq.consumeWhitespace();\n8             if (tq.matchChomp(SQ)) {\n9                 value = tq.chompTo(SQ);\n10             } else if (tq.matchChomp(DQ)) {\n11                 value = tq.chompTo(DQ);\n12             } else {\n13                 StringBuilder valueAccum = new StringBuilder();\n14                 while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n15                     valueAccum.append(tq.consume());\n16                 }\n17                 value = valueAccum.toString();\n18             }\n19             tq.consumeWhitespace();\n20         }\n21         if (key.length() != 0)\n22             return Attribute.createFromEncoded(key, value);\n23         else {\n24             tq.consume();\n25             return null;\n26         }\n27     }\n", "fixed_code": "    private Attribute parseAttribute() {\n        tq.consumeWhitespace();\n        String key = tq.consumeAttributeKey();\n        String value = \"\";\n        tq.consumeWhitespace();\n        if (tq.matchChomp(\"=\")) {\n            tq.consumeWhitespace();\n            if (tq.matchChomp(SQ)) {\n                value = tq.chompTo(SQ);\n            } else if (tq.matchChomp(DQ)) {\n                value = tq.chompTo(DQ);\n            } else {\n                StringBuilder valueAccum = new StringBuilder();\n                while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n                    valueAccum.append(tq.consume());\n                }\n                value = valueAccum.toString();\n            }\n            tq.consumeWhitespace();\n        }\n        if (key.length() != 0)\n            return Attribute.createFromEncoded(key, value);\n        else {\n            if (value.length() == 0) \n                tq.advance();\n            return null;\n        }\n    }\n"}
{"bug_id": "Jsoup-47", "buggy_code": "1     static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n2                        boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n3         boolean lastWasWhite = false;\n4         boolean reachedNonWhite = false;\n5         final EscapeMode escapeMode = out.escapeMode();\n6         final CharsetEncoder encoder = out.encoder();\n7         final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n8         final Map<Character, String> map = escapeMode.getMap();\n9         final int length = string.length();\n10         int codePoint;\n11         for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n12             codePoint = string.codePointAt(offset);\n13             if (normaliseWhite) {\n14                 if (StringUtil.isWhitespace(codePoint)) {\n15                     if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n16                         continue;\n17                     accum.append(' ');\n18                     lastWasWhite = true;\n19                     continue;\n20                 } else {\n21                     lastWasWhite = false;\n22                     reachedNonWhite = true;\n23                 }\n24             }\n25             if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n26                 final char c = (char) codePoint;\n27                 switch (c) {\n28                     case '&':\n29                         accum.append(\"&amp;\");\n30                         break;\n31                     case 0xA0:\n32                         if (escapeMode != EscapeMode.xhtml)\n33                             accum.append(\"&nbsp;\");\n34                         else\n35                             accum.append(\"&#xa0;\");\n36                         break;\n37                     case '<':\n38                         if (!inAttribute)\n39                             accum.append(\"&lt;\");\n40                         else\n41                             accum.append(c);\n42                         break;\n43                     case '>':\n44                         if (!inAttribute)\n45                             accum.append(\"&gt;\");\n46                         else\n47                             accum.append(c);\n48                         break;\n49                     case '\"':\n50                         if (inAttribute)\n51                             accum.append(\"&quot;\");\n52                         else\n53                             accum.append(c);\n54                         break;\n55                     default:\n56                         if (canEncode(coreCharset, c, encoder))\n57                             accum.append(c);\n58                         else if (map.containsKey(c))\n59                             accum.append('&').append(map.get(c)).append(';');\n60                         else\n61                             accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n62                 }\n63             } else {\n64                 final String c = new String(Character.toChars(codePoint));\n65                 if (encoder.canEncode(c)) \n66                     accum.append(c);\n67                 else\n68                     accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n69             }\n70         }\n71     }\n", "fixed_code": "    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n        final Map<Character, String> map = escapeMode.getMap();\n        final int length = string.length();\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) \n                    accum.append(c);\n                else\n                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        }\n    }\n"}
{"bug_id": "JacksonDatabind-71", "buggy_code": "1     public static StdKeyDeserializer forType(Class<?> raw)\n2     {\n3         int kind;\n4         if (raw == String.class || raw == Object.class) {\n5             return StringKD.forType(raw);\n6         } else if (raw == UUID.class) {\n7             kind = TYPE_UUID;\n8         } else if (raw == Integer.class) {\n9             kind = TYPE_INT;\n10         } else if (raw == Long.class) {\n11             kind = TYPE_LONG;\n12         } else if (raw == Date.class) {\n13             kind = TYPE_DATE;\n14         } else if (raw == Calendar.class) {\n15             kind = TYPE_CALENDAR;\n16         } else if (raw == Boolean.class) {\n17             kind = TYPE_BOOLEAN;\n18         } else if (raw == Byte.class) {\n19             kind = TYPE_BYTE;\n20         } else if (raw == Character.class) {\n21             kind = TYPE_CHAR;\n22         } else if (raw == Short.class) {\n23             kind = TYPE_SHORT;\n24         } else if (raw == Float.class) {\n25             kind = TYPE_FLOAT;\n26         } else if (raw == Double.class) {\n27             kind = TYPE_DOUBLE;\n28         } else if (raw == URI.class) {\n29             kind = TYPE_URI;\n30         } else if (raw == URL.class) {\n31             kind = TYPE_URL;\n32         } else if (raw == Class.class) {\n33             kind = TYPE_CLASS;\n34         } else if (raw == Locale.class) {\n35             FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n36             return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n37         } else if (raw == Currency.class) {\n38             FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n39             return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n40         } else {\n41             return null;\n42         }\n43         return new StdKeyDeserializer(kind, raw);\n44     }\n", "fixed_code": "    public static StdKeyDeserializer forType(Class<?> raw)\n    {\n        int kind;\n        if (raw == String.class || raw == Object.class || raw == CharSequence.class) {\n            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n            kind = TYPE_URI;\n        } else if (raw == URL.class) {\n            kind = TYPE_URL;\n        } else if (raw == Class.class) {\n            kind = TYPE_CLASS;\n        } else if (raw == Locale.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n            return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n        } else if (raw == Currency.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n            return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n        } else {\n            return null;\n        }\n        return new StdKeyDeserializer(kind, raw);\n    }\n"}
{"bug_id": "Closure-124", "buggy_code": "1   private boolean isSafeReplacement(Node node, Node replacement) {\n2     if (node.isName()) {\n3       return true;\n4     }\n5     Preconditions.checkArgument(node.isGetProp());\n6       node = node.getFirstChild();\n7     if (node.isName()\n8         && isNameAssignedTo(node.getString(), replacement)) {\n9       return false;\n10     }\n11     return true;\n12   }\n", "fixed_code": "  private boolean isSafeReplacement(Node node, Node replacement) {\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n    while (node.isGetProp()) {\n      node = node.getFirstChild();\n    }\n    if (node.isName()\n        && isNameAssignedTo(node.getString(), replacement)) {\n      return false;\n    }\n    return true;\n  }\n"}
{"bug_id": "Jsoup-41", "buggy_code": "1     public boolean equals(Object o) {\n2         if (this == o) return true;\n3         if (o == null || getClass() != o.getClass()) return false;\n4         if (!super.equals(o)) return false;\n5         Element element = (Element) o;\n6         return this == o;\n7     }\n", "fixed_code": "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n        Element element = (Element) o;\n        return tag.equals(element.tag);\n    }\n"}
{"bug_id": "Mockito-8", "buggy_code": "1     protected void registerTypeVariablesOn(Type classType) {\n2         if (!(classType instanceof ParameterizedType)) {\n3             return;\n4         }\n5         ParameterizedType parameterizedType = (ParameterizedType) classType;\n6         TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n7         Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n8         for (int i = 0; i < actualTypeArguments.length; i++) {\n9             TypeVariable typeParameter = typeParameters[i];\n10             Type actualTypeArgument = actualTypeArguments[i];\n11             if (actualTypeArgument instanceof WildcardType) {\n12                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n13             } else {\n14                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n15             }\n16         }\n17     }\n", "fixed_code": "    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else if (typeParameter != actualTypeArgument) {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n        }\n    }\n"}
{"bug_id": "JacksonCore-8", "buggy_code": "1     public char[] getTextBuffer()\n2     {\n3         if (_inputStart >= 0) return _inputBuffer;\n4         if (_resultArray != null)  return _resultArray;\n5         if (_resultString != null) {\n6             return (_resultArray = _resultString.toCharArray());\n7         }\n8         if (!_hasSegments)  return _currentSegment;\n9         return contentsAsArray();\n10     }\n", "fixed_code": "    public char[] getTextBuffer()\n    {\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n        return contentsAsArray();\n    }\n"}
{"bug_id": "Cli-17", "buggy_code": "1     protected void burstToken(String token, boolean stopAtNonOption)\n2     {\n3         for (int i = 1; i < token.length(); i++)\n4         {\n5             String ch = String.valueOf(token.charAt(i));\n6             if (options.hasOption(ch))\n7             {\n8                 tokens.add(\"-\" + ch);\n9                 currentOption = options.getOption(ch);\n10                 if (currentOption.hasArg() && (token.length() != (i + 1)))\n11                 {\n12                     tokens.add(token.substring(i + 1));\n13                     break;\n14                 }\n15             }\n16             else if (stopAtNonOption)\n17             {\n18                 process(token.substring(i));\n19             }\n20             else\n21             {\n22                 tokens.add(token);\n23                 break;\n24             }\n25         }\n26     }\n", "fixed_code": "    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n"}
{"bug_id": "Math-86", "buggy_code": "1     public CholeskyDecompositionImpl(final RealMatrix matrix,\n2                                      final double relativeSymmetryThreshold,\n3                                      final double absolutePositivityThreshold)\n4         throws NonSquareMatrixException,\n5                NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n6         if (!matrix.isSquare()) {\n7             throw new NonSquareMatrixException(matrix.getRowDimension(),\n8                                                matrix.getColumnDimension());\n9         }\n10         final int order = matrix.getRowDimension();\n11         lTData   = matrix.getData();\n12         cachedL  = null;\n13         cachedLT = null;\n14         for (int i = 0; i < order; ++i) {\n15             final double[] lI = lTData[i];\n16             if (lTData[i][i] < absolutePositivityThreshold) {\n17                 throw new NotPositiveDefiniteMatrixException();\n18             }\n19             for (int j = i + 1; j < order; ++j) {\n20                 final double[] lJ = lTData[j];\n21                 final double lIJ = lI[j];\n22                 final double lJI = lJ[i];\n23                 final double maxDelta =\n24                     relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n25                 if (Math.abs(lIJ - lJI) > maxDelta) {\n26                     throw new NotSymmetricMatrixException();\n27                 }\n28                 lJ[i] = 0;\n29            }\n30         }\n31         for (int i = 0; i < order; ++i) {\n32             final double[] ltI = lTData[i];\n33             ltI[i] = Math.sqrt(ltI[i]);\n34             final double inverse = 1.0 / ltI[i];\n35             for (int q = order - 1; q > i; --q) {\n36                 ltI[q] *= inverse;\n37                 final double[] ltQ = lTData[q];\n38                 for (int p = q; p < order; ++p) {\n39                     ltQ[p] -= ltI[q] * ltI[p];\n40                 }\n41             }\n42         }\n43     }\n", "fixed_code": "    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n        for (int i = 0; i < order; ++i) {\n            final double[] lI = lTData[i];\n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j];\n                final double lIJ = lI[j];\n                final double lJI = lJ[i];\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                lJ[i] = 0;\n           }\n        }\n        for (int i = 0; i < order; ++i) {\n            final double[] ltI = lTData[i];\n            if (ltI[i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n            ltI[i] = Math.sqrt(ltI[i]);\n            final double inverse = 1.0 / ltI[i];\n            for (int q = order - 1; q > i; --q) {\n                ltI[q] *= inverse;\n                final double[] ltQ = lTData[q];\n                for (int p = q; p < order; ++p) {\n                    ltQ[p] -= ltI[q] * ltI[p];\n                }\n            }\n        }\n    }\n"}
{"bug_id": "Closure-83", "buggy_code": "1       public int parseArguments(Parameters params) throws CmdLineException {\n2         String param = params.getParameter(0);\n3         if (param == null) {\n4           setter.addValue(true);\n5           return 0;\n6         } else {\n7           String lowerParam = param.toLowerCase();\n8           if (TRUES.contains(lowerParam)) {\n9             setter.addValue(true);\n10           } else if (FALSES.contains(lowerParam)) {\n11             setter.addValue(false);\n12           } else {\n13             setter.addValue(true);\n14             return 0;\n15           }\n16           return 1;\n17         }\n18       }\n", "fixed_code": "      public int parseArguments(Parameters params) throws CmdLineException {\n        String param = null;\n        try {\n          param = params.getParameter(0);\n        } catch (CmdLineException e) {}\n        if (param == null) {\n          setter.addValue(true);\n          return 0;\n        } else {\n          String lowerParam = param.toLowerCase();\n          if (TRUES.contains(lowerParam)) {\n            setter.addValue(true);\n          } else if (FALSES.contains(lowerParam)) {\n            setter.addValue(false);\n          } else {\n            setter.addValue(true);\n            return 0;\n          }\n          return 1;\n        }\n      }\n"}
{"bug_id": "Jsoup-61", "buggy_code": "1     public boolean hasClass(String className) {\n2         final String classAttr = attributes.get(\"class\");\n3         final int len = classAttr.length();\n4         final int wantLen = className.length();\n5         if (len == 0 || len < wantLen) {\n6             return false;\n7         }\n8         if (len == wantLen) {\n9             return className.equalsIgnoreCase(classAttr);\n10         }\n11         boolean inClass = false;\n12         int start = 0;\n13         for (int i = 0; i < len; i++) {\n14             if (Character.isWhitespace(classAttr.charAt(i))) {\n15                 if (inClass) {\n16                     if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n17                         return true;\n18                     }\n19                     inClass = false;\n20                 }\n21             } else {\n22                 if (!inClass) {\n23                     inClass = true;\n24                     start = i;\n25                 }\n26             }\n27         }\n28         if (inClass && len - start == wantLen) {\n29             return classAttr.regionMatches(true, start, className, 0, wantLen);\n30         }\n31         return false;\n32     }\n", "fixed_code": "    public boolean hasClass(String className) {\n        final String classAttr = attributes.getIgnoreCase(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n                if (!inClass) {\n                    inClass = true;\n                    start = i;\n                }\n            }\n        }\n        if (inClass && len - start == wantLen) {\n            return classAttr.regionMatches(true, start, className, 0, wantLen);\n        }\n        return false;\n    }\n"}
{"bug_id": "Closure-32", "buggy_code": "1   private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n2                                                       WhitespaceOption option) {\n3     if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n4         token == JsDocToken.EOF) {\n5       return new ExtractionInfo(\"\", token);\n6     }\n7     stream.update();\n8     int startLineno = stream.getLineno();\n9     int startCharno = stream.getCharno() + 1;\n10     String line = stream.getRemainingJSDocLine();\n11     if (option != WhitespaceOption.PRESERVE) {\n12       line = line.trim();\n13     }\n14     StringBuilder builder = new StringBuilder();\n15     builder.append(line);\n16     state = State.SEARCHING_ANNOTATION;\n17     token = next();\n18     boolean ignoreStar = false;\n19     do {\n20       switch (token) {\n21         case STAR:\n22           if (ignoreStar) {\n23           } else {\n24             if (builder.length() > 0) {\n25               builder.append(' ');\n26             }\n27             builder.append('*');\n28           }\n29           token = next();\n30           continue;\n31         case EOL:\n32           if (option != WhitespaceOption.SINGLE_LINE) {\n33             builder.append(\"\\n\");\n34           }\n35           ignoreStar = true;\n36           token = next();\n37           continue;\n38         default:\n39           ignoreStar = false;\n40           state = State.SEARCHING_ANNOTATION;\n41           if (token == JsDocToken.EOC ||\n42               token == JsDocToken.EOF ||\n43               (token == JsDocToken.ANNOTATION &&\n44                option != WhitespaceOption.PRESERVE)) {\n45             String multilineText = builder.toString();\n46             if (option != WhitespaceOption.PRESERVE) {\n47               multilineText = multilineText.trim();\n48             }\n49             int endLineno = stream.getLineno();\n50             int endCharno = stream.getCharno();\n51             if (multilineText.length() > 0) {\n52               jsdocBuilder.markText(multilineText, startLineno, startCharno,\n53                   endLineno, endCharno);\n54             }\n55             return new ExtractionInfo(multilineText, token);\n56           }\n57           if (builder.length() > 0) {\n58             builder.append(' ');\n59           }\n60           builder.append(toString(token));\n61           line = stream.getRemainingJSDocLine();\n62           if (option != WhitespaceOption.PRESERVE) {\n63             line = trimEnd(line);\n64           }\n65           builder.append(line);\n66           token = next();\n67       }\n68     } while (true);\n69   }\n", "fixed_code": "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    int lineStartChar = -1;\n    do {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n            lineStartChar = stream.getCharno() + 1;\n          } else {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n            builder.append('*');\n          }\n          token = next();\n          continue;\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          ignoreStar = true;\n          lineStartChar = 0;\n          token = next();\n          continue;\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n          boolean isEOC = token == JsDocToken.EOC;\n          if (!isEOC) {\n            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {\n              int numSpaces = stream.getCharno() - lineStartChar;\n              for (int i = 0; i < numSpaces; i++) {\n                builder.append(' ');\n              }\n              lineStartChar = -1;\n            } else if (builder.length() > 0) {\n              builder.append(' ');\n            }\n          }\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n            return new ExtractionInfo(multilineText, token);\n          }\n          builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n"}
{"bug_id": "Math-53", "buggy_code": "1     public Complex add(Complex rhs)\n2         throws NullArgumentException {\n3         MathUtils.checkNotNull(rhs);\n4         return createComplex(real + rhs.getReal(),\n5             imaginary + rhs.getImaginary());\n6     }\n", "fixed_code": "    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n"}
{"bug_id": "Math-28", "buggy_code": "1     private Integer getPivotRow(SimplexTableau tableau, final int col) {\n2         List<Integer> minRatioPositions = new ArrayList<Integer>();\n3         double minRatio = Double.MAX_VALUE;\n4         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n5             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n6             final double entry = tableau.getEntry(i, col);\n7             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n8                 final double ratio = rhs / entry;\n9                 final int cmp = Double.compare(ratio, minRatio);\n10                 if (cmp == 0) {\n11                     minRatioPositions.add(i);\n12                 } else if (cmp < 0) {\n13                     minRatio = ratio;\n14                     minRatioPositions = new ArrayList<Integer>();\n15                     minRatioPositions.add(i);\n16                 }\n17             }\n18         }\n19         if (minRatioPositions.size() == 0) {\n20             return null;\n21         } else if (minRatioPositions.size() > 1) {\n22                 for (Integer row : minRatioPositions) {\n23                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n24                         int column = i + tableau.getArtificialVariableOffset();\n25                         final double entry = tableau.getEntry(row, column);\n26                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n27                             return row;\n28                         }\n29                     }\n30                 }\n31                 Integer minRow = null;\n32                 int minIndex = tableau.getWidth();\n33                 for (Integer row : minRatioPositions) {\n34                     int i = tableau.getNumObjectiveFunctions();\n35                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n36                         if (row == tableau.getBasicRow(i)) {\n37                             if (i < minIndex) {\n38                                 minIndex = i;\n39                                 minRow = row;\n40                             }\n41                         }\n42                     }\n43                 }\n44                 return minRow;\n45         }\n46         return minRatioPositions.get(0);\n47     }\n", "fixed_code": "    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            if (tableau.getNumArtificialVariables() > 0) {\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n            }\n            if (getIterations() < getMaxIterations() / 2) {\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n            }\n        }\n        return minRatioPositions.get(0);\n    }\n"}
{"bug_id": "Closure-128", "buggy_code": "1   static boolean isSimpleNumber(String s) {\n2     int len = s.length();\n3     for (int index = 0; index < len; index++) {\n4       char c = s.charAt(index);\n5       if (c < '0' || c > '9') {\n6         return false;\n7       }\n8     }\n9     return len > 0 && s.charAt(0) != '0';\n10   }\n", "fixed_code": "  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    if (len == 0) {\n      return false;\n    }\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len == 1 || s.charAt(0) != '0';\n  }\n"}
{"bug_id": "Compress-37", "buggy_code": "1     Map<String, String> parsePaxHeaders(final InputStream i)\n2         throws IOException {\n3         final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n4         while(true){ \n5             int ch;\n6             int len = 0;\n7             int read = 0;\n8             while((ch = i.read()) != -1) {\n9                 read++;\n10                 if (ch == ' '){\n11                     final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n12                     while((ch = i.read()) != -1) {\n13                         read++;\n14                         if (ch == '='){ \n15                             final String keyword = coll.toString(CharsetNames.UTF_8);\n16                             final int restLen = len - read;\n17                             if (restLen == 1) { \n18                                 headers.remove(keyword);\n19                             } else {\n20                                 final byte[] rest = new byte[restLen];\n21                                 final int got = IOUtils.readFully(i, rest);\n22                                 if (got != restLen) {\n23                                     throw new IOException(\"Failed to read \"\n24                                                           + \"Paxheader. Expected \"\n25                                                           + restLen\n26                                                           + \" bytes, read \"\n27                                                           + got);\n28                                 }\n29                                 final String value = new String(rest, 0,\n30                                                           restLen - 1, CharsetNames.UTF_8);\n31                                 headers.put(keyword, value);\n32                             }\n33                             break;\n34                         }\n35                         coll.write((byte) ch);\n36                     }\n37                     break; \n38                 }\n39                 len *= 10;\n40                 len += ch - '0';\n41             }\n42             if (ch == -1){ \n43                 break;\n44             }\n45         }\n46         return headers;\n47     }\n", "fixed_code": "    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        while(true){ \n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == '\\n') { \n                    break;\n                } else if (ch == ' '){ \n                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ \n                            final String keyword = coll.toString(CharsetNames.UTF_8);\n                            final int restLen = len - read;\n                            if (restLen == 1) { \n                                headers.remove(keyword);\n                            } else {\n                                final byte[] rest = new byte[restLen];\n                                final int got = IOUtils.readFully(i, rest);\n                                if (got != restLen) {\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + restLen\n                                                          + \" bytes, read \"\n                                                          + got);\n                                }\n                                final String value = new String(rest, 0,\n                                                          restLen - 1, CharsetNames.UTF_8);\n                                headers.put(keyword, value);\n                            }\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; \n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ \n                break;\n            }\n        }\n        return headers;\n    }\n"}
{"bug_id": "Compress-7", "buggy_code": "1     public static String parseName(byte[] buffer, final int offset, final int length) {\n2         StringBuffer result = new StringBuffer(length);\n3         int          end = offset + length;\n4         for (int i = offset; i < end; ++i) {\n5             if (buffer[i] == 0) {\n6                 break;\n7             }\n8             result.append((char) buffer[i]);\n9         }\n10         return result.toString();\n11     }\n", "fixed_code": "    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n        for (int i = offset; i < end; ++i) {\n            byte b = buffer[i];\n            if (b == 0) { \n                break;\n            }\n            result.append((char) (b & 0xFF)); \n        }\n        return result.toString();\n    }\n"}
{"bug_id": "Cli-4", "buggy_code": "1     private void checkRequiredOptions()\n2         throws MissingOptionException\n3     {\n4         if (requiredOptions.size() > 0)\n5         {\n6             Iterator iter = requiredOptions.iterator();\n7             StringBuffer buff = new StringBuffer();\n8             while (iter.hasNext())\n9             {\n10                 buff.append(iter.next());\n11             }\n12             throw new MissingOptionException(buff.toString());\n13         }\n14     }\n", "fixed_code": "    private void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        if (requiredOptions.size() > 0)\n        {\n            Iterator iter = requiredOptions.iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(requiredOptions.size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n"}
{"bug_id": "Time-16", "buggy_code": "1     public int parseInto(ReadWritableInstant instant, String text, int position) {\n2         DateTimeParser parser = requireParser();\n3         if (instant == null) {\n4             throw new IllegalArgumentException(\"Instant must not be null\");\n5         }\n6         long instantMillis = instant.getMillis();\n7         Chronology chrono = instant.getChronology();\n8         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n9         chrono = selectChronology(chrono);\n10         DateTimeParserBucket bucket = new DateTimeParserBucket(\n11             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n12         int newPos = parser.parseInto(bucket, text, position);\n13         instant.setMillis(bucket.computeMillis(false, text));\n14         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n15             int parsedOffset = bucket.getOffsetInteger();\n16             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n17             chrono = chrono.withZone(parsedZone);\n18         } else if (bucket.getZone() != null) {\n19             chrono = chrono.withZone(bucket.getZone());\n20         }\n21         instant.setChronology(chrono);\n22         if (iZone != null) {\n23             instant.setZone(iZone);\n24         }\n25         return newPos;\n26     }\n", "fixed_code": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n"}
{"bug_id": "Jsoup-42", "buggy_code": "1     public List<Connection.KeyVal> formData() {\n2         ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n3         for (Element el: elements) {\n4             if (!el.tag().isFormSubmittable()) continue; \n5             String name = el.attr(\"name\");\n6             if (name.length() == 0) continue;\n7             String type = el.attr(\"type\");\n8             if (\"select\".equals(el.tagName())) {\n9                 Elements options = el.select(\"option[selected]\");\n10                 boolean set = false;\n11                 for (Element option: options) {\n12                     data.add(HttpConnection.KeyVal.create(name, option.val()));\n13                     set = true;\n14                 }\n15                 if (!set) {\n16                     Element option = el.select(\"option\").first();\n17                     if (option != null)\n18                         data.add(HttpConnection.KeyVal.create(name, option.val()));\n19                 }\n20             } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n21                 if (el.hasAttr(\"checked\")) {\n22                     final String val = el.val();\n23                     data.add(HttpConnection.KeyVal.create(name, val));\n24                 }\n25             } else {\n26                 data.add(HttpConnection.KeyVal.create(name, el.val()));\n27             }\n28         }\n29         return data;\n30     }\n", "fixed_code": "    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; \n            if (el.hasAttr(\"disabled\")) continue; \n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n            if (\"select\".equals(el.tagName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n        return data;\n    }\n"}
{"bug_id": "Closure-166", "buggy_code": "1   public void matchConstraint(JSType constraint) {\n2     if (hasReferenceName()) {\n3       return;\n4     }\n5     if (constraint.isRecordType()) {\n6       matchRecordTypeConstraint(constraint.toObjectType());\n7     }\n8   }\n", "fixed_code": "  public void matchConstraint(JSType constraint) {\n    if (hasReferenceName()) {\n      return;\n    }\n    if (constraint.isRecordType()) {\n      matchRecordTypeConstraint(constraint.toObjectType());\n    } else if (constraint.isUnionType()) {\n      for (JSType alt : constraint.toMaybeUnionType().getAlternates()) {\n        if (alt.isRecordType()) {\n          matchRecordTypeConstraint(alt.toObjectType());\n        }\n      }\n    }\n  }\n"}
{"bug_id": "Closure-87", "buggy_code": "1   private boolean isFoldableExpressBlock(Node n) {\n2     if (n.getType() == Token.BLOCK) {\n3       if (n.hasOneChild()) {\n4         Node maybeExpr = n.getFirstChild();\n5           return NodeUtil.isExpressionNode(maybeExpr);\n6       }\n7     }\n8     return false;\n9   }\n", "fixed_code": "  private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        Node maybeExpr = n.getFirstChild();\n        if (maybeExpr.getType() == Token.EXPR_RESULT) {\n          if (maybeExpr.getFirstChild().getType() == Token.CALL) {\n            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n            if (calledFn.getType() == Token.GETELEM) {\n              return false;\n            } else if (calledFn.getType() == Token.GETPROP &&\n                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n              return false;\n            }\n          }\n          return true;\n        }\n        return false;\n      }\n    }\n    return false;\n  }\n"}
{"bug_id": "JacksonDatabind-107", "buggy_code": "1     protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n2             String typeId) throws IOException\n3     {\n4         JsonDeserializer<Object> deser = _deserializers.get(typeId);\n5         if (deser == null) {\n6             JavaType type = _idResolver.typeFromId(ctxt, typeId);\n7             if (type == null) {\n8                 deser = _findDefaultImplDeserializer(ctxt);\n9                 if (deser == null) {\n10                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n11                     if (actual == null) { \n12                         return null;\n13                     }\n14                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n15                 }\n16             } else {\n17                 if ((_baseType != null)\n18                         && _baseType.getClass() == type.getClass()) {\n19                     if (!type.hasGenericTypes()) {\n20                         type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n21                     }\n22                 }\n23                 deser = ctxt.findContextualValueDeserializer(type, _property);\n24             }\n25             _deserializers.put(typeId, deser);\n26         }\n27         return deser;\n28     }\n", "fixed_code": "    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                    if (actual == null) { \n                        return NullifyingDeserializer.instance;\n                    }\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    if (!type.hasGenericTypes()) {\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                    }\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n"}
{"bug_id": "Jsoup-62", "buggy_code": "1         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n2             String name = t.asEndTag().normalName();\n3             ArrayList<Element> stack = tb.getStack();\n4             for (int pos = stack.size() -1; pos >= 0; pos--) {\n5                 Element node = stack.get(pos);\n6                 if (node.nodeName().equals(name)) {\n7                     tb.generateImpliedEndTags(name);\n8                     if (!name.equals(tb.currentElement().nodeName()))\n9                         tb.error(this);\n10                     tb.popStackToClose(name);\n11                     break;\n12                 } else {\n13                     if (tb.isSpecial(node)) {\n14                         tb.error(this);\n15                         return false;\n16                     }\n17                 }\n18             }\n19             return true;\n20         }\n", "fixed_code": "        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().name(); \n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n"}
{"bug_id": "JacksonDatabind-37", "buggy_code": "1     protected JavaType _narrow(Class<?> subclass)\n2     {\n3         if (_class == subclass) {\n4             return this;\n5         }\n6         return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n7                 _valueHandler, _typeHandler, _asStatic);\n8     }\n", "fixed_code": "    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n"}
{"bug_id": "Math-51", "buggy_code": "1     protected final double doSolve() {\n2         double x0 = getMin();\n3         double x1 = getMax();\n4         double f0 = computeObjectiveValue(x0);\n5         double f1 = computeObjectiveValue(x1);\n6         if (f0 == 0.0) {\n7             return x0;\n8         }\n9         if (f1 == 0.0) {\n10             return x1;\n11         }\n12         verifyBracketing(x0, x1);\n13         final double ftol = getFunctionValueAccuracy();\n14         final double atol = getAbsoluteAccuracy();\n15         final double rtol = getRelativeAccuracy();\n16         boolean inverted = false;\n17         while (true) {\n18             final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n19             final double fx = computeObjectiveValue(x);\n20             if (fx == 0.0) {\n21                 return x;\n22             }\n23             if (f1 * fx < 0) {\n24                 x0 = x1;\n25                 f0 = f1;\n26                 inverted = !inverted;\n27             } else {\n28                 switch (method) {\n29                 case ILLINOIS:\n30                     f0 *= 0.5;\n31                     break;\n32                 case PEGASUS:\n33                     f0 *= f1 / (f1 + fx);\n34                     break;\n35                 default:\n36                 }\n37             }\n38             x1 = x;\n39             f1 = fx;\n40             if (FastMath.abs(f1) <= ftol) {\n41                 switch (allowed) {\n42                 case ANY_SIDE:\n43                     return x1;\n44                 case LEFT_SIDE:\n45                     if (inverted) {\n46                         return x1;\n47                     }\n48                     break;\n49                 case RIGHT_SIDE:\n50                     if (!inverted) {\n51                         return x1;\n52                     }\n53                     break;\n54                 case BELOW_SIDE:\n55                     if (f1 <= 0) {\n56                         return x1;\n57                     }\n58                     break;\n59                 case ABOVE_SIDE:\n60                     if (f1 >= 0) {\n61                         return x1;\n62                     }\n63                     break;\n64                 default:\n65                     throw new MathInternalError();\n66                 }\n67             }\n68             if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n69                                                      atol)) {\n70                 switch (allowed) {\n71                 case ANY_SIDE:\n72                     return x1;\n73                 case LEFT_SIDE:\n74                     return inverted ? x1 : x0;\n75                 case RIGHT_SIDE:\n76                     return inverted ? x0 : x1;\n77                 case BELOW_SIDE:\n78                     return (f1 <= 0) ? x1 : x0;\n79                 case ABOVE_SIDE:\n80                     return (f1 >= 0) ? x1 : x0;\n81                 default:\n82                     throw new MathInternalError();\n83                 }\n84             }\n85         }\n86     }\n", "fixed_code": "    protected final double doSolve() {\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n        boolean inverted = false;\n        while (true) {\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n            if (fx == 0.0) {\n                return x;\n            }\n            if (f1 * fx < 0) {\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    if (x == x1) {\n                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n                                                          atol);\n                        x0 = 0.5 * (x0 + x1 - delta);\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            x1 = x;\n            f1 = fx;\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"}
{"bug_id": "JacksonDatabind-100", "buggy_code": "1     public byte[] getBinaryValue(Base64Variant b64variant)\n2         throws IOException, JsonParseException\n3     {\n4         JsonNode n = currentNode();\n5         if (n != null) {\n6             byte[] data = n.binaryValue();\n7             if (data != null) {\n8                 return data;\n9             }\n10             if (n.isPojo()) {\n11                 Object ob = ((POJONode) n).getPojo();\n12                 if (ob instanceof byte[]) {\n13                     return (byte[]) ob;\n14                 }\n15             }\n16         }\n17         return null;\n18     }\n", "fixed_code": "    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        JsonNode n = currentNode();\n        if (n != null) {\n            if (n instanceof TextNode) {\n                return ((TextNode) n).getBinaryValue(b64variant);\n            }\n            return n.binaryValue();\n        }\n        return null;\n    }\n"}
{"bug_id": "Time-20", "buggy_code": "1         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n2             String str = text.substring(position);\n3             for (String id : ALL_IDS) {\n4                 if (str.startsWith(id)) {\n5                     bucket.setZone(DateTimeZone.forID(id));\n6                     return position + id.length();\n7                 }\n8             }\n9             return ~position;\n10         }\n", "fixed_code": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            String best = null;\n            for (String id : ALL_IDS) {\n                if (str.startsWith(id)) {\n                \tif (best == null || id.length() > best.length()) {\n                \t\tbest = id;\n                \t}\n                }\n            }\n            if (best != null) {\n                bucket.setZone(DateTimeZone.forID(best));\n                return position + best.length();\n            }\n            return ~position;\n        }\n"}
{"bug_id": "Jsoup-68", "buggy_code": "1     private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n2         int bottom = stack.size() -1;\n3         if (bottom > MaxScopeSearchDepth) {\n4             bottom = MaxScopeSearchDepth;\n5         }\n6         final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n7         for (int pos = bottom; pos >= top; pos--) {\n8             final String elName = stack.get(pos).nodeName();\n9             if (inSorted(elName, targetNames))\n10                 return true;\n11             if (inSorted(elName, baseTypes))\n12                 return false;\n13             if (extraTypes != null && inSorted(elName, extraTypes))\n14                 return false;\n15         }\n16         return false;\n17     }\n", "fixed_code": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).nodeName();\n            if (inSorted(elName, targetNames))\n                return true;\n            if (inSorted(elName, baseTypes))\n                return false;\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false;\n        }\n        return false;\n    }\n"}
{"bug_id": "Jsoup-51", "buggy_code": "1     boolean matchesLetter() {\n2         if (isEmpty())\n3             return false;\n4         char c = input[pos];\n5         return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n6     }\n", "fixed_code": "    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n"}
{"bug_id": "Gson-18", "buggy_code": "1   static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n2     checkArgument(supertype.isAssignableFrom(contextRawType));\n3     return resolve(context, contextRawType,\n4         $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n5   }\n", "fixed_code": "  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n    if (context instanceof WildcardType) {\n      context = ((WildcardType)context).getUpperBounds()[0];\n    }\n    checkArgument(supertype.isAssignableFrom(contextRawType));\n    return resolve(context, contextRawType,\n        $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n  }\n"}
{"bug_id": "Closure-88", "buggy_code": "1   private VariableLiveness isVariableReadBeforeKill(\n2       Node n, String variable) {\n3     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n4       if (NodeUtil.isLhs(n, n.getParent())) {\n5         return VariableLiveness.KILL;\n6       } else {\n7         return VariableLiveness.READ;\n8       }\n9     }\n10     for (Node child = n.getFirstChild();\n11         child != null; child = child.getNext()) {\n12       if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { \n13         VariableLiveness state = isVariableReadBeforeKill(child, variable);\n14         if (state != VariableLiveness.MAYBE_LIVE) {\n15           return state;\n16         }\n17       }\n18     }\n19     return VariableLiveness.MAYBE_LIVE;\n20   }\n", "fixed_code": "  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n        Node rhs = n.getNext();\n        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n        if (state == VariableLiveness.READ) {\n          return state;\n        }\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { \n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state;\n        }\n      }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n  }\n"}
{"bug_id": "Closure-123", "buggy_code": "1   void add(Node n, Context context) {\n2     if (!cc.continueProcessing()) {\n3       return;\n4     }\n5     int type = n.getType();\n6     String opstr = NodeUtil.opToStr(type);\n7     int childCount = n.getChildCount();\n8     Node first = n.getFirstChild();\n9     Node last = n.getLastChild();\n10     if (opstr != null && first != last) {\n11       Preconditions.checkState(\n12           childCount == 2,\n13           \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n14           opstr, childCount);\n15       int p = NodeUtil.precedence(type);\n16       Context rhsContext = getContextForNoInOperator(context);\n17       if (last.getType() == type &&\n18           NodeUtil.isAssociative(type)) {\n19         addExpr(first, p, context);\n20         cc.addOp(opstr, true);\n21         addExpr(last, p, rhsContext);\n22       } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n23         addExpr(first, p, context);\n24         cc.addOp(opstr, true);\n25         addExpr(last, p, rhsContext);\n26       } else {\n27         unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n28       }\n29       return;\n30     }\n31     cc.startSourceMapping(n);\n32     switch (type) {\n33       case Token.TRY: {\n34         Preconditions.checkState(first.getNext().isBlock() &&\n35                 !first.getNext().hasMoreThanOneChild());\n36         Preconditions.checkState(childCount >= 2 && childCount <= 3);\n37         add(\"try\");\n38         add(first, Context.PRESERVE_BLOCK);\n39         Node catchblock = first.getNext().getFirstChild();\n40         if (catchblock != null) {\n41           add(catchblock);\n42         }\n43         if (childCount == 3) {\n44           add(\"finally\");\n45           add(last, Context.PRESERVE_BLOCK);\n46         }\n47         break;\n48       }\n49       case Token.CATCH:\n50         Preconditions.checkState(childCount == 2);\n51         add(\"catch(\");\n52         add(first);\n53         add(\")\");\n54         add(last, Context.PRESERVE_BLOCK);\n55         break;\n56       case Token.THROW:\n57         Preconditions.checkState(childCount == 1);\n58         add(\"throw\");\n59         add(first);\n60         cc.endStatement(true);\n61         break;\n62       case Token.RETURN:\n63         add(\"return\");\n64         if (childCount == 1) {\n65           add(first);\n66         } else {\n67           Preconditions.checkState(childCount == 0);\n68         }\n69         cc.endStatement();\n70         break;\n71       case Token.VAR:\n72         if (first != null) {\n73           add(\"var \");\n74           addList(first, false, getContextForNoInOperator(context));\n75         }\n76         break;\n77       case Token.LABEL_NAME:\n78         Preconditions.checkState(!n.getString().isEmpty());\n79         addIdentifier(n.getString());\n80         break;\n81       case Token.NAME:\n82         if (first == null || first.isEmpty()) {\n83           addIdentifier(n.getString());\n84         } else {\n85           Preconditions.checkState(childCount == 1);\n86           addIdentifier(n.getString());\n87           cc.addOp(\"=\", true);\n88           if (first.isComma()) {\n89             addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n90           } else {\n91             addExpr(first, 0, getContextForNoInOperator(context));\n92           }\n93         }\n94         break;\n95       case Token.ARRAYLIT:\n96         add(\"[\");\n97         addArrayList(first);\n98         add(\"]\");\n99         break;\n100       case Token.PARAM_LIST:\n101         add(\"(\");\n102         addList(first);\n103         add(\")\");\n104         break;\n105       case Token.COMMA:\n106         Preconditions.checkState(childCount == 2);\n107         unrollBinaryOperator(n, Token.COMMA, \",\", context,\n108             getContextForNoInOperator(context), 0, 0);\n109         break;\n110       case Token.NUMBER:\n111         Preconditions.checkState(childCount == 0);\n112         cc.addNumber(n.getDouble());\n113         break;\n114       case Token.TYPEOF:\n115       case Token.VOID:\n116       case Token.NOT:\n117       case Token.BITNOT:\n118       case Token.POS: {\n119         Preconditions.checkState(childCount == 1);\n120         cc.addOp(NodeUtil.opToStrNoFail(type), false);\n121         addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n122         break;\n123       }\n124       case Token.NEG: {\n125         Preconditions.checkState(childCount == 1);\n126         if (n.getFirstChild().isNumber()) {\n127           cc.addNumber(-n.getFirstChild().getDouble());\n128         } else {\n129           cc.addOp(NodeUtil.opToStrNoFail(type), false);\n130           addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n131         }\n132         break;\n133       }\n134       case Token.HOOK: {\n135         Preconditions.checkState(childCount == 3);\n136         int p = NodeUtil.precedence(type);\n137         Context rhsContext = Context.OTHER;\n138         addExpr(first, p + 1, context);\n139         cc.addOp(\"?\", true);\n140         addExpr(first.getNext(), 1, rhsContext);\n141         cc.addOp(\":\", true);\n142         addExpr(last, 1, rhsContext);\n143         break;\n144       }\n145       case Token.REGEXP:\n146         if (!first.isString() ||\n147             !last.isString()) {\n148           throw new Error(\"Expected children to be strings\");\n149         }\n150         String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n151         if (childCount == 2) {\n152           add(regexp + last.getString());\n153         } else {\n154           Preconditions.checkState(childCount == 1);\n155           add(regexp);\n156         }\n157         break;\n158       case Token.FUNCTION:\n159         if (n.getClass() != Node.class) {\n160           throw new Error(\"Unexpected Node subclass.\");\n161         }\n162         Preconditions.checkState(childCount == 3);\n163         boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n164         if (funcNeedsParens) {\n165           add(\"(\");\n166         }\n167         add(\"function\");\n168         add(first);\n169         add(first.getNext());\n170         add(last, Context.PRESERVE_BLOCK);\n171         cc.endFunction(context == Context.STATEMENT);\n172         if (funcNeedsParens) {\n173           add(\")\");\n174         }\n175         break;\n176       case Token.GETTER_DEF:\n177       case Token.SETTER_DEF:\n178         Preconditions.checkState(n.getParent().isObjectLit());\n179         Preconditions.checkState(childCount == 1);\n180         Preconditions.checkState(first.isFunction());\n181         Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n182         if (type == Token.GETTER_DEF) {\n183           Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n184           add(\"get \");\n185         } else {\n186           Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n187           add(\"set \");\n188         }\n189         String name = n.getString();\n190         Node fn = first;\n191         Node parameters = fn.getChildAtIndex(1);\n192         Node body = fn.getLastChild();\n193         if (!n.isQuotedString() &&\n194             TokenStream.isJSIdentifier(name) &&\n195             NodeUtil.isLatin(name)) {\n196           add(name);\n197         } else {\n198           double d = getSimpleNumber(name);\n199           if (!Double.isNaN(d)) {\n200             cc.addNumber(d);\n201           } else {\n202             addJsString(n);\n203           }\n204         }\n205         add(parameters);\n206         add(body, Context.PRESERVE_BLOCK);\n207         break;\n208       case Token.SCRIPT:\n209       case Token.BLOCK: {\n210         if (n.getClass() != Node.class) {\n211           throw new Error(\"Unexpected Node subclass.\");\n212         }\n213         boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n214         if (preserveBlock) {\n215           cc.beginBlock();\n216         }\n217         boolean preferLineBreaks =\n218             type == Token.SCRIPT ||\n219             (type == Token.BLOCK &&\n220                 !preserveBlock &&\n221                 n.getParent() != null &&\n222                 n.getParent().isScript());\n223         for (Node c = first; c != null; c = c.getNext()) {\n224           add(c, Context.STATEMENT);\n225           if (c.isVar()) {\n226             cc.endStatement();\n227           }\n228           if (c.isFunction()) {\n229             cc.maybeLineBreak();\n230           }\n231           if (preferLineBreaks) {\n232             cc.notePreferredLineBreak();\n233           }\n234         }\n235         if (preserveBlock) {\n236           cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n237         }\n238         break;\n239       }\n240       case Token.FOR:\n241         if (childCount == 4) {\n242           add(\"for(\");\n243           if (first.isVar()) {\n244             add(first, Context.IN_FOR_INIT_CLAUSE);\n245           } else {\n246             addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n247           }\n248           add(\";\");\n249           add(first.getNext());\n250           add(\";\");\n251           add(first.getNext().getNext());\n252           add(\")\");\n253           addNonEmptyStatement(\n254               last, getContextForNonEmptyExpression(context), false);\n255         } else {\n256           Preconditions.checkState(childCount == 3);\n257           add(\"for(\");\n258           add(first);\n259           add(\"in\");\n260           add(first.getNext());\n261           add(\")\");\n262           addNonEmptyStatement(\n263               last, getContextForNonEmptyExpression(context), false);\n264         }\n265         break;\n266       case Token.DO:\n267         Preconditions.checkState(childCount == 2);\n268         add(\"do\");\n269         addNonEmptyStatement(first, Context.OTHER, false);\n270         add(\"while(\");\n271         add(last);\n272         add(\")\");\n273         cc.endStatement();\n274         break;\n275       case Token.WHILE:\n276         Preconditions.checkState(childCount == 2);\n277         add(\"while(\");\n278         add(first);\n279         add(\")\");\n280         addNonEmptyStatement(\n281             last, getContextForNonEmptyExpression(context), false);\n282         break;\n283       case Token.EMPTY:\n284         Preconditions.checkState(childCount == 0);\n285         break;\n286       case Token.GETPROP: {\n287         Preconditions.checkState(\n288             childCount == 2,\n289             \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n290         Preconditions.checkState(\n291             last.isString(),\n292             \"Bad GETPROP: RHS should be STRING\");\n293         boolean needsParens = (first.isNumber());\n294         if (needsParens) {\n295           add(\"(\");\n296         }\n297         addExpr(first, NodeUtil.precedence(type), context);\n298         if (needsParens) {\n299           add(\")\");\n300         }\n301         if (this.languageMode == LanguageMode.ECMASCRIPT3\n302             && TokenStream.isKeyword(last.getString())) {\n303           add(\"[\");\n304           add(last);\n305           add(\"]\");\n306         } else {\n307           add(\".\");\n308           addIdentifier(last.getString());\n309         }\n310         break;\n311       }\n312       case Token.GETELEM:\n313         Preconditions.checkState(\n314             childCount == 2,\n315             \"Bad GETELEM: expected 2 children but got %s\", childCount);\n316         addExpr(first, NodeUtil.precedence(type), context);\n317         add(\"[\");\n318         add(first.getNext());\n319         add(\"]\");\n320         break;\n321       case Token.WITH:\n322         Preconditions.checkState(childCount == 2);\n323         add(\"with(\");\n324         add(first);\n325         add(\")\");\n326         addNonEmptyStatement(\n327             last, getContextForNonEmptyExpression(context), false);\n328         break;\n329       case Token.INC:\n330       case Token.DEC: {\n331         Preconditions.checkState(childCount == 1);\n332         String o = type == Token.INC ? \"++\" : \"--\";\n333         int postProp = n.getIntProp(Node.INCRDECR_PROP);\n334         if (postProp != 0) {\n335           addExpr(first, NodeUtil.precedence(type), context);\n336           cc.addOp(o, false);\n337         } else {\n338           cc.addOp(o, false);\n339           add(first);\n340         }\n341         break;\n342       }\n343       case Token.CALL:\n344         if (isIndirectEval(first)\n345             || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n346           add(\"(0,\");\n347           addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n348           add(\")\");\n349         } else {\n350           addExpr(first, NodeUtil.precedence(type), context);\n351         }\n352         add(\"(\");\n353         addList(first.getNext());\n354         add(\")\");\n355         break;\n356       case Token.IF:\n357         boolean hasElse = childCount == 3;\n358         boolean ambiguousElseClause =\n359             context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n360         if (ambiguousElseClause) {\n361           cc.beginBlock();\n362         }\n363         add(\"if(\");\n364         add(first);\n365         add(\")\");\n366         if (hasElse) {\n367           addNonEmptyStatement(\n368               first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n369           add(\"else\");\n370           addNonEmptyStatement(\n371               last, getContextForNonEmptyExpression(context), false);\n372         } else {\n373           addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n374           Preconditions.checkState(childCount == 2);\n375         }\n376         if (ambiguousElseClause) {\n377           cc.endBlock();\n378         }\n379         break;\n380       case Token.NULL:\n381         Preconditions.checkState(childCount == 0);\n382         cc.addConstant(\"null\");\n383         break;\n384       case Token.THIS:\n385         Preconditions.checkState(childCount == 0);\n386         add(\"this\");\n387         break;\n388       case Token.FALSE:\n389         Preconditions.checkState(childCount == 0);\n390         cc.addConstant(\"false\");\n391         break;\n392       case Token.TRUE:\n393         Preconditions.checkState(childCount == 0);\n394         cc.addConstant(\"true\");\n395         break;\n396       case Token.CONTINUE:\n397         Preconditions.checkState(childCount <= 1);\n398         add(\"continue\");\n399         if (childCount == 1) {\n400           if (!first.isLabelName()) {\n401             throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n402           }\n403           add(\" \");\n404           add(first);\n405         }\n406         cc.endStatement();\n407         break;\n408       case Token.DEBUGGER:\n409         Preconditions.checkState(childCount == 0);\n410         add(\"debugger\");\n411         cc.endStatement();\n412         break;\n413       case Token.BREAK:\n414         Preconditions.checkState(childCount <= 1);\n415         add(\"break\");\n416         if (childCount == 1) {\n417           if (!first.isLabelName()) {\n418             throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n419           }\n420           add(\" \");\n421           add(first);\n422         }\n423         cc.endStatement();\n424         break;\n425       case Token.EXPR_RESULT:\n426         Preconditions.checkState(childCount == 1);\n427         add(first, Context.START_OF_EXPR);\n428         cc.endStatement();\n429         break;\n430       case Token.NEW:\n431         add(\"new \");\n432         int precedence = NodeUtil.precedence(type);\n433         if (NodeUtil.containsType(\n434             first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n435           precedence = NodeUtil.precedence(first.getType()) + 1;\n436         }\n437         addExpr(first, precedence, Context.OTHER);\n438         Node next = first.getNext();\n439         if (next != null) {\n440           add(\"(\");\n441           addList(next);\n442           add(\")\");\n443         }\n444         break;\n445       case Token.STRING_KEY:\n446         Preconditions.checkState(\n447             childCount == 1, \"Object lit key must have 1 child\");\n448         addJsString(n);\n449         break;\n450       case Token.STRING:\n451         Preconditions.checkState(\n452             childCount == 0, \"A string may not have children\");\n453         addJsString(n);\n454         break;\n455       case Token.DELPROP:\n456         Preconditions.checkState(childCount == 1);\n457         add(\"delete \");\n458         add(first);\n459         break;\n460       case Token.OBJECTLIT: {\n461         boolean needsParens = (context == Context.START_OF_EXPR);\n462         if (needsParens) {\n463           add(\"(\");\n464         }\n465         add(\"{\");\n466         for (Node c = first; c != null; c = c.getNext()) {\n467           if (c != first) {\n468             cc.listSeparator();\n469           }\n470           if (c.isGetterDef() || c.isSetterDef()) {\n471             add(c);\n472           } else {\n473             Preconditions.checkState(c.isStringKey());\n474             String key = c.getString();\n475             if (!c.isQuotedString()\n476                 && !(languageMode == LanguageMode.ECMASCRIPT3\n477                     && TokenStream.isKeyword(key))\n478                 && TokenStream.isJSIdentifier(key)\n479                 && NodeUtil.isLatin(key)) {\n480               add(key);\n481             } else {\n482               double d = getSimpleNumber(key);\n483               if (!Double.isNaN(d)) {\n484                 cc.addNumber(d);\n485               } else {\n486                 addExpr(c, 1, Context.OTHER);\n487               }\n488             }\n489             add(\":\");\n490             addExpr(c.getFirstChild(), 1, Context.OTHER);\n491           }\n492         }\n493         add(\"}\");\n494         if (needsParens) {\n495           add(\")\");\n496         }\n497         break;\n498       }\n499       case Token.SWITCH:\n500         add(\"switch(\");\n501         add(first);\n502         add(\")\");\n503         cc.beginBlock();\n504         addAllSiblings(first.getNext());\n505         cc.endBlock(context == Context.STATEMENT);\n506         break;\n507       case Token.CASE:\n508         Preconditions.checkState(childCount == 2);\n509         add(\"case \");\n510         add(first);\n511         addCaseBody(last);\n512         break;\n513       case Token.DEFAULT_CASE:\n514         Preconditions.checkState(childCount == 1);\n515         add(\"default\");\n516         addCaseBody(first);\n517         break;\n518       case Token.LABEL:\n519         Preconditions.checkState(childCount == 2);\n520         if (!first.isLabelName()) {\n521           throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n522         }\n523         add(first);\n524         add(\":\");\n525         addNonEmptyStatement(\n526             last, getContextForNonEmptyExpression(context), true);\n527         break;\n528       case Token.CAST:\n529         add(\"(\");\n530         add(first);\n531         add(\")\");\n532         break;\n533       default:\n534         throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n535     }\n536     cc.endSourceMapping(n);\n537   }\n", "fixed_code": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = getContextForNoInOperator(context);\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n    cc.startSourceMapping(n);\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n        cc.endStatement(true);\n        break;\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context,\n            getContextForNoInOperator(context), 0, 0);\n        break;\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n        break;\n      }\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        Context rhsContext = getContextForNoInOperator(context);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, rhsContext);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, rhsContext);\n        break;\n      }\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n        add(\"function\");\n        add(first);\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        if (this.languageMode == LanguageMode.ECMASCRIPT3\n            && TokenStream.isKeyword(last.getString())) {\n          add(\"[\");\n          add(last);\n          add(\"]\");\n        } else {\n          add(\".\");\n          addIdentifier(last.getString());\n        }\n        break;\n      }\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n      case Token.CALL:\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n        add(\"if(\");\n        add(first);\n        add(\")\");\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n      case Token.STRING_KEY:\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        addJsString(n);\n        break;\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isStringKey());\n            String key = c.getString();\n            if (!c.isQuotedString()\n                && !(languageMode == LanguageMode.ECMASCRIPT3\n                    && TokenStream.isKeyword(key))\n                && TokenStream.isJSIdentifier(key)\n                && NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n      case Token.CAST:\n        add(\"(\");\n        add(first);\n        add(\")\");\n        break;\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n  }\n"}
{"bug_id": "Math-42", "buggy_code": "1     protected RealPointValuePair getSolution() {\n2       int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n3       Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n4       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n5       Set<Integer> basicRows = new HashSet<Integer>();\n6       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n7       for (int i = 0; i < coefficients.length; i++) {\n8           int colIndex = columnLabels.indexOf(\"x\" + i);\n9           if (colIndex < 0) {\n10             coefficients[i] = 0;\n11             continue;\n12           }\n13           Integer basicRow = getBasicRow(colIndex);\n14           if (basicRows.contains(basicRow)) {\n15               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n16           } else {\n17               basicRows.add(basicRow);\n18               coefficients[i] =\n19                   (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n20                   (restrictToNonNegative ? 0 : mostNegative);\n21           }\n22       }\n23       return new RealPointValuePair(coefficients, f.getValue(coefficients));\n24     }\n", "fixed_code": "    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n          if (basicRow != null && basicRow == 0) {\n              coefficients[i] = 0;\n          } else if (basicRows.contains(basicRow)) {\n              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n          } else {\n              basicRows.add(basicRow);\n              coefficients[i] =\n                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n"}
{"bug_id": "Math-89", "buggy_code": "1     public void addValue(Object v) {\n2             addValue((Comparable<?>) v);            \n3     }\n", "fixed_code": "    public void addValue(Object v) {\n        if (v instanceof Comparable<?>){\n            addValue((Comparable<?>) v);            \n        } else {\n            throw new IllegalArgumentException(\"Object must implement Comparable\");\n        }\n    }\n"}
{"bug_id": "Math-78", "buggy_code": "1     public boolean evaluateStep(final StepInterpolator interpolator)\n2         throws DerivativeException, EventException, ConvergenceException {\n3         try {\n4             forward = interpolator.isForward();\n5             final double t1 = interpolator.getCurrentTime();\n6             final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n7             final double h  = (t1 - t0) / n;\n8             double ta = t0;\n9             double ga = g0;\n10             double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n11             for (int i = 0; i < n; ++i) {\n12                 tb += h;\n13                 interpolator.setInterpolatedTime(tb);\n14                 final double gb = handler.g(tb, interpolator.getInterpolatedState());\n15                 if (g0Positive ^ (gb >= 0)) {\n16                     increasing = gb >= ga;\n17                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n18                         public double value(final double t) throws FunctionEvaluationException {\n19                             try {\n20                                 interpolator.setInterpolatedTime(t);\n21                                 return handler.g(t, interpolator.getInterpolatedState());\n22                             } catch (DerivativeException e) {\n23                                 throw new FunctionEvaluationException(e, t);\n24                             } catch (EventException e) {\n25                                 throw new FunctionEvaluationException(e, t);\n26                             }\n27                         }\n28                     };\n29                     final BrentSolver solver = new BrentSolver();\n30                     solver.setAbsoluteAccuracy(convergence);\n31                     solver.setMaximalIterationCount(maxIterationCount);\n32                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n33                     if ((Math.abs(root - ta) <= convergence) &&\n34                          (Math.abs(root - previousEventTime) <= convergence)) {\n35                         ta = tb;\n36                         ga = gb;\n37                     } else if (Double.isNaN(previousEventTime) ||\n38                                (Math.abs(previousEventTime - root) > convergence)) {\n39                         pendingEventTime = root;\n40                         if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n41                             return false;\n42                         }\n43                         pendingEvent = true;\n44                         return true;\n45                     }\n46                 } else {\n47                     ta = tb;\n48                     ga = gb;\n49                 }\n50             }\n51             pendingEvent     = false;\n52             pendingEventTime = Double.NaN;\n53             return false;\n54         } catch (FunctionEvaluationException e) {\n55             final Throwable cause = e.getCause();\n56             if ((cause != null) && (cause instanceof DerivativeException)) {\n57                 throw (DerivativeException) cause;\n58             } else if ((cause != null) && (cause instanceof EventException)) {\n59                 throw (EventException) cause;\n60             }\n61             throw new EventException(e);\n62         }\n63     }\n", "fixed_code": "    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n        try {\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n            final double h  = (t1 - t0) / n;\n            double ta = t0;\n            double ga = g0;\n            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n            for (int i = 0; i < n; ++i) {\n                tb += h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n                if (g0Positive ^ (gb >= 0)) {\n                    if (ga * gb > 0) {\n                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n                            ta += epsilon;\n                            interpolator.setInterpolatedTime(ta);\n                            ga = handler.g(ta, interpolator.getInterpolatedState());\n                        }\n                        if (ga * gb > 0) {\n                            throw MathRuntimeException.createInternalError(null);\n                        }\n                    }\n                    increasing = gb >= ga;\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                    if ((Math.abs(root - ta) <= convergence) &&\n                         (Math.abs(root - previousEventTime) <= convergence)) {\n                        ta = tb;\n                        ga = gb;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (Math.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                            return false;\n                        }\n                        pendingEvent = true;\n                        return true;\n                    }\n                } else {\n                    ta = tb;\n                    ga = gb;\n                }\n            }\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n        } catch (FunctionEvaluationException e) {\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            }\n            throw new EventException(e);\n        }\n    }\n"}
{"bug_id": "Time-27", "buggy_code": "1     private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n2         if (notPrinter && notParser) {\n3             throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n4         }\n5         int size = elementPairs.size();\n6         if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n7             Separator sep = (Separator) elementPairs.get(0);\n8                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n9                 sep = sep.finish(f.getPrinter(), f.getParser());\n10                 return new PeriodFormatter(sep, sep);\n11         }\n12         Object[] comp = createComposite(elementPairs);\n13         if (notPrinter) {\n14             return new PeriodFormatter(null, (PeriodParser) comp[1]);\n15         } else if (notParser) {\n16             return new PeriodFormatter((PeriodPrinter) comp[0], null);\n17         } else {\n18             return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n19         }\n20     }\n", "fixed_code": "    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        int size = elementPairs.size();\n        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n            Separator sep = (Separator) elementPairs.get(0);\n            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                sep = sep.finish(f.getPrinter(), f.getParser());\n                return new PeriodFormatter(sep, sep);\n            }\n        }\n        Object[] comp = createComposite(elementPairs);\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }\n"}
{"bug_id": "Time-14", "buggy_code": "1     public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n2         if (valueToAdd == 0) {\n3             return values;\n4         }\n5         if (DateTimeUtils.isContiguous(partial)) {\n6             long instant = 0L;\n7             for (int i = 0, isize = partial.size(); i < isize; i++) {\n8                 instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n9             }\n10             instant = add(instant, valueToAdd);\n11             return iChronology.get(partial, instant);\n12         } else {\n13             return super.add(partial, fieldIndex, values, valueToAdd);\n14         }\n15     }\n", "fixed_code": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        if (valueToAdd == 0) {\n            return values;\n        }\n        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n            int curMonth0 = partial.getValue(0) - 1;\n            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n            return set(partial, 0, values, newMonth);\n        }\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }\n"}
{"bug_id": "Chart-23", "buggy_code": "", "fixed_code": "    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof MinMaxCategoryRenderer)) {\n            return false;\n        }\n        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj;\n        if (this.plotLines != that.plotLines) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) {\n            return false;\n        }\n        if (!this.groupStroke.equals(that.groupStroke)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n"}
{"bug_id": "Mockito-33", "buggy_code": "1     public boolean hasSameMethod(Invocation candidate) {        \n2         Method m1 = invocation.getMethod();\n3         Method m2 = candidate.getMethod();\n4         return m1.equals(m2);\n5     }\n", "fixed_code": "    public boolean hasSameMethod(Invocation candidate) {        \n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n        \tClass[] params1 = m1.getParameterTypes();\n        \tClass[] params2 = m2.getParameterTypes();\n        \tif (params1.length == params2.length) {\n        \t    for (int i = 0; i < params1.length; i++) {\n        \t\tif (params1[i] != params2[i])\n        \t\t    return false;\n        \t    }\n        \t    return true;\n        \t}\n        }\n        return false;\n    }\n"}
{"bug_id": "Closure-101", "buggy_code": "1   protected CompilerOptions createOptions() {\n2     CompilerOptions options = new CompilerOptions();\n3     options.setCodingConvention(new ClosureCodingConvention());\n4     CompilationLevel level = flags.compilation_level;\n5     level.setOptionsForCompilationLevel(options);\n6     if (flags.debug) {\n7       level.setDebugOptionsForCompilationLevel(options);\n8     }\n9     WarningLevel wLevel = flags.warning_level;\n10     wLevel.setOptionsForWarningLevel(options);\n11     for (FormattingOption formattingOption : flags.formatting) {\n12       formattingOption.applyToOptions(options);\n13     }\n14     if (flags.process_closure_primitives) {\n15       options.closurePass = true;\n16     }\n17     initOptionsFromFlags(options);\n18     return options;\n19   }\n", "fixed_code": "  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n    options.closurePass = flags.process_closure_primitives;\n    initOptionsFromFlags(options);\n    return options;\n  }\n"}
{"bug_id": "Closure-38", "buggy_code": "1   void addNumber(double x) {\n2     char prev = getLastChar();\n3     boolean negativeZero = isNegativeZero(x);\n4     if (x < 0 && prev == '-') {\n5       add(\" \");\n6     }\n7     if ((long) x == x && !negativeZero) {\n8       long value = (long) x;\n9       long mantissa = value;\n10       int exp = 0;\n11       if (Math.abs(x) >= 100) {\n12         while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n13           mantissa /= 10;\n14           exp++;\n15         }\n16       }\n17       if (exp > 2) {\n18         add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n19       } else {\n20         add(Long.toString(value));\n21       }\n22     } else {\n23       add(String.valueOf(x));\n24     }\n25   }\n", "fixed_code": "  void addNumber(double x) {\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n    if ((x < 0 || negativeZero) && prev == '-') {\n      add(\" \");\n    }\n    if ((long) x == x && !negativeZero) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }\n"}
{"bug_id": "JacksonDatabind-70", "buggy_code": "1     public void remove(SettableBeanProperty propToRm)\n2     {\n3         ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n4         String key = getPropertyName(propToRm);\n5         boolean found = false;\n6         for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n7             SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n8             if (prop == null) {\n9                 continue;\n10             }\n11             if (!found) {\n12                 found = key.equals(prop.getName());\n13                 if (found) {\n14                     _propsInOrder[_findFromOrdered(prop)] = null;\n15                     continue;\n16                 }\n17             }\n18             props.add(prop);\n19         }\n20         if (!found) {\n21             throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n22         }\n23         init(props);\n24     }\n", "fixed_code": "    public void remove(SettableBeanProperty propToRm)\n    {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                found = key.equals(_hashArea[i-1]);\n                if (found) {\n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n            }\n            props.add(prop);\n        }\n        if (!found) {\n            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n        }\n        init(props);\n    }\n"}
{"bug_id": "JacksonDatabind-6", "buggy_code": "1     protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n2     {\n3         int len = dateStr.length();\n4         char c = dateStr.charAt(len-1);\n5         DateFormat df;\n6         if (len <= 10 && Character.isDigit(c)) {\n7             df = _formatPlain;\n8             if (df == null) {\n9                 df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n10             }\n11         } else if (c == 'Z') {\n12             df = _formatISO8601_z;\n13             if (df == null) {\n14                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n15             }\n16             if (dateStr.charAt(len-4) == ':') {\n17                 StringBuilder sb = new StringBuilder(dateStr);\n18                 sb.insert(len-1, \".000\");\n19                 dateStr = sb.toString();\n20             }\n21         } else {\n22             if (hasTimeZone(dateStr)) {\n23                 c = dateStr.charAt(len-3);\n24                 if (c == ':') { \n25                     StringBuilder sb = new StringBuilder(dateStr);\n26                     sb.delete(len-3, len-2);\n27                     dateStr = sb.toString();\n28                 } else if (c == '+' || c == '-') { \n29                     dateStr += \"00\";\n30                 }\n31                 len = dateStr.length();\n32                 c = dateStr.charAt(len-9);\n33                 if (Character.isDigit(c)) {\n34                     StringBuilder sb = new StringBuilder(dateStr);\n35                     sb.insert(len-5, \".000\");\n36                     dateStr = sb.toString();\n37                 }\n38                 df = _formatISO8601;\n39                 if (_formatISO8601 == null) {\n40                     df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n41                 }\n42             } else {\n43                 StringBuilder sb = new StringBuilder(dateStr);\n44                 int timeLen = len - dateStr.lastIndexOf('T') - 1;\n45                 if (timeLen <= 8) {\n46                         sb.append(\".000\");\n47                 }\n48                 sb.append('Z');\n49                 dateStr = sb.toString();\n50                 df = _formatISO8601_z;\n51                 if (df == null) {\n52                     df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n53                             _timezone, _locale);\n54                 }\n55             }\n56         }\n57         return df.parse(dateStr, pos);\n58     }\n", "fixed_code": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { \n                    dateStr += \"00\";\n                }\n                len = dateStr.length();\n                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n                if (timeLen < 12) { \n                    int offset = len - 5; \n                    StringBuilder sb = new StringBuilder(dateStr);\n                    switch (timeLen) {\n                    case 11:\n                        sb.insert(offset, '0'); break;\n                    case 10:\n                        sb.insert(offset, \"00\"); break;\n                    case 9: \n                        sb.insert(offset, \"000\"); break;\n                    case 8:\n                        sb.insert(offset, \".000\"); break;\n                    case 7: \n                        break;\n                    case 6: \n                        sb.insert(offset, \"00.000\");\n                    case 5: \n                        sb.insert(offset, \":00.000\");\n                    }\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else {\n                StringBuilder sb = new StringBuilder(dateStr);\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen < 12) { \n                    switch (timeLen) {\n                    case 11: sb.append('0');\n                    case 10: sb.append('0');\n                    case 9: sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                    }\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }\n"}
{"bug_id": "JacksonDatabind-101", "buggy_code": "1     protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n2         throws IOException\n3     {\n4         final PropertyBasedCreator creator = _propertyBasedCreator;\n5         PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n6         TokenBuffer tokens = new TokenBuffer(p, ctxt);\n7         tokens.writeStartObject();\n8         JsonToken t = p.getCurrentToken();\n9         for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n10             String propName = p.getCurrentName();\n11             p.nextToken(); \n12             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n13             if (creatorProp != null) {\n14                 if (buffer.assignParameter(creatorProp,\n15                         _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n16                     t = p.nextToken(); \n17                     Object bean;\n18                     try {\n19                         bean = creator.build(ctxt, buffer);\n20                     } catch (Exception e) {\n21                         bean = wrapInstantiationProblem(e, ctxt);\n22                     }\n23                     p.setCurrentValue(bean);\n24                     while (t == JsonToken.FIELD_NAME) {\n25                         p.nextToken();\n26                         tokens.copyCurrentStructure(p);\n27                         t = p.nextToken();\n28                     }\n29                     tokens.writeEndObject();\n30                     if (bean.getClass() != _beanType.getRawClass()) {\n31                         ctxt.reportInputMismatch(creatorProp,\n32                                 \"Cannot create polymorphic instances with unwrapped values\");\n33                         return null;\n34                     }\n35                     return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n36                 }\n37                 continue;\n38             }\n39             if (buffer.readIdProperty(propName)) {\n40                 continue;\n41             }\n42             SettableBeanProperty prop = _beanProperties.find(propName);\n43             if (prop != null) {\n44                 buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n45                 continue;\n46             }\n47             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n48                 handleIgnoredProperty(p, ctxt, handledType(), propName);\n49                 continue;\n50             }\n51             if (_anySetter == null) {\n52                 tokens.writeFieldName(propName);\n53                 tokens.copyCurrentStructure(p);\n54             } else {\n55                 TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n56                 tokens.writeFieldName(propName);\n57                 tokens.append(b2);\n58                 try {\n59                     buffer.bufferAnyProperty(_anySetter, propName,\n60                             _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));\n61                 } catch (Exception e) {\n62                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n63                 }\n64                 continue;\n65             }\n66         }\n67         Object bean;\n68         try {\n69             bean = creator.build(ctxt, buffer);\n70         } catch (Exception e) {\n71             wrapInstantiationProblem(e, ctxt);\n72             return null; \n73         }\n74         return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n75     }\n", "fixed_code": "    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); \n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); \n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    p.setCurrentValue(bean);\n                    while (t == JsonToken.FIELD_NAME) {\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    if (t != JsonToken.END_OBJECT) {\n                        ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, \n                                \"Attempted to unwrap '%s' value\",\n                                handledType().getName());\n                    }\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        ctxt.reportInputMismatch(creatorProp,\n                                \"Cannot create polymorphic instances with unwrapped values\");\n                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            if (_anySetter == null) {\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n            } else {\n                TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n                tokens.writeFieldName(propName);\n                tokens.append(b2);\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName,\n                            _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n        }\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; \n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n"}
{"bug_id": "Time-23", "buggy_code": "1     private static synchronized String getConvertedId(String id) {\n2         Map<String, String> map = cZoneIdConversion;\n3         if (map == null) {\n4             map = new HashMap<String, String>();\n5             map.put(\"GMT\", \"UTC\");\n6             map.put(\"MIT\", \"Pacific/Apia\");\n7             map.put(\"HST\", \"Pacific/Honolulu\");  \n8             map.put(\"AST\", \"America/Anchorage\");\n9             map.put(\"PST\", \"America/Los_Angeles\");\n10             map.put(\"MST\", \"America/Denver\");  \n11             map.put(\"PNT\", \"America/Phoenix\");\n12             map.put(\"CST\", \"America/Chicago\");\n13             map.put(\"EST\", \"America/New_York\");  \n14             map.put(\"IET\", \"America/Indianapolis\");\n15             map.put(\"PRT\", \"America/Puerto_Rico\");\n16             map.put(\"CNT\", \"America/St_Johns\");\n17             map.put(\"AGT\", \"America/Buenos_Aires\");\n18             map.put(\"BET\", \"America/Sao_Paulo\");\n19             map.put(\"WET\", \"Europe/London\");\n20             map.put(\"ECT\", \"Europe/Paris\");\n21             map.put(\"ART\", \"Africa/Cairo\");\n22             map.put(\"CAT\", \"Africa/Harare\");\n23             map.put(\"EET\", \"Europe/Bucharest\");\n24             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n25             map.put(\"MET\", \"Asia/Tehran\");\n26             map.put(\"NET\", \"Asia/Yerevan\");\n27             map.put(\"PLT\", \"Asia/Karachi\");\n28             map.put(\"IST\", \"Asia/Calcutta\");\n29             map.put(\"BST\", \"Asia/Dhaka\");\n30             map.put(\"VST\", \"Asia/Saigon\");\n31             map.put(\"CTT\", \"Asia/Shanghai\");\n32             map.put(\"JST\", \"Asia/Tokyo\");\n33             map.put(\"ACT\", \"Australia/Darwin\");\n34             map.put(\"AET\", \"Australia/Sydney\");\n35             map.put(\"SST\", \"Pacific/Guadalcanal\");\n36             map.put(\"NST\", \"Pacific/Auckland\");\n37             cZoneIdConversion = map;\n38         }\n39         return map.get(id);\n40     }\n", "fixed_code": "    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  \n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  \n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  \n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n"}
{"bug_id": "Csv-2", "buggy_code": "1     public String get(final String name) {\n2         if (mapping == null) {\n3             throw new IllegalStateException(\n4                     \"No header mapping was specified, the record values can't be accessed by name\");\n5         }\n6         final Integer index = mapping.get(name);\n7             return index != null ? values[index.intValue()] : null;\n8     }\n", "fixed_code": "    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        try {\n            return index != null ? values[index.intValue()] : null;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(\n                    String.format(\n                            \"Index for header '%s' is %d but CSVRecord only has %d values!\",\n                            name, index.intValue(), values.length));\n        }\n    }\n"}
{"bug_id": "Closure-20", "buggy_code": "1   private Node tryFoldSimpleFunctionCall(Node n) {\n2     Preconditions.checkState(n.isCall());\n3     Node callTarget = n.getFirstChild();\n4     if (callTarget != null && callTarget.isName() &&\n5           callTarget.getString().equals(\"String\")) {\n6       Node value = callTarget.getNext();\n7       if (value != null) {\n8         Node addition = IR.add(\n9             IR.string(\"\").srcref(callTarget),\n10             value.detachFromParent());\n11         n.getParent().replaceChild(n, addition);\n12         reportCodeChange();\n13         return addition;\n14       }\n15     }\n16     return n;\n17   }\n", "fixed_code": "  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      Node value = callTarget.getNext();\n      if (value != null && value.getNext() == null &&\n          NodeUtil.isImmutableValue(value)) {\n        Node addition = IR.add(\n            IR.string(\"\").srcref(callTarget),\n            value.detachFromParent());\n        n.getParent().replaceChild(n, addition);\n        reportCodeChange();\n        return addition;\n      }\n    }\n    return n;\n  }\n"}
{"bug_id": "Compress-45", "buggy_code": "1     public static int formatLongOctalOrBinaryBytes(\n2         final long value, final byte[] buf, final int offset, final int length) {\n3         final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n4         final boolean negative = value < 0;\n5         if (!negative && value <= maxAsOctalChar) { \n6             return formatLongOctalBytes(value, buf, offset, length);\n7         }\n8         if (length < 9) {\n9             formatLongBinary(value, buf, offset, length, negative);\n10         }\n11         formatBigIntegerBinary(value, buf, offset, length, negative);\n12         buf[offset] = (byte) (negative ? 0xff : 0x80);\n13         return offset + length;\n14     }\n", "fixed_code": "    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { \n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        } else {\n            formatBigIntegerBinary(value, buf, offset, length, negative);\n        }\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }\n"}
{"bug_id": "Jsoup-54", "buggy_code": "1         private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n2             for (Attribute attribute : source.attributes()) {\n3                 String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n4                     el.setAttribute(key, attribute.getValue());\n5             }\n6         }\n", "fixed_code": "        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n                if (key.matches(\"[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*\"))\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n"}
{"bug_id": "Compress-11", "buggy_code": "1     public ArchiveInputStream createArchiveInputStream(final InputStream in)\n2             throws ArchiveException {\n3         if (in == null) {\n4             throw new IllegalArgumentException(\"Stream must not be null.\");\n5         }\n6         if (!in.markSupported()) {\n7             throw new IllegalArgumentException(\"Mark is not supported.\");\n8         }\n9         final byte[] signature = new byte[12];\n10         in.mark(signature.length);\n11         try {\n12             int signatureLength = in.read(signature);\n13             in.reset();\n14             if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n15                 return new ZipArchiveInputStream(in);\n16             } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n17                 return new JarArchiveInputStream(in);\n18             } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n19                 return new ArArchiveInputStream(in);\n20             } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n21                 return new CpioArchiveInputStream(in);\n22             }\n23             final byte[] dumpsig = new byte[32];\n24             in.mark(dumpsig.length);\n25             signatureLength = in.read(dumpsig);\n26             in.reset();\n27             if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n28                 return new DumpArchiveInputStream(in);\n29             }\n30             final byte[] tarheader = new byte[512];\n31             in.mark(tarheader.length);\n32             signatureLength = in.read(tarheader);\n33             in.reset();\n34             if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n35                 return new TarArchiveInputStream(in);\n36             }\n37             try {\n38                 TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n39                 tais.getNextEntry();\n40                 return new TarArchiveInputStream(in);\n41             } catch (Exception e) { \n42             }\n43         } catch (IOException e) {\n44             throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n45         }\n46         throw new ArchiveException(\"No Archiver found for the stream signature\");\n47     }\n", "fixed_code": "    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            if (signatureLength >= 512) {\n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                tais.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) { \n            }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n"}
{"bug_id": "JacksonXml-5", "buggy_code": "1     protected XmlSerializerProvider(XmlSerializerProvider src) {\n2         super(src);\n3         _rootNameLookup = src._rootNameLookup;\n4     }\n", "fixed_code": "    protected XmlSerializerProvider(XmlSerializerProvider src) {\n        super(src);\n        _rootNameLookup = new XmlRootNameLookup();\n    }\n"}
{"bug_id": "Csv-15", "buggy_code": "1     private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n2             final Appendable out, final boolean newRecord) throws IOException {\n3         boolean quote = false;\n4         int start = offset;\n5         int pos = offset;\n6         final int end = offset + len;\n7         final char delimChar = getDelimiter();\n8         final char quoteChar = getQuoteCharacter().charValue();\n9         QuoteMode quoteModePolicy = getQuoteMode();\n10         if (quoteModePolicy == null) {\n11             quoteModePolicy = QuoteMode.MINIMAL;\n12         }\n13         switch (quoteModePolicy) {\n14         case ALL:\n15         case ALL_NON_NULL:\n16             quote = true;\n17             break;\n18         case NON_NUMERIC:\n19             quote = !(object instanceof Number);\n20             break;\n21         case NONE:\n22             printAndEscape(value, offset, len, out);\n23             return;\n24         case MINIMAL:\n25             if (len <= 0) {\n26                 if (newRecord) {\n27                     quote = true;\n28                 }\n29             } else {\n30                 char c = value.charAt(pos);\n31                 if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n32                     quote = true;\n33                 } else if (c <= COMMENT) {\n34                     quote = true;\n35                 } else {\n36                     while (pos < end) {\n37                         c = value.charAt(pos);\n38                         if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n39                             quote = true;\n40                             break;\n41                         }\n42                         pos++;\n43                     }\n44                     if (!quote) {\n45                         pos = end - 1;\n46                         c = value.charAt(pos);\n47                         if (c <= SP) {\n48                             quote = true;\n49                         }\n50                     }\n51                 }\n52             }\n53             if (!quote) {\n54                 out.append(value, start, end);\n55                 return;\n56             }\n57             break;\n58         default:\n59             throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n60         }\n61         if (!quote) {\n62             out.append(value, start, end);\n63             return;\n64         }\n65         out.append(quoteChar);\n66         while (pos < end) {\n67             final char c = value.charAt(pos);\n68             if (c == quoteChar) {\n69                 out.append(value, start, pos + 1);\n70                 start = pos;\n71             }\n72             pos++;\n73         }\n74         out.append(value, start, pos);\n75         out.append(quoteChar);\n76     }\n", "fixed_code": "    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n                if (c <= COMMENT) {\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n        out.append(quoteChar);\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(value, start, pos + 1);\n                start = pos;\n            }\n            pos++;\n        }\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n"}
{"bug_id": "Chart-6", "buggy_code": "1     public boolean equals(Object obj) {\n2         if (obj == this) {\n3             return true;\n4         }\n5         if (!(obj instanceof ShapeList)) {\n6             return false;\n7         }\n8         return super.equals(obj);\n9     }\n", "fixed_code": "    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ShapeList)) {\n            return false;\n        }\n        ShapeList that = (ShapeList) obj;\n        int listSize = size();\n        for (int i = 0; i < listSize; i++) {\n           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {\n               return false;\n           }\n        }\n        return true;\n    }\n"}
{"bug_id": "Mockito-34", "buggy_code": "1     public void captureArgumentsFrom(Invocation i) {\n2         int k = 0;\n3         for (Matcher m : matchers) {\n4             if (m instanceof CapturesArguments) {\n5                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n6             }\n7             k++;\n8         }\n9     }\n", "fixed_code": "    public void captureArgumentsFrom(Invocation i) {\n        int k = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n            }\n            k++;\n        }\n    }\n"}
{"bug_id": "Math-34", "buggy_code": "1     public Iterator<Chromosome> iterator() {\n2         return chromosomes.iterator();\n3     }\n", "fixed_code": "    public Iterator<Chromosome> iterator() {\n        return getChromosomes().iterator();\n    }\n"}
{"bug_id": "Closure-44", "buggy_code": "1   void add(String newcode) {\n2     maybeEndStatement();\n3     if (newcode.length() == 0) {\n4       return;\n5     }\n6     char c = newcode.charAt(0);\n7     if ((isWordChar(c) || c == '\\\\') &&\n8         isWordChar(getLastChar())) {\n9       append(\" \");\n10     }\n11     append(newcode);\n12   }\n", "fixed_code": "  void add(String newcode) {\n    maybeEndStatement();\n    if (newcode.length() == 0) {\n      return;\n    }\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') &&\n        isWordChar(getLastChar())) {\n      append(\" \");\n    } else if (c == '/' && getLastChar() == '/') {\n      append(\" \");\n    }\n    append(newcode);\n  }\n"}
{"bug_id": "Compress-25", "buggy_code": "1     public ZipArchiveInputStream(InputStream inputStream,\n2                                  String encoding,\n3                                  boolean useUnicodeExtraFields,\n4                                  boolean allowStoredEntriesWithDataDescriptor) {\n5         zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n6         this.useUnicodeExtraFields = useUnicodeExtraFields;\n7         in = new PushbackInputStream(inputStream, buf.capacity());\n8         this.allowStoredEntriesWithDataDescriptor =\n9             allowStoredEntriesWithDataDescriptor;\n10     }\n", "fixed_code": "    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        buf.limit(0);\n    }\n"}
{"bug_id": "Closure-52", "buggy_code": "1   static boolean isSimpleNumber(String s) {\n2     int len = s.length();\n3     for (int index = 0; index < len; index++) {\n4       char c = s.charAt(index);\n5       if (c < '0' || c > '9') {\n6         return false;\n7       }\n8     }\n9     return len > 0;\n10   }\n", "fixed_code": "  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len > 0 && s.charAt(0) != '0';\n  }\n"}
{"bug_id": "Closure-14", "buggy_code": "1   private static Node computeFollowNode(\n2       Node fromNode, Node node, ControlFlowAnalysis cfa) {\n3     Node parent = node.getParent();\n4     if (parent == null || parent.isFunction() ||\n5         (cfa != null && node == cfa.root)) {\n6       return null;\n7     }\n8     switch (parent.getType()) {\n9       case Token.IF:\n10         return computeFollowNode(fromNode, parent, cfa);\n11       case Token.CASE:\n12       case Token.DEFAULT_CASE:\n13         if (parent.getNext() != null) {\n14           if (parent.getNext().isCase()) {\n15             return parent.getNext().getFirstChild().getNext();\n16           } else if (parent.getNext().isDefaultCase()) {\n17             return parent.getNext().getFirstChild();\n18           } else {\n19             Preconditions.checkState(false, \"Not reachable\");\n20           }\n21         } else {\n22           return computeFollowNode(fromNode, parent, cfa);\n23         }\n24         break;\n25       case Token.FOR:\n26         if (NodeUtil.isForIn(parent)) {\n27           return parent;\n28         } else {\n29           return parent.getFirstChild().getNext().getNext();\n30         }\n31       case Token.WHILE:\n32       case Token.DO:\n33         return parent;\n34       case Token.TRY:\n35         if (parent.getFirstChild() == node) {\n36           if (NodeUtil.hasFinally(parent)) { \n37             return computeFallThrough(parent.getLastChild());\n38           } else { \n39             return computeFollowNode(fromNode, parent, cfa);\n40           }\n41         } else if (NodeUtil.getCatchBlock(parent) == node){\n42           if (NodeUtil.hasFinally(parent)) { \n43             return computeFallThrough(node.getNext());\n44           } else {\n45             return computeFollowNode(fromNode, parent, cfa);\n46           }\n47         } else if (parent.getLastChild() == node){\n48           if (cfa != null) {\n49             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n50               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n51             }\n52           }\n53           return computeFollowNode(fromNode, parent, cfa);\n54         }\n55     }\n56     Node nextSibling = node.getNext();\n57     while (nextSibling != null && nextSibling.isFunction()) {\n58       nextSibling = nextSibling.getNext();\n59     }\n60     if (nextSibling != null) {\n61       return computeFallThrough(nextSibling);\n62     } else {\n63       return computeFollowNode(fromNode, parent, cfa);\n64     }\n65   }\n", "fixed_code": "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n    switch (parent.getType()) {\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(parent.getLastChild());\n          } else { \n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { \n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n"}
{"bug_id": "Math-56", "buggy_code": "1     public int[] getCounts(int index) {\n2         if (index < 0 ||\n3             index >= totalSize) {\n4             throw new OutOfRangeException(index, 0, totalSize);\n5         }\n6         final int[] indices = new int[dimension];\n7         int count = 0;\n8         for (int i = 0; i < last; i++) {\n9             int idx = 0;\n10             final int offset = uniCounterOffset[i];\n11             while (count <= index) {\n12                 count += offset;\n13                 ++idx;\n14             }\n15             --idx;\n16             count -= offset;\n17             indices[i] = idx;\n18         }\n19         int idx = 1;\n20         while (count < index) {\n21             count += idx;\n22             ++idx;\n23         }\n24         --idx;\n25         indices[last] = idx;\n26         return indices;\n27     }\n", "fixed_code": "    public int[] getCounts(int index) {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n        final int[] indices = new int[dimension];\n        int count = 0;\n        for (int i = 0; i < last; i++) {\n            int idx = 0;\n            final int offset = uniCounterOffset[i];\n            while (count <= index) {\n                count += offset;\n                ++idx;\n            }\n            --idx;\n            count -= offset;\n            indices[i] = idx;\n        }\n        indices[last] = index - count;\n        return indices;\n    }\n"}
{"bug_id": "Math-79", "buggy_code": "1     public static double distance(int[] p1, int[] p2) {\n2       int sum = 0;\n3       for (int i = 0; i < p1.length; i++) {\n4           final int dp = p1[i] - p2[i];\n5           sum += dp * dp;\n6       }\n7       return Math.sqrt(sum);\n8     }\n", "fixed_code": "    public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }\n"}
{"bug_id": "Jsoup-53", "buggy_code": "1     public String chompBalanced(char open, char close) {\n2         int start = -1;\n3         int end = -1;\n4         int depth = 0;\n5         char last = 0;\n6         do {\n7             if (isEmpty()) break;\n8             Character c = consume();\n9             if (last == 0 || last != ESC) {\n10                 if (c.equals(open)) {\n11                     depth++;\n12                     if (start == -1)\n13                         start = pos;\n14                 }\n15                 else if (c.equals(close))\n16                     depth--;\n17             }\n18             if (depth > 0 && last != 0)\n19                 end = pos; \n20             last = c;\n21         } while (depth > 0);\n22         return (end >= 0) ? queue.substring(start, end) : \"\";\n23     }\n", "fixed_code": "    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inQuote = false;\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if (c.equals('\\'') || c.equals('\"') && c != open)\n                    inQuote = !inQuote;\n                if (inQuote)\n                    continue;\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n            if (depth > 0 && last != 0)\n                end = pos; \n            last = c;\n        } while (depth > 0);\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }\n"}
{"bug_id": "Closure-92", "buggy_code": "1     void replace() {\n2       if (firstNode == null) {\n3         replacementNode = candidateDefinition;\n4         return;\n5       }\n6       if (candidateDefinition != null && explicitNode != null) {\n7         explicitNode.detachFromParent();\n8         compiler.reportCodeChange();\n9         replacementNode = candidateDefinition;\n10         if (NodeUtil.isExpressionNode(candidateDefinition)) {\n11           candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n12           Node assignNode = candidateDefinition.getFirstChild();\n13           Node nameNode = assignNode.getFirstChild();\n14           if (nameNode.getType() == Token.NAME) {\n15             Node valueNode = nameNode.getNext();\n16             assignNode.removeChild(nameNode);\n17             assignNode.removeChild(valueNode);\n18             nameNode.addChildToFront(valueNode);\n19             Node varNode = new Node(Token.VAR, nameNode);\n20             varNode.copyInformationFrom(candidateDefinition);\n21             candidateDefinition.getParent().replaceChild(\n22                 candidateDefinition, varNode);\n23             nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n24             compiler.reportCodeChange();\n25             replacementNode = varNode;\n26           }\n27         }\n28       } else {\n29         replacementNode = createDeclarationNode();\n30         if (firstModule == minimumModule) {\n31           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n32         } else {\n33           int indexOfDot = namespace.indexOf('.');\n34           if (indexOfDot == -1) {\n35             compiler.getNodeForCodeInsertion(minimumModule)\n36                 .addChildToBack(replacementNode);\n37           } else {\n38             ProvidedName parentName =\n39                 providedNames.get(namespace.substring(0, indexOfDot));\n40             Preconditions.checkNotNull(parentName);\n41             Preconditions.checkNotNull(parentName.replacementNode);\n42             parentName.replacementNode.getParent().addChildAfter(\n43                 replacementNode, parentName.replacementNode);\n44           }\n45         }\n46         if (explicitNode != null) {\n47           explicitNode.detachFromParent();\n48         }\n49         compiler.reportCodeChange();\n50       }\n51     }\n", "fixed_code": "    void replace() {\n      if (firstNode == null) {\n        replacementNode = candidateDefinition;\n        return;\n      }\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          int indexOfDot = namespace.lastIndexOf('.');\n          if (indexOfDot == -1) {\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"}
{"bug_id": "Compress-10", "buggy_code": "1     private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n2                                             entriesWithoutUTF8Flag)\n3         throws IOException {\n4         for (ZipArchiveEntry ze : entries.keySet()) {\n5             OffsetEntry offsetEntry = entries.get(ze);\n6             long offset = offsetEntry.headerOffset;\n7             archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n8             byte[] b = new byte[SHORT];\n9             archive.readFully(b);\n10             int fileNameLen = ZipShort.getValue(b);\n11             archive.readFully(b);\n12             int extraFieldLen = ZipShort.getValue(b);\n13             int lenToSkip = fileNameLen;\n14             while (lenToSkip > 0) {\n15                 int skipped = archive.skipBytes(lenToSkip);\n16                 if (skipped <= 0) {\n17                     throw new RuntimeException(\"failed to skip file name in\"\n18                                                + \" local file header\");\n19                 }\n20                 lenToSkip -= skipped;\n21             }\n22             byte[] localExtraData = new byte[extraFieldLen];\n23             archive.readFully(localExtraData);\n24             ze.setExtra(localExtraData);\n25             offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n26                 + SHORT + SHORT + fileNameLen + extraFieldLen;\n27             if (entriesWithoutUTF8Flag.containsKey(ze)) {\n28                 String orig = ze.getName();\n29                 NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n30                 ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n31                                                          nc.comment);\n32                 if (!orig.equals(ze.getName())) {\n33                     nameMap.remove(orig);\n34                     nameMap.put(ze.getName(), ze);\n35                 }\n36             }\n37         }\n38     }\n", "fixed_code": "    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        Map<ZipArchiveEntry, OffsetEntry> origMap =\n            new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);\n        entries.clear();\n        for (ZipArchiveEntry ze : origMap.keySet()) {\n            OffsetEntry offsetEntry = origMap.get(ze);\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip file name in\"\n                                               + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData);\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n            entries.put(ze, offsetEntry);\n        }\n    }\n"}
{"bug_id": "Closure-121", "buggy_code": "1     private void inlineNonConstants(\n2         Var v, ReferenceCollection referenceInfo,\n3         boolean maybeModifiedArguments) {\n4       int refCount = referenceInfo.references.size();\n5       Reference declaration = referenceInfo.references.get(0);\n6       Reference init = referenceInfo.getInitializingReference();\n7       int firstRefAfterInit = (declaration == init) ? 2 : 3;\n8       if (refCount > 1 &&\n9           isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n10         Node value;\n11         if (init != null) {\n12           value = init.getAssignedValue();\n13         } else {\n14           Node srcLocation = declaration.getNode();\n15           value = NodeUtil.newUndefinedNode(srcLocation);\n16         }\n17         Preconditions.checkNotNull(value);\n18         inlineWellDefinedVariable(v, value, referenceInfo.references);\n19         staleVars.add(v);\n20       } else if (refCount == firstRefAfterInit) {\n21         Reference reference = referenceInfo.references.get(\n22             firstRefAfterInit - 1);\n23         if (canInline(declaration, init, reference)) {\n24           inline(v, declaration, init, reference);\n25           staleVars.add(v);\n26         }\n27       } else if (declaration != init && refCount == 2) {\n28         if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n29           Node value = init.getAssignedValue();\n30           Preconditions.checkNotNull(value);\n31           inlineWellDefinedVariable(v, value, referenceInfo.references);\n32           staleVars.add(v);\n33         }\n34       }\n35       if (!maybeModifiedArguments &&\n36           !staleVars.contains(v) &&\n37           referenceInfo.isWellDefined() &&\n38           referenceInfo.isAssignedOnceInLifetime()) {\n39         List<Reference> refs = referenceInfo.references;\n40         for (int i = 1 ; i < refs.size(); i++) {\n41           Node nameNode = refs.get(i).getNode();\n42           if (aliasCandidates.containsKey(nameNode)) {\n43             AliasCandidate candidate = aliasCandidates.get(nameNode);\n44             if (!staleVars.contains(candidate.alias) &&\n45                 !isVarInlineForbidden(candidate.alias)) {\n46               Reference aliasInit;\n47               aliasInit = candidate.refInfo.getInitializingReference();\n48               Node value = aliasInit.getAssignedValue();\n49               Preconditions.checkNotNull(value);\n50               inlineWellDefinedVariable(candidate.alias,\n51                   value,\n52                   candidate.refInfo.references);\n53               staleVars.add(candidate.alias);\n54             }\n55           }\n56         }\n57       }\n58     }\n", "fixed_code": "    private void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo,\n        boolean maybeModifiedArguments) {\n      int refCount = referenceInfo.references.size();\n      Reference declaration = referenceInfo.references.get(0);\n      Reference init = referenceInfo.getInitializingReference();\n      int firstRefAfterInit = (declaration == init) ? 2 : 3;\n      if (refCount > 1 &&\n          isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        Node value;\n        if (init != null) {\n          value = init.getAssignedValue();\n        } else {\n          Node srcLocation = declaration.getNode();\n          value = NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n      } else if (refCount == firstRefAfterInit) {\n        Reference reference = referenceInfo.references.get(\n            firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n          inline(v, declaration, init, reference);\n          staleVars.add(v);\n        }\n      } else if (declaration != init && refCount == 2) {\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n          Node value = init.getAssignedValue();\n          Preconditions.checkNotNull(value);\n          inlineWellDefinedVariable(v, value, referenceInfo.references);\n          staleVars.add(v);\n        }\n      }\n      if (!maybeModifiedArguments &&\n          !staleVars.contains(v) &&\n          referenceInfo.isWellDefined() &&\n          referenceInfo.isAssignedOnceInLifetime() &&\n          (isInlineableDeclaredConstant(v, referenceInfo) ||\n           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {\n        List<Reference> refs = referenceInfo.references;\n        for (int i = 1 ; i < refs.size(); i++) {\n          Node nameNode = refs.get(i).getNode();\n          if (aliasCandidates.containsKey(nameNode)) {\n            AliasCandidate candidate = aliasCandidates.get(nameNode);\n            if (!staleVars.contains(candidate.alias) &&\n                !isVarInlineForbidden(candidate.alias)) {\n              Reference aliasInit;\n              aliasInit = candidate.refInfo.getInitializingReference();\n              Node value = aliasInit.getAssignedValue();\n              Preconditions.checkNotNull(value);\n              inlineWellDefinedVariable(candidate.alias,\n                  value,\n                  candidate.refInfo.references);\n              staleVars.add(candidate.alias);\n            }\n          }\n        }\n      }\n    }\n"}
{"bug_id": "Jsoup-59", "buggy_code": "1         final void newAttribute() {\n2             if (attributes == null)\n3                 attributes = new Attributes();\n4             if (pendingAttributeName != null) {\n5                 pendingAttributeName = pendingAttributeName.trim();\n6                     Attribute attribute;\n7                     if (hasPendingAttributeValue)\n8                         attribute = new Attribute(pendingAttributeName,\n9                             pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n10                     else if (hasEmptyAttributeValue)\n11                         attribute = new Attribute(pendingAttributeName, \"\");\n12                     else\n13                         attribute = new BooleanAttribute(pendingAttributeName);\n14                     attributes.put(attribute);\n15             }\n16             pendingAttributeName = null;\n17             hasEmptyAttributeValue = false;\n18             hasPendingAttributeValue = false;\n19             reset(pendingAttributeValue);\n20             pendingAttributeValueS = null;\n21         }\n", "fixed_code": "        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n            if (pendingAttributeName != null) {\n                pendingAttributeName = pendingAttributeName.trim();\n                if (pendingAttributeName.length() > 0) {\n                    Attribute attribute;\n                    if (hasPendingAttributeValue)\n                        attribute = new Attribute(pendingAttributeName,\n                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n                    else if (hasEmptyAttributeValue)\n                        attribute = new Attribute(pendingAttributeName, \"\");\n                    else\n                        attribute = new BooleanAttribute(pendingAttributeName);\n                    attributes.put(attribute);\n                }\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }\n"}
{"bug_id": "Lang-28", "buggy_code": "1     public int translate(CharSequence input, int index, Writer out) throws IOException {\n2         if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n3             int start = index + 2;\n4             boolean isHex = false;\n5             char firstChar = input.charAt(start);\n6             if(firstChar == 'x' || firstChar == 'X') {\n7                 start++;\n8                 isHex = true;\n9             }\n10             int end = start;\n11             while(input.charAt(end) != ';') {\n12                 end++;\n13             }\n14             int entityValue;\n15             try {\n16                 if(isHex) {\n17                     entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n18                 } else {\n19                     entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n20                 }\n21             } catch(NumberFormatException nfe) {\n22                 return 0;\n23             }\n24                 out.write(entityValue);\n25             return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n26         }\n27         return 0;\n28     }\n", "fixed_code": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n            }\n            int end = start;\n            while(input.charAt(end) != ';') {\n                end++;\n            }\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n                return 0;\n            }\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }\n"}
{"bug_id": "Math-87", "buggy_code": "1     private Integer getBasicRow(final int col) {\n2         Integer row = null;\n3         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n4             if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n5                 if (row == null) {\n6                 row = i;\n7                 } else {\n8                 return null;\n9                 }\n10             }\n11         }\n12         return row;\n13     }\n", "fixed_code": "    private Integer getBasicRow(final int col) {\n        Integer row = null;\n        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                row = i;\n            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                return null;\n            }\n        }\n        return row;\n    }\n"}
{"bug_id": "JacksonCore-23", "buggy_code": "1     public DefaultPrettyPrinter createInstance() {\n2         return new DefaultPrettyPrinter(this);\n3     }\n", "fixed_code": "    public DefaultPrettyPrinter createInstance() {\n        if (getClass() != DefaultPrettyPrinter.class) { \n            throw new IllegalStateException(\"Failed `createInstance()`: \"+getClass().getName()\n                    +\" does not override method; it has to\");\n        }\n        return new DefaultPrettyPrinter(this);\n    }\n"}
{"bug_id": "Closure-122", "buggy_code": "1   private void handleBlockComment(Comment comment) {\n2     if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n3       errorReporter.warning(\n4           SUSPICIOUS_COMMENT_WARNING,\n5           sourceName,\n6           comment.getLineno(), \"\", 0);\n7     }\n8   }\n", "fixed_code": "  private void handleBlockComment(Comment comment) {\n    Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\");\n    if (p.matcher(comment.getValue()).find()) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n  }\n"}
{"bug_id": "JacksonDatabind-8", "buggy_code": "1     protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n2     {\n3         final int mask = (1 << typeIndex);\n4         _hasNonDefaultCreator = true;\n5         AnnotatedWithParams oldOne = _creators[typeIndex];\n6         if (oldOne != null) {\n7             if ((_explicitCreators & mask) != 0) { \n8                 if (!explicit) {\n9                     return;\n10                 }\n11             }\n12             if (oldOne.getClass() == newOne.getClass()) {\n13                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n14                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n15             }\n16         }\n17         if (explicit) {\n18             _explicitCreators |= mask;\n19         }\n20         _creators[typeIndex] = _fixAccess(newOne);\n21     }\n", "fixed_code": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        if (oldOne != null) {\n            boolean verify;\n            if ((_explicitCreators & mask) != 0) { \n                if (!explicit) {\n                    return;\n                }\n                verify = true;\n            } else {\n                verify = !explicit;\n            }\n            if (verify && (oldOne.getClass() == newOne.getClass())) {\n                Class<?> oldType = oldOne.getRawParameterType(0);\n                Class<?> newType = newOne.getRawParameterType(0);\n                if (oldType == newType) {\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                }\n                if (newType.isAssignableFrom(oldType)) {\n                    return;\n                }\n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }\n"}
{"bug_id": "JacksonDatabind-49", "buggy_code": "1     public Object generateId(Object forPojo) {\n2             id = generator.generateId(forPojo);\n3         return id;\n4     }\n", "fixed_code": "    public Object generateId(Object forPojo) {\n        if (id == null) {\n            id = generator.generateId(forPojo);\n        }\n        return id;\n    }\n"}
{"bug_id": "Jsoup-6", "buggy_code": "1     static String unescape(String string) {\n2         if (!string.contains(\"&\"))\n3             return string;\n4         Matcher m = unescapePattern.matcher(string); \n5         StringBuffer accum = new StringBuffer(string.length()); \n6         while (m.find()) {\n7             int charval = -1;\n8             String num = m.group(3);\n9             if (num != null) {\n10                 try {\n11                     int base = m.group(2) != null ? 16 : 10; \n12                     charval = Integer.valueOf(num, base);\n13                 } catch (NumberFormatException e) {\n14                 } \n15             } else {\n16                 String name = m.group(1);\n17                 if (full.containsKey(name))\n18                     charval = full.get(name);\n19             }\n20             if (charval != -1 || charval > 0xFFFF) { \n21                 String c = Character.toString((char) charval);\n22                 m.appendReplacement(accum, c);\n23             } else {\n24                 m.appendReplacement(accum, m.group(0));\n25             }\n26         }\n27         m.appendTail(accum);\n28         return accum.toString();\n29     }\n", "fixed_code": "    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n        Matcher m = unescapePattern.matcher(string); \n        StringBuffer accum = new StringBuffer(string.length()); \n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3);\n            if (num != null) {\n                try {\n                    int base = m.group(2) != null ? 16 : 10; \n                    charval = Integer.valueOf(num, base);\n                } catch (NumberFormatException e) {\n                } \n            } else {\n                String name = m.group(1);\n                if (full.containsKey(name))\n                    charval = full.get(name);\n            }\n            if (charval != -1 || charval > 0xFFFF) { \n                String c = Character.toString((char) charval);\n                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n            } else {\n                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); \n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }\n"}
{"bug_id": "Cli-12", "buggy_code": "1     protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n2     {\n3         List tokens = new ArrayList();\n4         boolean eatTheRest = false;\n5         for (int i = 0; i < arguments.length; i++)\n6         {\n7             String arg = arguments[i];\n8             if (\"--\".equals(arg))\n9             {\n10                 eatTheRest = true;\n11                 tokens.add(\"--\");\n12             }\n13             else if (\"-\".equals(arg))\n14             {\n15                 tokens.add(\"-\");\n16             }\n17             else if (arg.startsWith(\"-\"))\n18             {\n19                 String opt = Util.stripLeadingHyphens(arg);\n20                 if (options.hasOption(opt))\n21                 {\n22                     tokens.add(arg);\n23                 }\n24                 else\n25                 {\n26                     if (options.hasOption(arg.substring(0, 2)))\n27                     {\n28                         tokens.add(arg.substring(0, 2)); \n29                         tokens.add(arg.substring(2)); \n30                     }\n31                     else\n32                     {\n33                         eatTheRest = stopAtNonOption;\n34                         tokens.add(arg);\n35                     }\n36                 }\n37             }\n38             else\n39             {\n40                 tokens.add(arg);\n41             }\n42             if (eatTheRest)\n43             {\n44                 for (i++; i < arguments.length; i++)\n45                 {\n46                     tokens.add(arguments[i]);\n47                 }\n48             }\n49         }\n50         return (String[]) tokens.toArray(new String[tokens.size()]);\n51     }\n", "fixed_code": "    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        List tokens = new ArrayList();\n        boolean eatTheRest = false;\n        for (int i = 0; i < arguments.length; i++)\n        {\n            String arg = arguments[i];\n            if (\"--\".equals(arg))\n            {\n                eatTheRest = true;\n                tokens.add(\"--\");\n            }\n            else if (\"-\".equals(arg))\n            {\n                tokens.add(\"-\");\n            }\n            else if (arg.startsWith(\"-\"))\n            {\n                String opt = Util.stripLeadingHyphens(arg);\n                if (options.hasOption(opt))\n                {\n                    tokens.add(arg);\n                }\n                else\n                {\n                    if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('='))))\n                    {\n                        tokens.add(arg.substring(0, arg.indexOf('='))); \n                        tokens.add(arg.substring(arg.indexOf('=') + 1)); \n                    }\n                    else if (options.hasOption(arg.substring(0, 2)))\n                    {\n                        tokens.add(arg.substring(0, 2)); \n                        tokens.add(arg.substring(2)); \n                    }\n                    else\n                    {\n                        eatTheRest = stopAtNonOption;\n                        tokens.add(arg);\n                    }\n                }\n            }\n            else\n            {\n                tokens.add(arg);\n            }\n            if (eatTheRest)\n            {\n                for (i++; i < arguments.length; i++)\n                {\n                    tokens.add(arguments[i]);\n                }\n            }\n        }\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n"}
{"bug_id": "Codec-5", "buggy_code": "1     void decode(byte[] in, int inPos, int inAvail) {\n2         if (eof) {\n3             return;\n4         }\n5         if (inAvail < 0) {\n6             eof = true;\n7         }\n8         for (int i = 0; i < inAvail; i++) {\n9             if (buffer == null || buffer.length - pos < decodeSize) {\n10                 resizeBuffer();\n11             }\n12             byte b = in[inPos++];\n13             if (b == PAD) {\n14                 eof = true;\n15                 break;\n16             } else {\n17                 if (b >= 0 && b < DECODE_TABLE.length) {\n18                     int result = DECODE_TABLE[b];\n19                     if (result >= 0) {\n20                         modulus = (++modulus) % 4;\n21                         x = (x << 6) + result;\n22                         if (modulus == 0) {\n23                             buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n24                             buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n25                             buffer[pos++] = (byte) (x & MASK_8BITS);\n26                         }\n27                     }\n28                 }\n29             }\n30         }\n31         if (eof && modulus != 0) {\n32             x = x << 6;\n33             switch (modulus) {\n34                 case 2 :\n35                     x = x << 6;\n36                     buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n37                     break;\n38                 case 3 :\n39                     buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n40                     buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n41                     break;\n42             }\n43         }\n44     }\n", "fixed_code": "    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n        if (eof && modulus != 0) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n"}
{"bug_id": "Chart-26", "buggy_code": "1     protected AxisState drawLabel(String label, Graphics2D g2, \n2             Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n3             AxisState state, PlotRenderingInfo plotState) {\n4         if (state == null) {\n5             throw new IllegalArgumentException(\"Null 'state' argument.\");\n6         }\n7         if ((label == null) || (label.equals(\"\"))) {\n8             return state;\n9         }\n10         Font font = getLabelFont();\n11         RectangleInsets insets = getLabelInsets();\n12         g2.setFont(font);\n13         g2.setPaint(getLabelPaint());\n14         FontMetrics fm = g2.getFontMetrics();\n15         Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n16         Shape hotspot = null;\n17         if (edge == RectangleEdge.TOP) {\n18             AffineTransform t = AffineTransform.getRotateInstance(\n19                     getLabelAngle(), labelBounds.getCenterX(), \n20                     labelBounds.getCenterY());\n21             Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n22             labelBounds = rotatedLabelBounds.getBounds2D();\n23             float w = (float) labelBounds.getWidth();\n24             float h = (float) labelBounds.getHeight();\n25             float labelx = (float) dataArea.getCenterX();\n26             float labely = (float) (state.getCursor() - insets.getBottom() \n27                     - h / 2.0);\n28             TextUtilities.drawRotatedString(label, g2, labelx, labely, \n29                     TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n30             hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n31                     labely - h / 2.0f, w, h);\n32             state.cursorUp(insets.getTop() + labelBounds.getHeight() \n33                     + insets.getBottom());\n34         }\n35         else if (edge == RectangleEdge.BOTTOM) {\n36             AffineTransform t = AffineTransform.getRotateInstance(\n37                     getLabelAngle(), labelBounds.getCenterX(), \n38                     labelBounds.getCenterY());\n39             Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n40             labelBounds = rotatedLabelBounds.getBounds2D();\n41             float w = (float) labelBounds.getWidth();\n42             float h = (float) labelBounds.getHeight();\n43             float labelx = (float) dataArea.getCenterX();\n44             float labely = (float) (state.getCursor() + insets.getTop() \n45                     + h / 2.0);\n46             TextUtilities.drawRotatedString(label, g2, labelx, labely, \n47                     TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n48             hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n49                     labely - h / 2.0f, w, h);\n50             state.cursorDown(insets.getTop() + labelBounds.getHeight() \n51                     + insets.getBottom());\n52         }\n53         else if (edge == RectangleEdge.LEFT) {\n54             AffineTransform t = AffineTransform.getRotateInstance(\n55                     getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n56                     labelBounds.getCenterY());\n57             Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n58             labelBounds = rotatedLabelBounds.getBounds2D();\n59             float w = (float) labelBounds.getWidth();\n60             float h = (float) labelBounds.getHeight();\n61             float labelx = (float) (state.getCursor() - insets.getRight() \n62                     - w / 2.0);\n63             float labely = (float) dataArea.getCenterY();\n64             TextUtilities.drawRotatedString(label, g2, labelx, labely, \n65                     TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n66                     TextAnchor.CENTER);\n67             hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n68                     labely - h / 2.0f, w, h);\n69             state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n70                     + insets.getRight());\n71         }\n72         else if (edge == RectangleEdge.RIGHT) {\n73             AffineTransform t = AffineTransform.getRotateInstance(\n74                     getLabelAngle() + Math.PI / 2.0, \n75                     labelBounds.getCenterX(), labelBounds.getCenterY());\n76             Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n77             labelBounds = rotatedLabelBounds.getBounds2D();\n78             float w = (float) labelBounds.getWidth();\n79             float h = (float) labelBounds.getHeight();\n80             float labelx = (float) (state.getCursor() \n81                             + insets.getLeft() + w / 2.0);\n82             float labely = (float) (dataArea.getY() + dataArea.getHeight() \n83                     / 2.0);\n84             TextUtilities.drawRotatedString(label, g2, labelx, labely, \n85                     TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n86                     TextAnchor.CENTER);\n87             hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n88                     labely - h / 2.0f, w, h);\n89             state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n90                     + insets.getRight());\n91         }\n92         if (plotState != null && hotspot != null) {\n93             ChartRenderingInfo owner = plotState.getOwner();\n94                 EntityCollection entities = owner.getEntityCollection();\n95                 if (entities != null) {\n96                     entities.add(new AxisLabelEntity(this, hotspot, \n97                             this.labelToolTip, this.labelURL));\n98                 }\n99         }\n100         return state;\n101     }\n", "fixed_code": "    protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n            if (owner != null) {\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n            }\n        }\n        return state;\n    }\n"}
{"bug_id": "Math-105", "buggy_code": "1     public double getSumSquaredErrors() {\n2         return sumYY - sumXY * sumXY / sumXX;\n3     }\n", "fixed_code": "    public double getSumSquaredErrors() {\n        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n    }\n"}
{"bug_id": "Time-18", "buggy_code": "1     public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n2                                   int hourOfDay, int minuteOfHour,\n3                                   int secondOfMinute, int millisOfSecond)\n4         throws IllegalArgumentException\n5     {\n6         Chronology base;\n7         if ((base = getBase()) != null) {\n8             return base.getDateTimeMillis\n9                 (year, monthOfYear, dayOfMonth,\n10                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n11         }\n12         long instant;\n13             instant = iGregorianChronology.getDateTimeMillis\n14                 (year, monthOfYear, dayOfMonth,\n15                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n16         if (instant < iCutoverMillis) {\n17             instant = iJulianChronology.getDateTimeMillis\n18                 (year, monthOfYear, dayOfMonth,\n19                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n20             if (instant >= iCutoverMillis) {\n21                 throw new IllegalArgumentException(\"Specified date does not exist\");\n22             }\n23         }\n24         return instant;\n25     }\n", "fixed_code": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n        long instant;\n        try {\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalFieldValueException ex) {\n            if (monthOfYear != 2 || dayOfMonth != 29) {\n                throw ex;\n            }\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, 28,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                throw ex;\n            }\n        }\n        if (instant < iCutoverMillis) {\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n"}
{"bug_id": "JacksonDatabind-34", "buggy_code": "1     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n2     {\n3         if (_isInt) {\n4             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n5         } else {\n6             Class<?> h = handledType();\n7             if (h == BigDecimal.class) {\n8                 visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n9             } else {\n10                  visitor.expectNumberFormat(typeHint);\n11             }\n12         }\n13     }\n", "fixed_code": "    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        if (_isInt) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            Class<?> h = handledType();\n            if (h == BigDecimal.class) {\n                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n            } else {\n                 visitor.expectNumberFormat(typeHint);\n            }\n        }\n    }\n"}
{"bug_id": "Mockito-28", "buggy_code": "1     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n2         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n3             mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n4         }\n5     }\n", "fixed_code": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n            mocks.remove(injected);\n        }\n    }\n"}
{"bug_id": "Mockito-29", "buggy_code": "1     public void describeTo(Description description) {\n2         description.appendText(\"same(\");\n3         appendQuoting(description);\n4         description.appendText(wanted.toString());\n5         appendQuoting(description);\n6         description.appendText(\")\");\n7     }\n", "fixed_code": "    public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n        description.appendText(wanted == null ? \"null\" : wanted.toString());\n        appendQuoting(description);\n        description.appendText(\")\");\n    }\n"}
{"bug_id": "Lang-52", "buggy_code": "1     private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n2         if (out == null) {\n3             throw new IllegalArgumentException(\"The Writer must not be null\");\n4         }\n5         if (str == null) {\n6             return;\n7         }\n8         int sz;\n9         sz = str.length();\n10         for (int i = 0; i < sz; i++) {\n11             char ch = str.charAt(i);\n12             if (ch > 0xfff) {\n13                 out.write(\"\\\\u\" + hex(ch));\n14             } else if (ch > 0xff) {\n15                 out.write(\"\\\\u0\" + hex(ch));\n16             } else if (ch > 0x7f) {\n17                 out.write(\"\\\\u00\" + hex(ch));\n18             } else if (ch < 32) {\n19                 switch (ch) {\n20                     case '\\b':\n21                         out.write('\\\\');\n22                         out.write('b');\n23                         break;\n24                     case '\\n':\n25                         out.write('\\\\');\n26                         out.write('n');\n27                         break;\n28                     case '\\t':\n29                         out.write('\\\\');\n30                         out.write('t');\n31                         break;\n32                     case '\\f':\n33                         out.write('\\\\');\n34                         out.write('f');\n35                         break;\n36                     case '\\r':\n37                         out.write('\\\\');\n38                         out.write('r');\n39                         break;\n40                     default :\n41                         if (ch > 0xf) {\n42                             out.write(\"\\\\u00\" + hex(ch));\n43                         } else {\n44                             out.write(\"\\\\u000\" + hex(ch));\n45                         }\n46                         break;\n47                 }\n48             } else {\n49                 switch (ch) {\n50                     case '\\'':\n51                         if (escapeSingleQuote) {\n52                           out.write('\\\\');\n53                         }\n54                         out.write('\\'');\n55                         break;\n56                     case '\"':\n57                         out.write('\\\\');\n58                         out.write('\"');\n59                         break;\n60                     case '\\\\':\n61                         out.write('\\\\');\n62                         out.write('\\\\');\n63                         break;\n64                     default :\n65                         out.write(ch);\n66                         break;\n67                 }\n68             }\n69         }\n70     }\n", "fixed_code": "    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (str == null) {\n            return;\n        }\n        int sz;\n        sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            char ch = str.charAt(i);\n            if (ch > 0xfff) {\n                out.write(\"\\\\u\" + hex(ch));\n            } else if (ch > 0xff) {\n                out.write(\"\\\\u0\" + hex(ch));\n            } else if (ch > 0x7f) {\n                out.write(\"\\\\u00\" + hex(ch));\n            } else if (ch < 32) {\n                switch (ch) {\n                    case '\\b':\n                        out.write('\\\\');\n                        out.write('b');\n                        break;\n                    case '\\n':\n                        out.write('\\\\');\n                        out.write('n');\n                        break;\n                    case '\\t':\n                        out.write('\\\\');\n                        out.write('t');\n                        break;\n                    case '\\f':\n                        out.write('\\\\');\n                        out.write('f');\n                        break;\n                    case '\\r':\n                        out.write('\\\\');\n                        out.write('r');\n                        break;\n                    default :\n                        if (ch > 0xf) {\n                            out.write(\"\\\\u00\" + hex(ch));\n                        } else {\n                            out.write(\"\\\\u000\" + hex(ch));\n                        }\n                        break;\n                }\n            } else {\n                switch (ch) {\n                    case '\\'':\n                        if (escapeSingleQuote) {\n                          out.write('\\\\');\n                        }\n                        out.write('\\'');\n                        break;\n                    case '\"':\n                        out.write('\\\\');\n                        out.write('\"');\n                        break;\n                    case '\\\\':\n                        out.write('\\\\');\n                        out.write('\\\\');\n                        break;\n                    case '/':\n                        out.write('\\\\');\n                        out.write('/');\n                        break;\n                    default :\n                        out.write(ch);\n                        break;\n                }\n            }\n        }\n    }\n"}
{"bug_id": "Jsoup-34", "buggy_code": "1     int nextIndexOf(CharSequence seq) {\n2         char startChar = seq.charAt(0);\n3         for (int offset = pos; offset < length; offset++) {\n4             if (startChar != input[offset])\n5                 while(++offset < length && startChar != input[offset]);\n6             int i = offset + 1;\n7             int last = i + seq.length()-1;\n8             if (offset < length) {\n9                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n10                 if (i == last) \n11                     return offset - pos;\n12             }\n13         }\n14         return -1;\n15     }\n", "fixed_code": "    int nextIndexOf(CharSequence seq) {\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) \n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n"}
{"bug_id": "Closure-86", "buggy_code": "1   static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n2     switch (value.getType()) {\n3       case Token.ASSIGN:\n4         return NodeUtil.isImmutableValue(value.getLastChild())\n5             || (locals.apply(value)\n6                 && evaluatesToLocalValue(value.getLastChild(), locals));\n7       case Token.COMMA:\n8         return evaluatesToLocalValue(value.getLastChild(), locals);\n9       case Token.AND:\n10       case Token.OR:\n11         return evaluatesToLocalValue(value.getFirstChild(), locals)\n12            && evaluatesToLocalValue(value.getLastChild(), locals);\n13       case Token.HOOK:\n14         return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n15            && evaluatesToLocalValue(value.getLastChild(), locals);\n16       case Token.INC:\n17       case Token.DEC:\n18         if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n19           return evaluatesToLocalValue(value.getFirstChild(), locals);\n20         } else {\n21           return true;\n22         }\n23       case Token.THIS:\n24         return locals.apply(value);\n25       case Token.NAME:\n26         return isImmutableValue(value) || locals.apply(value);\n27       case Token.GETELEM:\n28       case Token.GETPROP:\n29         return locals.apply(value);\n30       case Token.CALL:\n31         return callHasLocalResult(value)\n32             || isToStringMethodCall(value)\n33             || locals.apply(value);\n34       case Token.NEW:\n35         return true;\n36       case Token.FUNCTION:\n37       case Token.REGEXP:\n38       case Token.ARRAYLIT:\n39       case Token.OBJECTLIT:\n40         return true;\n41       case Token.IN:\n42         return true;\n43       default:\n44         if (isAssignmentOp(value)\n45             || isSimpleOperator(value)\n46             || isImmutableValue(value)) {\n47           return true;\n48         }\n49         throw new IllegalStateException(\n50             \"Unexpected expression node\" + value +\n51             \"\\n parent:\" + value.getParent());\n52     }\n53   }\n", "fixed_code": "  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        return false;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return true;\n      case Token.IN:\n        return true;\n      default:\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }\n"}
{"bug_id": "Jsoup-32", "buggy_code": "1     public Element clone() {\n2         Element clone = (Element) super.clone();\n3         clone.classNames();\n4         return clone;\n5     }\n", "fixed_code": "    public Element clone() {\n        Element clone = (Element) super.clone();\n        clone.classNames = null; \n        return clone;\n    }\n"}
{"bug_id": "Jsoup-64", "buggy_code": "1     private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n2         tb.insert(startTag);\n3         tb.tokeniser.transition(TokeniserState.Rawtext);\n4         tb.markInsertionMode();\n5         tb.transition(Text);\n6     }\n", "fixed_code": "    private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.tokeniser.transition(TokeniserState.Rawtext);\n        tb.markInsertionMode();\n        tb.transition(Text);\n        tb.insert(startTag);\n    }\n"}
{"bug_id": "Lang-11", "buggy_code": "1     public static String random(int count, int start, int end, boolean letters, boolean numbers,\n2                                 char[] chars, Random random) {\n3         if (count == 0) {\n4             return \"\";\n5         } else if (count < 0) {\n6             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n7         }\n8         if (chars != null && chars.length == 0) {\n9             throw new IllegalArgumentException(\"The chars array must not be empty\");\n10         }\n11         if (start == 0 && end == 0) {\n12             if (chars != null) {\n13                 end = chars.length;\n14             } else {\n15                 if (!letters && !numbers) {\n16                     end = Integer.MAX_VALUE;\n17                 } else {\n18                     end = 'z' + 1;\n19                     start = ' ';                \n20                 }\n21             }\n22         }\n23         char[] buffer = new char[count];\n24         int gap = end - start;\n25         while (count-- != 0) {\n26             char ch;\n27             if (chars == null) {\n28                 ch = (char) (random.nextInt(gap) + start);\n29             } else {\n30                 ch = chars[random.nextInt(gap) + start];\n31             }\n32             if (letters && Character.isLetter(ch)\n33                     || numbers && Character.isDigit(ch)\n34                     || !letters && !numbers) {\n35                 if(ch >= 56320 && ch <= 57343) {\n36                     if(count == 0) {\n37                         count++;\n38                     } else {\n39                         buffer[count] = ch;\n40                         count--;\n41                         buffer[count] = (char) (55296 + random.nextInt(128));\n42                     }\n43                 } else if(ch >= 55296 && ch <= 56191) {\n44                     if(count == 0) {\n45                         count++;\n46                     } else {\n47                         buffer[count] = (char) (56320 + random.nextInt(128));\n48                         count--;\n49                         buffer[count] = ch;\n50                     }\n51                 } else if(ch >= 56192 && ch <= 56319) {\n52                     count++;\n53                 } else {\n54                     buffer[count] = ch;\n55                 }\n56             } else {\n57                 count++;\n58             }\n59         }\n60         return new String(buffer);\n61     }\n", "fixed_code": "    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else {\n                if (!letters && !numbers) {\n                    end = Integer.MAX_VALUE;\n                } else {\n                    end = 'z' + 1;\n                    start = ' ';                \n                }\n            }\n        } else {\n            if (end <= start) {\n                throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n            }\n        }\n        char[] buffer = new char[count];\n        int gap = end - start;\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(gap) + start];\n            }\n            if (letters && Character.isLetter(ch)\n                    || numbers && Character.isDigit(ch)\n                    || !letters && !numbers) {\n                if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n"}
{"bug_id": "Jsoup-46", "buggy_code": "1     static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n2                        boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n3         boolean lastWasWhite = false;\n4         boolean reachedNonWhite = false;\n5         final EscapeMode escapeMode = out.escapeMode();\n6         final CharsetEncoder encoder = out.encoder();\n7         final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n8         final Map<Character, String> map = escapeMode.getMap();\n9         final int length = string.length();\n10         int codePoint;\n11         for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n12             codePoint = string.codePointAt(offset);\n13             if (normaliseWhite) {\n14                 if (StringUtil.isWhitespace(codePoint)) {\n15                     if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n16                         continue;\n17                     accum.append(' ');\n18                     lastWasWhite = true;\n19                     continue;\n20                 } else {\n21                     lastWasWhite = false;\n22                     reachedNonWhite = true;\n23                 }\n24             }\n25             if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n26                 final char c = (char) codePoint;\n27                 switch (c) {\n28                     case '&':\n29                         accum.append(\"&amp;\");\n30                         break;\n31                     case 0xA0:\n32                         if (escapeMode != EscapeMode.xhtml)\n33                             accum.append(\"&nbsp;\");\n34                         else\n35                             accum.append(c);\n36                         break;\n37                     case '<':\n38                         if (!inAttribute)\n39                             accum.append(\"&lt;\");\n40                         else\n41                             accum.append(c);\n42                         break;\n43                     case '>':\n44                         if (!inAttribute)\n45                             accum.append(\"&gt;\");\n46                         else\n47                             accum.append(c);\n48                         break;\n49                     case '\"':\n50                         if (inAttribute)\n51                             accum.append(\"&quot;\");\n52                         else\n53                             accum.append(c);\n54                         break;\n55                     default:\n56                         if (canEncode(coreCharset, c, encoder))\n57                             accum.append(c);\n58                         else if (map.containsKey(c))\n59                             accum.append('&').append(map.get(c)).append(';');\n60                         else\n61                             accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n62                 }\n63             } else {\n64                 final String c = new String(Character.toChars(codePoint));\n65                 if (encoder.canEncode(c)) \n66                     accum.append(c);\n67                 else\n68                     accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n69             }\n70         }\n71     }\n", "fixed_code": "    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n        final Map<Character, String> map = escapeMode.getMap();\n        final int length = string.length();\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) \n                    accum.append(c);\n                else\n                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        }\n    }\n"}
{"bug_id": "Math-58", "buggy_code": "1     public double[] fit() {\n2         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n3         return fit(new Gaussian.Parametric(), guess);\n4     }\n", "fixed_code": "    public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(guess);\n    }\n"}
{"bug_id": "Closure-7", "buggy_code": "1     public JSType caseObjectType(ObjectType type) {\n2       if (value.equals(\"function\")) {\n3         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n4         return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n5       }\n6       return matchesExpectation(\"object\") ? type : null;\n7     }\n", "fixed_code": "    public JSType caseObjectType(ObjectType type) {\n      if (value.equals(\"function\")) {\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        if (resultEqualsValue) {\n          return ctorType.getGreatestSubtype(type);\n        } else {\n          return type.isSubtype(ctorType) ? null : type;\n        }\n      }\n      return matchesExpectation(\"object\") ? type : null;\n    }\n"}
{"bug_id": "Closure-73", "buggy_code": "1   static String strEscape(String s, char quote,\n2                           String doublequoteEscape,\n3                           String singlequoteEscape,\n4                           String backslashEscape,\n5                           CharsetEncoder outputCharsetEncoder) {\n6     StringBuilder sb = new StringBuilder(s.length() + 2);\n7     sb.append(quote);\n8     for (int i = 0; i < s.length(); i++) {\n9       char c = s.charAt(i);\n10       switch (c) {\n11         case '\\0': sb.append(\"\\\\0\"); break;\n12         case '\\n': sb.append(\"\\\\n\"); break;\n13         case '\\r': sb.append(\"\\\\r\"); break;\n14         case '\\t': sb.append(\"\\\\t\"); break;\n15         case '\\\\': sb.append(backslashEscape); break;\n16         case '\\\"': sb.append(doublequoteEscape); break;\n17         case '\\'': sb.append(singlequoteEscape); break;\n18         case '>':                       \n19           if (i >= 2 &&\n20               ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n21                (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n22             sb.append(\"\\\\>\");\n23           } else {\n24             sb.append(c);\n25           }\n26           break;\n27         case '<':\n28           final String END_SCRIPT = \"/script\";\n29           final String START_COMMENT = \"!--\";\n30           if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n31                               END_SCRIPT.length())) {\n32             sb.append(\"<\\\\\");\n33           } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n34                                      START_COMMENT.length())) {\n35             sb.append(\"<\\\\\");\n36           } else {\n37             sb.append(c);\n38           }\n39           break;\n40         default:\n41           if (outputCharsetEncoder != null) {\n42             if (outputCharsetEncoder.canEncode(c)) {\n43               sb.append(c);\n44             } else {\n45               appendHexJavaScriptRepresentation(sb, c);\n46             }\n47           } else {\n48             if (c > 0x1f && c <= 0x7f) {\n49               sb.append(c);\n50             } else {\n51               appendHexJavaScriptRepresentation(sb, c);\n52             }\n53           }\n54       }\n55     }\n56     sb.append(quote);\n57     return sb.toString();\n58   }\n", "fixed_code": "  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       \n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          final String END_SCRIPT = \"/script\";\n          final String START_COMMENT = \"!--\";\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            if (c > 0x1f && c < 0x7f) {\n              sb.append(c);\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n"}
{"bug_id": "Cli-28", "buggy_code": "1     protected void processProperties(Properties properties)\n2     {\n3         if (properties == null)\n4         {\n5             return;\n6         }\n7         for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n8         {\n9             String option = e.nextElement().toString();\n10             if (!cmd.hasOption(option))\n11             {\n12                 Option opt = getOptions().getOption(option);\n13                 String value = properties.getProperty(option);\n14                 if (opt.hasArg())\n15                 {\n16                     if (opt.getValues() == null || opt.getValues().length == 0)\n17                     {\n18                         try\n19                         {\n20                             opt.addValueForProcessing(value);\n21                         }\n22                         catch (RuntimeException exp)\n23                         {\n24                         }\n25                     }\n26                 }\n27                 else if (!(\"yes\".equalsIgnoreCase(value)\n28                         || \"true\".equalsIgnoreCase(value)\n29                         || \"1\".equalsIgnoreCase(value)))\n30                 {\n31                     break;\n32                 }\n33                 cmd.addOption(opt);\n34             }\n35         }\n36     }\n", "fixed_code": "    protected void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n                String value = properties.getProperty(option);\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    continue;\n                }\n                cmd.addOption(opt);\n            }\n        }\n    }\n"}
{"bug_id": "Closure-77", "buggy_code": "1   static String strEscape(String s, char quote,\n2                           String doublequoteEscape,\n3                           String singlequoteEscape,\n4                           String backslashEscape,\n5                           CharsetEncoder outputCharsetEncoder) {\n6     StringBuilder sb = new StringBuilder(s.length() + 2);\n7     sb.append(quote);\n8     for (int i = 0; i < s.length(); i++) {\n9       char c = s.charAt(i);\n10       switch (c) {\n11         case '\\n': sb.append(\"\\\\n\"); break;\n12         case '\\r': sb.append(\"\\\\r\"); break;\n13         case '\\t': sb.append(\"\\\\t\"); break;\n14         case '\\\\': sb.append(backslashEscape); break;\n15         case '\\\"': sb.append(doublequoteEscape); break;\n16         case '\\'': sb.append(singlequoteEscape); break;\n17         case '>':                       \n18           if (i >= 2 &&\n19               ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n20                (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n21             sb.append(\"\\\\>\");\n22           } else {\n23             sb.append(c);\n24           }\n25           break;\n26         case '<':\n27           final String END_SCRIPT = \"/script\";\n28           final String START_COMMENT = \"!--\";\n29           if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n30                               END_SCRIPT.length())) {\n31             sb.append(\"<\\\\\");\n32           } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n33                                      START_COMMENT.length())) {\n34             sb.append(\"<\\\\\");\n35           } else {\n36             sb.append(c);\n37           }\n38           break;\n39         default:\n40           if (outputCharsetEncoder != null) {\n41             if (outputCharsetEncoder.canEncode(c)) {\n42               sb.append(c);\n43             } else {\n44               appendHexJavaScriptRepresentation(sb, c);\n45             }\n46           } else {\n47             if (c > 0x1f && c <= 0x7f) {\n48               sb.append(c);\n49             } else {\n50               appendHexJavaScriptRepresentation(sb, c);\n51             }\n52           }\n53       }\n54     }\n55     sb.append(quote);\n56     return sb.toString();\n57   }\n", "fixed_code": "  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       \n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          final String END_SCRIPT = \"/script\";\n          final String START_COMMENT = \"!--\";\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n"}
{"bug_id": "Cli-40", "buggy_code": "1     public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n2     {\n3         if (PatternOptionBuilder.STRING_VALUE == clazz)\n4         {\n5             return (T) str;\n6         }\n7         else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n8         {\n9             return (T) createObject(str);\n10         }\n11         else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n12         {\n13             return (T) createNumber(str);\n14         }\n15         else if (PatternOptionBuilder.DATE_VALUE == clazz)\n16         {\n17             return (T) createDate(str);\n18         }\n19         else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n20         {\n21             return (T) createClass(str);\n22         }\n23         else if (PatternOptionBuilder.FILE_VALUE == clazz)\n24         {\n25             return (T) createFile(str);\n26         }\n27         else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n28         {\n29             return (T) openFile(str);\n30         }\n31         else if (PatternOptionBuilder.FILES_VALUE == clazz)\n32         {\n33             return (T) createFiles(str);\n34         }\n35         else if (PatternOptionBuilder.URL_VALUE == clazz)\n36         {\n37             return (T) createURL(str);\n38         }\n39         else\n40         {\n41             return null;\n42         }\n43     }\n", "fixed_code": "    public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return (T) str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n            throw new ParseException(\"Unable to handle the class: \" + clazz);\n        }\n    }\n"}
{"bug_id": "Lang-43", "buggy_code": "1     private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n2             StringBuffer appendTo, boolean escapingOn) {\n3         int start = pos.getIndex();\n4         char[] c = pattern.toCharArray();\n5         if (escapingOn && c[start] == QUOTE) {\n6             return appendTo == null ? null : appendTo.append(QUOTE);\n7         }\n8         int lastHold = start;\n9         for (int i = pos.getIndex(); i < pattern.length(); i++) {\n10             if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n11                 appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n12                         QUOTE);\n13                 pos.setIndex(i + ESCAPED_QUOTE.length());\n14                 lastHold = pos.getIndex();\n15                 continue;\n16             }\n17             switch (c[pos.getIndex()]) {\n18             case QUOTE:\n19                 next(pos);\n20                 return appendTo == null ? null : appendTo.append(c, lastHold,\n21                         pos.getIndex() - lastHold);\n22             default:\n23                 next(pos);\n24             }\n25         }\n26         throw new IllegalArgumentException(\n27                 \"Unterminated quoted string at position \" + start);\n28     }\n", "fixed_code": "    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            next(pos);\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n"}
{"bug_id": "Compress-38", "buggy_code": "1     public boolean isDirectory() {\n2         if (file != null) {\n3             return file.isDirectory();\n4         }\n5         if (linkFlag == LF_DIR) {\n6             return true;\n7         }\n8         if (getName().endsWith(\"/\")) {\n9             return true;\n10         }\n11         return false;\n12     }\n", "fixed_code": "    public boolean isDirectory() {\n        if (file != null) {\n            return file.isDirectory();\n        }\n        if (linkFlag == LF_DIR) {\n            return true;\n        }\n        if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {\n            return true;\n        }\n        return false;\n    }\n"}
{"bug_id": "Time-17", "buggy_code": "1     public long adjustOffset(long instant, boolean earlierOrLater) {\n2         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n3         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n4         if (instantBefore == instantAfter) {\n5             return instant;  \n6         }\n7         long local = convertUTCToLocal(instant);\n8         return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n9     }\n", "fixed_code": "    public long adjustOffset(long instant, boolean earlierOrLater) {\n        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long offsetBefore = getOffset(instantBefore);\n        long offsetAfter = getOffset(instantAfter);\n        if (offsetBefore <= offsetAfter) {\n            return instant;  \n        }\n        long diff = offsetBefore - offsetAfter;\n        long transition = nextTransition(instantBefore);\n        long overlapStart = transition - diff;\n        long overlapEnd = transition + diff;\n        if (instant < overlapStart || instant >= overlapEnd) {\n          return instant;  \n        }\n        long afterStart = instant - overlapStart;\n        if (afterStart >= diff) {\n          return earlierOrLater ? instant : instant - diff;\n        } else {\n          return earlierOrLater ? instant + diff : instant;\n        }\n    }\n"}
{"bug_id": "Math-45", "buggy_code": "1     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n2         super(rowDimension, columnDimension);\n3         this.rows = rowDimension;\n4         this.columns = columnDimension;\n5         this.entries = new OpenIntToDoubleHashMap(0.0);\n6     }\n", "fixed_code": "    public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n        super(rowDimension, columnDimension);\n        long lRow = (long) rowDimension;\n        long lCol = (long) columnDimension;\n        if (lRow * lCol >= (long) Integer.MAX_VALUE) {\n            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);\n        }\n        this.rows = rowDimension;\n        this.columns = columnDimension;\n        this.entries = new OpenIntToDoubleHashMap(0.0);\n    }\n"}
{"bug_id": "Codec-9", "buggy_code": "1     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n2         if (binaryData == null || binaryData.length == 0) {\n3             return binaryData;\n4         }\n5         long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n6         if (len > maxResultSize) {\n7             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n8                 len +\n9                 \") than the specified maxium size of \" +\n10                 maxResultSize);\n11         }\n12         Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n13         return b64.encode(binaryData);\n14     }\n", "fixed_code": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n"}
{"bug_id": "Math-33", "buggy_code": "1     protected void dropPhase1Objective() {\n2         if (getNumObjectiveFunctions() == 1) {\n3             return;\n4         }\n5         List<Integer> columnsToDrop = new ArrayList<Integer>();\n6         columnsToDrop.add(0);\n7         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n8             final double entry = tableau.getEntry(0, i);\n9             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n10                 columnsToDrop.add(i);\n11             }\n12         }\n13         for (int i = 0; i < getNumArtificialVariables(); i++) {\n14           int col = i + getArtificialVariableOffset();\n15           if (getBasicRow(col) == null) {\n16             columnsToDrop.add(col);\n17           }\n18         }\n19         double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n20         for (int i = 1; i < getHeight(); i++) {\n21           int col = 0;\n22           for (int j = 0; j < getWidth(); j++) {\n23             if (!columnsToDrop.contains(j)) {\n24               matrix[i - 1][col++] = tableau.getEntry(i, j);\n25             }\n26           }\n27         }\n28         for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n29           columnLabels.remove((int) columnsToDrop.get(i));\n30         }\n31         this.tableau = new Array2DRowRealMatrix(matrix);\n32         this.numArtificialVariables = 0;\n33     }\n", "fixed_code": "    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n"}
{"bug_id": "Jsoup-24", "buggy_code": "1         void read(Tokeniser t, CharacterReader r) {\n2             if (r.matchesLetter()) {\n3                 String name = r.consumeLetterSequence();\n4                 t.tagPending.appendTagName(name.toLowerCase());\n5                 t.dataBuffer.append(name);\n6                 r.advance();\n7                 return;\n8             }\n9             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n10                 char c = r.consume();\n11                 switch (c) {\n12                     case '\\t':\n13                     case '\\n':\n14                     case '\\f':\n15                     case ' ':\n16                         t.transition(BeforeAttributeName);\n17                         break;\n18                     case '/':\n19                         t.transition(SelfClosingStartTag);\n20                         break;\n21                     case '>':\n22                         t.emitTagPending();\n23                         t.transition(Data);\n24                         break;\n25                     default:\n26                         t.dataBuffer.append(c);\n27                         anythingElse(t, r);\n28                         break;\n29                 }\n30             } else {\n31                 anythingElse(t, r);\n32             }\n33         }\n", "fixed_code": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                char c = r.consume();\n                switch (c) {\n                    case '\\t':\n                    case '\\n':\n                    case '\\f':\n                    case ' ':\n                        t.transition(BeforeAttributeName);\n                        break;\n                    case '/':\n                        t.transition(SelfClosingStartTag);\n                        break;\n                    case '>':\n                        t.emitTagPending();\n                        t.transition(Data);\n                        break;\n                    default:\n                        t.dataBuffer.append(c);\n                        anythingElse(t, r);\n                        break;\n                }\n            } else {\n                anythingElse(t, r);\n            }\n        }\n"}
{"bug_id": "JacksonXml-3", "buggy_code": "1     public String nextTextValue() throws IOException\n2     {\n3         _binaryValue = null;\n4         if (_nextToken != null) {\n5             JsonToken t = _nextToken;\n6             _currToken = t;\n7             _nextToken = null;\n8             if (t == JsonToken.VALUE_STRING) {\n9                 return _currText;\n10             }\n11             _updateState(t);\n12             return null;\n13         }\n14         int token = _xmlTokens.next();\n15         while (token == XmlTokenStream.XML_START_ELEMENT) {\n16             if (_mayBeLeaf) {\n17                 _nextToken = JsonToken.FIELD_NAME;\n18                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n19                 _currToken = JsonToken.START_OBJECT;\n20                 return null;\n21             }\n22             if (_parsingContext.inArray()) {\n23                 token = _xmlTokens.next();\n24                 _mayBeLeaf = true;\n25                 continue;\n26             }\n27             String name = _xmlTokens.getLocalName();\n28             _parsingContext.setCurrentName(name);\n29             if (_namesToWrap != null && _namesToWrap.contains(name)) {\n30                 _xmlTokens.repeatStartElement();\n31             }\n32             _mayBeLeaf = true;\n33             _currToken = JsonToken.FIELD_NAME;\n34             return null;\n35         }\n36         switch (token) {\n37         case XmlTokenStream.XML_END_ELEMENT:\n38             if (_mayBeLeaf) {\n39                 _mayBeLeaf = false;\n40                 _currToken = JsonToken.VALUE_STRING;\n41                 return (_currText = \"\");\n42             }\n43             _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n44             _parsingContext = _parsingContext.getParent();\n45             _namesToWrap = _parsingContext.getNamesToWrap();\n46             break;\n47         case XmlTokenStream.XML_ATTRIBUTE_NAME:\n48             if (_mayBeLeaf) {\n49                 _mayBeLeaf = false;\n50                 _nextToken = JsonToken.FIELD_NAME;\n51                 _currText = _xmlTokens.getText();\n52                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n53                 _currToken = JsonToken.START_OBJECT;\n54             } else {\n55                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n56                 _currToken = JsonToken.FIELD_NAME;\n57             }\n58             break;\n59         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n60             _currText = _xmlTokens.getText();\n61             _currToken = JsonToken.VALUE_STRING;\n62             break;\n63         case XmlTokenStream.XML_TEXT:\n64             _currText = _xmlTokens.getText();\n65             if (_mayBeLeaf) {\n66                 _mayBeLeaf = false;\n67                 _xmlTokens.skipEndElement();\n68                 _currToken = JsonToken.VALUE_STRING;\n69                 return _currText;\n70             }\n71             _parsingContext.setCurrentName(_cfgNameForTextElement);\n72             _nextToken = JsonToken.VALUE_STRING;\n73             _currToken = JsonToken.FIELD_NAME;\n74             break;\n75         case XmlTokenStream.XML_END:\n76             _currToken = null;\n77         }\n78         return null;\n79     }\n", "fixed_code": "    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n        int token = _xmlTokens.next();\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currToken = JsonToken.VALUE_STRING;\n            return (_currText = _xmlTokens.getText());\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _xmlTokens.skipEndElement();\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }\n"}
{"bug_id": "Chart-10", "buggy_code": "1     public String generateToolTipFragment(String toolTipText) {\n2         return \" title=\\\"\" + toolTipText\n3             + \"\\\" alt=\\\"\\\"\";\n4     }\n", "fixed_code": "    public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \n            + \"\\\" alt=\\\"\\\"\";\n    }\n"}
{"bug_id": "Closure-102", "buggy_code": "1   public void process(Node externs, Node root) {\n2     NodeTraversal.traverse(compiler, root, this);\n3     if (MAKE_LOCAL_NAMES_UNIQUE) {\n4       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n5       NodeTraversal t = new NodeTraversal(compiler, renamer);\n6       t.traverseRoots(externs, root);\n7     }\n8     removeDuplicateDeclarations(root);\n9     new PropogateConstantAnnotations(compiler, assertOnChange)\n10         .process(externs, root);\n11   }\n", "fixed_code": "  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }\n"}
{"bug_id": "Closure-71", "buggy_code": "1   private void checkPropertyVisibility(NodeTraversal t,\n2       Node getprop, Node parent) {\n3     ObjectType objectType =\n4         ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n5     String propertyName = getprop.getLastChild().getString();\n6     if (objectType != null) {\n7       boolean isOverride = t.inGlobalScope() &&\n8           parent.getType() == Token.ASSIGN &&\n9           parent.getFirstChild() == getprop;\n10       if (isOverride) {\n11         objectType = objectType.getImplicitPrototype();\n12       }\n13       JSDocInfo docInfo = null;\n14       for (; objectType != null;\n15            objectType = objectType.getImplicitPrototype()) {\n16         docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n17         if (docInfo != null &&\n18             docInfo.getVisibility() != Visibility.INHERITED) {\n19           break;\n20         }\n21       }\n22       if (objectType == null) {\n23         return;\n24       }\n25       boolean sameInput =\n26           t.getInput().getName().equals(docInfo.getSourceName());\n27       Visibility visibility = docInfo.getVisibility();\n28       JSType ownerType = normalizeClassType(objectType);\n29       if (isOverride) {\n30         JSDocInfo overridingInfo = parent.getJSDocInfo();\n31         Visibility overridingVisibility = overridingInfo == null ?\n32             Visibility.INHERITED : overridingInfo.getVisibility();\n33         if (visibility == Visibility.PRIVATE && !sameInput) {\n34           compiler.report(\n35               t.makeError(getprop, PRIVATE_OVERRIDE,\n36                   objectType.toString()));\n37         } else if (overridingVisibility != Visibility.INHERITED &&\n38             overridingVisibility != visibility) {\n39           compiler.report(\n40               t.makeError(getprop, VISIBILITY_MISMATCH,\n41                   visibility.name(), objectType.toString(),\n42                   overridingVisibility.name()));\n43         }\n44       } else {\n45         if (sameInput) {\n46           return;\n47         } else if (visibility == Visibility.PRIVATE &&\n48             (currentClass == null || ownerType.differsFrom(currentClass))) {\n49           if (docInfo.isConstructor() &&\n50               isValidPrivateConstructorAccess(parent)) {\n51             return;\n52           }\n53           compiler.report(\n54               t.makeError(getprop,\n55                   BAD_PRIVATE_PROPERTY_ACCESS,\n56                   propertyName,\n57                   validator.getReadableJSTypeName(\n58                       getprop.getFirstChild(), true)));\n59         } else if (visibility == Visibility.PROTECTED) {\n60           if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n61             compiler.report(\n62                 t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n63                     propertyName,\n64                     validator.getReadableJSTypeName(\n65                         getprop.getFirstChild(), true)));\n66           }\n67         }\n68       }\n69     }\n70   }\n", "fixed_code": "  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n      boolean isOverride = parent.getJSDocInfo() != null &&\n          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n      if (isOverride) {\n        objectType = objectType.getImplicitPrototype();\n      }\n      JSDocInfo docInfo = null;\n      for (; objectType != null;\n           objectType = objectType.getImplicitPrototype()) {\n        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        if (docInfo != null &&\n            docInfo.getVisibility() != Visibility.INHERITED) {\n          break;\n        }\n      }\n      if (objectType == null) {\n        return;\n      }\n      boolean sameInput =\n          t.getInput().getName().equals(docInfo.getSourceName());\n      Visibility visibility = docInfo.getVisibility();\n      JSType ownerType = normalizeClassType(objectType);\n      if (isOverride) {\n        JSDocInfo overridingInfo = parent.getJSDocInfo();\n        Visibility overridingVisibility = overridingInfo == null ?\n            Visibility.INHERITED : overridingInfo.getVisibility();\n        if (visibility == Visibility.PRIVATE && !sameInput) {\n          compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE,\n                  objectType.toString()));\n        } else if (overridingVisibility != Visibility.INHERITED &&\n            overridingVisibility != visibility) {\n          compiler.report(\n              t.makeError(getprop, VISIBILITY_MISMATCH,\n                  visibility.name(), objectType.toString(),\n                  overridingVisibility.name()));\n        }\n      } else {\n        if (sameInput) {\n          return;\n        } else if (visibility == Visibility.PRIVATE &&\n            (currentClass == null || ownerType.differsFrom(currentClass))) {\n          if (docInfo.isConstructor() &&\n              isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n          compiler.report(\n              t.makeError(getprop,\n                  BAD_PRIVATE_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        } else if (visibility == Visibility.PROTECTED) {\n          if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n            compiler.report(\n                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                    propertyName,\n                    validator.getReadableJSTypeName(\n                        getprop.getFirstChild(), true)));\n          }\n        }\n      }\n    }\n  }\n"}
{"bug_id": "Closure-42", "buggy_code": "1     Node processForInLoop(ForInLoop loopNode) {\n2       return newNode(\n3           Token.FOR,\n4           transform(loopNode.getIterator()),\n5           transform(loopNode.getIteratedObject()),\n6           transformBlock(loopNode.getBody()));\n7     }\n", "fixed_code": "    Node processForInLoop(ForInLoop loopNode) {\n      if (loopNode.isForEach()) {\n        errorReporter.error(\n            \"unsupported language extension: for each\",\n            sourceName,\n            loopNode.getLineno(), \"\", 0);\n        return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n      }\n      return newNode(\n          Token.FOR,\n          transform(loopNode.getIterator()),\n          transform(loopNode.getIteratedObject()),\n          transformBlock(loopNode.getBody()));\n    }\n"}
{"bug_id": "JacksonDatabind-45", "buggy_code": "1     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n2             BeanProperty property) throws JsonMappingException\n3     {\n4         if (property != null) {\n5             JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n6             if (format != null) {\n7                 JsonFormat.Shape shape = format.getShape();\n8                 if (shape.isNumeric()) {\n9                     return withFormat(Boolean.TRUE, null);\n10                 }\n11                 if (format.getShape() == JsonFormat.Shape.STRING) {\n12                     TimeZone tz = format.getTimeZone();\n13                     final String pattern = format.hasPattern()\n14                                     ? format.getPattern()\n15                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n16                     final Locale loc = format.hasLocale()\n17                                     ? format.getLocale()\n18                                     : serializers.getLocale();\n19                     SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n20                     if (tz == null) {\n21                         tz = serializers.getTimeZone();\n22                     }\n23                     df.setTimeZone(tz);\n24                     return withFormat(Boolean.FALSE, df);\n25                 }\n26             }\n27         }\n28         return this;\n29     }\n", "fixed_code": "    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n            if (format != null) {\n                JsonFormat.Shape shape = format.getShape();\n                if (shape.isNumeric()) {\n                    return withFormat(Boolean.TRUE, null);\n                }\n                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                                || format.hasLocale() || format.hasTimeZone()) {\n                    TimeZone tz = format.getTimeZone();\n                    final String pattern = format.hasPattern()\n                                    ? format.getPattern()\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                    final Locale loc = format.hasLocale()\n                                    ? format.getLocale()\n                                    : serializers.getLocale();\n                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                    if (tz == null) {\n                        tz = serializers.getTimeZone();\n                    }\n                    df.setTimeZone(tz);\n                    return withFormat(Boolean.FALSE, df);\n                }\n            }\n        }\n        return this;\n    }\n"}
{"bug_id": "Compress-23", "buggy_code": "1         InputStream decode(final InputStream in, final Coder coder,\n2                 byte[] password) throws IOException {\n3             byte propsByte = coder.properties[0];\n4             long dictSize = coder.properties[1];\n5             for (int i = 1; i < 4; i++) {\n6                 dictSize |= (coder.properties[i + 1] << (8 * i));\n7             }\n8             if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n9                 throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n10             }\n11             return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n12         }\n", "fixed_code": "        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n                dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n"}
{"bug_id": "Cli-27", "buggy_code": "1     public void setSelected(Option option) throws AlreadySelectedException\n2     {\n3         if (option == null)\n4         {\n5             selected = null;\n6             return;\n7         }\n8         if (selected == null || selected.equals(option.getOpt()))\n9         {\n10             selected = option.getOpt();\n11         }\n12         else\n13         {\n14             throw new AlreadySelectedException(this, option);\n15         }\n16     }\n", "fixed_code": "    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            selected = null;\n            return;\n        }\n        if (selected == null || selected.equals(option.getKey()))\n        {\n            selected = option.getKey();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n"}
{"bug_id": "Closure-29", "buggy_code": "1     private boolean isInlinableObject(List<Reference> refs) {\n2       boolean ret = false;\n3       for (Reference ref : refs) {\n4         Node name = ref.getNode();\n5         Node parent = ref.getParent();\n6         Node gramps = ref.getGrandparent();\n7         if (parent.isGetProp()) {\n8           Preconditions.checkState(parent.getFirstChild() == name);\n9           if (gramps.isCall()\n10               && gramps.getFirstChild() == parent) {\n11             return false;\n12           }\n13           continue;\n14         }\n15         if (!isVarOrAssignExprLhs(name)) {\n16            return false;\n17         }\n18         Node val = ref.getAssignedValue();\n19         if (val == null) {\n20           continue;\n21         }\n22         if (!val.isObjectLit()) {\n23           return false;\n24         }\n25         for (Node child = val.getFirstChild(); child != null;\n26              child = child.getNext()) {\n27           if (child.isGetterDef() ||\n28               child.isSetterDef()) {\n29             return false;\n30           }\n31           Node childVal = child.getFirstChild();\n32           for (Reference t : refs) {\n33             Node refNode = t.getParent();\n34             while (!NodeUtil.isStatementBlock(refNode)) {\n35               if (refNode == childVal) {\n36                 return false;\n37               }\n38               refNode = refNode.getParent();\n39             }\n40           }\n41         }\n42         ret = true;\n43       }\n44       return ret;\n45     }\n", "fixed_code": "    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n          continue;\n        }\n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          continue;\n        }\n        if (!val.isObjectLit()) {\n          return false;\n        }\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            return false;\n          }\n          validProperties.add(child.getString());\n          Node childVal = child.getFirstChild();\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n        ret = true;\n      }\n      return ret;\n    }\n"}
{"bug_id": "Math-70", "buggy_code": "1     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n2         throws MaxIterationsExceededException, FunctionEvaluationException {\n3         return solve(min, max);\n4     }\n", "fixed_code": "    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n"}
{"bug_id": "Compress-16", "buggy_code": "1     public ArchiveInputStream createArchiveInputStream(final InputStream in)\n2             throws ArchiveException {\n3         if (in == null) {\n4             throw new IllegalArgumentException(\"Stream must not be null.\");\n5         }\n6         if (!in.markSupported()) {\n7             throw new IllegalArgumentException(\"Mark is not supported.\");\n8         }\n9         final byte[] signature = new byte[12];\n10         in.mark(signature.length);\n11         try {\n12             int signatureLength = in.read(signature);\n13             in.reset();\n14             if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n15                 return new ZipArchiveInputStream(in);\n16             } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n17                 return new JarArchiveInputStream(in);\n18             } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n19                 return new ArArchiveInputStream(in);\n20             } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n21                 return new CpioArchiveInputStream(in);\n22             }\n23             final byte[] dumpsig = new byte[32];\n24             in.mark(dumpsig.length);\n25             signatureLength = in.read(dumpsig);\n26             in.reset();\n27             if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n28                 return new DumpArchiveInputStream(in);\n29             }\n30             final byte[] tarheader = new byte[512];\n31             in.mark(tarheader.length);\n32             signatureLength = in.read(tarheader);\n33             in.reset();\n34             if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n35                 return new TarArchiveInputStream(in);\n36             }\n37             if (signatureLength >= 512) {\n38                 try {\n39                     TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n40                     tais.getNextEntry();\n41                         return new TarArchiveInputStream(in);\n42                 } catch (Exception e) { \n43                 }\n44             }\n45         } catch (IOException e) {\n46             throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n47         }\n48         throw new ArchiveException(\"No Archiver found for the stream signature\");\n49     }\n", "fixed_code": "    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            if (signatureLength >= 512) {\n                try {\n                    TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                    if (tais.getNextTarEntry().isCheckSumOK()) {\n                        return new TarArchiveInputStream(in);\n                    }\n                } catch (Exception e) { \n                }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n"}
{"bug_id": "Math-24", "buggy_code": "1     protected UnivariatePointValuePair doOptimize() {\n2         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n3         final double lo = getMin();\n4         final double mid = getStartValue();\n5         final double hi = getMax();\n6         final ConvergenceChecker<UnivariatePointValuePair> checker\n7             = getConvergenceChecker();\n8         double a;\n9         double b;\n10         if (lo < hi) {\n11             a = lo;\n12             b = hi;\n13         } else {\n14             a = hi;\n15             b = lo;\n16         }\n17         double x = mid;\n18         double v = x;\n19         double w = x;\n20         double d = 0;\n21         double e = 0;\n22         double fx = computeObjectiveValue(x);\n23         if (!isMinim) {\n24             fx = -fx;\n25         }\n26         double fv = fx;\n27         double fw = fx;\n28         UnivariatePointValuePair previous = null;\n29         UnivariatePointValuePair current\n30             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n31         int iter = 0;\n32         while (true) {\n33             final double m = 0.5 * (a + b);\n34             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n35             final double tol2 = 2 * tol1;\n36             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n37             if (!stop) {\n38                 double p = 0;\n39                 double q = 0;\n40                 double r = 0;\n41                 double u = 0;\n42                 if (FastMath.abs(e) > tol1) { \n43                     r = (x - w) * (fx - fv);\n44                     q = (x - v) * (fx - fw);\n45                     p = (x - v) * q - (x - w) * r;\n46                     q = 2 * (q - r);\n47                     if (q > 0) {\n48                         p = -p;\n49                     } else {\n50                         q = -q;\n51                     }\n52                     r = e;\n53                     e = d;\n54                     if (p > q * (a - x) &&\n55                         p < q * (b - x) &&\n56                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n57                         d = p / q;\n58                         u = x + d;\n59                         if (u - a < tol2 || b - u < tol2) {\n60                             if (x <= m) {\n61                                 d = tol1;\n62                             } else {\n63                                 d = -tol1;\n64                             }\n65                         }\n66                     } else {\n67                         if (x < m) {\n68                             e = b - x;\n69                         } else {\n70                             e = a - x;\n71                         }\n72                         d = GOLDEN_SECTION * e;\n73                     }\n74                 } else {\n75                     if (x < m) {\n76                         e = b - x;\n77                     } else {\n78                         e = a - x;\n79                     }\n80                     d = GOLDEN_SECTION * e;\n81                 }\n82                 if (FastMath.abs(d) < tol1) {\n83                     if (d >= 0) {\n84                         u = x + tol1;\n85                     } else {\n86                         u = x - tol1;\n87                     }\n88                 } else {\n89                     u = x + d;\n90                 }\n91                 double fu = computeObjectiveValue(u);\n92                 if (!isMinim) {\n93                     fu = -fu;\n94                 }\n95                 previous = current;\n96                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n97                 if (checker != null) {\n98                     if (checker.converged(iter, previous, current)) {\n99                         return current;\n100                     }\n101                 }\n102                 if (fu <= fx) {\n103                     if (u < x) {\n104                         b = x;\n105                     } else {\n106                         a = x;\n107                     }\n108                     v = w;\n109                     fv = fw;\n110                     w = x;\n111                     fw = fx;\n112                     x = u;\n113                     fx = fu;\n114                 } else {\n115                     if (u < x) {\n116                         a = u;\n117                     } else {\n118                         b = u;\n119                     }\n120                     if (fu <= fw ||\n121                         Precision.equals(w, x)) {\n122                         v = w;\n123                         fv = fw;\n124                         w = u;\n125                         fw = fu;\n126                     } else if (fu <= fv ||\n127                                Precision.equals(v, x) ||\n128                                Precision.equals(v, w)) {\n129                         v = u;\n130                         fv = fu;\n131                     }\n132                 }\n133             } else { \n134                 return current;\n135             }\n136             ++iter;\n137         }\n138     }\n", "fixed_code": "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n                if (FastMath.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n                    r = e;\n                    e = d;\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        d = p / q;\n                        u = x + d;\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return best(current, previous, isMinim);\n                    }\n                }\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { \n                return best(current, previous, isMinim);\n            }\n            ++iter;\n        }\n    }\n"}
{"bug_id": "Lang-40", "buggy_code": "1     public static boolean containsIgnoreCase(String str, String searchStr) {\n2         if (str == null || searchStr == null) {\n3             return false;\n4         }\n5         return contains(str.toUpperCase(), searchStr.toUpperCase());\n6     }\n", "fixed_code": "    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }\n"}
{"bug_id": "Jsoup-38", "buggy_code": "1         boolean process(Token t, HtmlTreeBuilder tb) {\n2             switch (t.type) {\n3                 case Character: {\n4                     Token.Character c = t.asCharacter();\n5                     if (c.getData().equals(nullString)) {\n6                         tb.error(this);\n7                         return false;\n8                     } else if (isWhitespace(c)) {\n9                         tb.reconstructFormattingElements();\n10                         tb.insert(c);\n11                     } else {\n12                         tb.reconstructFormattingElements();\n13                         tb.insert(c);\n14                         tb.framesetOk(false);\n15                     }\n16                     break;\n17                 }\n18                 case Comment: {\n19                     tb.insert(t.asComment());\n20                     break;\n21                 }\n22                 case Doctype: {\n23                     tb.error(this);\n24                     return false;\n25                 }\n26                 case StartTag:\n27                     Token.StartTag startTag = t.asStartTag();\n28                     String name = startTag.name();\n29                     if (name.equals(\"html\")) {\n30                         tb.error(this);\n31                         Element html = tb.getStack().getFirst();\n32                         for (Attribute attribute : startTag.getAttributes()) {\n33                             if (!html.hasAttr(attribute.getKey()))\n34                                 html.attributes().put(attribute);\n35                         }\n36                     } else if (StringUtil.in(name, Constants.InBodyStartToHead)) {\n37                         return tb.process(t, InHead);\n38                     } else if (name.equals(\"body\")) {\n39                         tb.error(this);\n40                         LinkedList<Element> stack = tb.getStack();\n41                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n42                             return false; \n43                         } else {\n44                             tb.framesetOk(false);\n45                             Element body = stack.get(1);\n46                             for (Attribute attribute : startTag.getAttributes()) {\n47                                 if (!body.hasAttr(attribute.getKey()))\n48                                     body.attributes().put(attribute);\n49                             }\n50                         }\n51                     } else if (name.equals(\"frameset\")) {\n52                         tb.error(this);\n53                         LinkedList<Element> stack = tb.getStack();\n54                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n55                             return false; \n56                         } else if (!tb.framesetOk()) {\n57                             return false; \n58                         } else {\n59                             Element second = stack.get(1);\n60                             if (second.parent() != null)\n61                                 second.remove();\n62                             while (stack.size() > 1)\n63                                 stack.removeLast();\n64                             tb.insert(startTag);\n65                             tb.transition(InFrameset);\n66                         }\n67                     } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\n68                         if (tb.inButtonScope(\"p\")) {\n69                             tb.process(new Token.EndTag(\"p\"));\n70                         }\n71                         tb.insert(startTag);\n72                     } else if (StringUtil.in(name, Constants.Headings)) {\n73                         if (tb.inButtonScope(\"p\")) {\n74                             tb.process(new Token.EndTag(\"p\"));\n75                         }\n76                         if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n77                             tb.error(this);\n78                             tb.pop();\n79                         }\n80                         tb.insert(startTag);\n81                     } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\n82                         if (tb.inButtonScope(\"p\")) {\n83                             tb.process(new Token.EndTag(\"p\"));\n84                         }\n85                         tb.insert(startTag);\n86                         tb.framesetOk(false);\n87                     } else if (name.equals(\"form\")) {\n88                         if (tb.getFormElement() != null) {\n89                             tb.error(this);\n90                             return false;\n91                         }\n92                         if (tb.inButtonScope(\"p\")) {\n93                             tb.process(new Token.EndTag(\"p\"));\n94                         }\n95                         tb.insertForm(startTag, true);\n96                     } else if (name.equals(\"li\")) {\n97                         tb.framesetOk(false);\n98                         LinkedList<Element> stack = tb.getStack();\n99                         for (int i = stack.size() - 1; i > 0; i--) {\n100                             Element el = stack.get(i);\n101                             if (el.nodeName().equals(\"li\")) {\n102                                 tb.process(new Token.EndTag(\"li\"));\n103                                 break;\n104                             }\n105                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n106                                 break;\n107                         }\n108                         if (tb.inButtonScope(\"p\")) {\n109                             tb.process(new Token.EndTag(\"p\"));\n110                         }\n111                         tb.insert(startTag);\n112                     } else if (StringUtil.in(name, Constants.DdDt)) {\n113                         tb.framesetOk(false);\n114                         LinkedList<Element> stack = tb.getStack();\n115                         for (int i = stack.size() - 1; i > 0; i--) {\n116                             Element el = stack.get(i);\n117                             if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n118                                 tb.process(new Token.EndTag(el.nodeName()));\n119                                 break;\n120                             }\n121                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n122                                 break;\n123                         }\n124                         if (tb.inButtonScope(\"p\")) {\n125                             tb.process(new Token.EndTag(\"p\"));\n126                         }\n127                         tb.insert(startTag);\n128                     } else if (name.equals(\"plaintext\")) {\n129                         if (tb.inButtonScope(\"p\")) {\n130                             tb.process(new Token.EndTag(\"p\"));\n131                         }\n132                         tb.insert(startTag);\n133                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n134                     } else if (name.equals(\"button\")) {\n135                         if (tb.inButtonScope(\"button\")) {\n136                             tb.error(this);\n137                             tb.process(new Token.EndTag(\"button\"));\n138                             tb.process(startTag);\n139                         } else {\n140                             tb.reconstructFormattingElements();\n141                             tb.insert(startTag);\n142                             tb.framesetOk(false);\n143                         }\n144                     } else if (name.equals(\"a\")) {\n145                         if (tb.getActiveFormattingElement(\"a\") != null) {\n146                             tb.error(this);\n147                             tb.process(new Token.EndTag(\"a\"));\n148                             Element remainingA = tb.getFromStack(\"a\");\n149                             if (remainingA != null) {\n150                                 tb.removeFromActiveFormattingElements(remainingA);\n151                                 tb.removeFromStack(remainingA);\n152                             }\n153                         }\n154                         tb.reconstructFormattingElements();\n155                         Element a = tb.insert(startTag);\n156                         tb.pushActiveFormattingElements(a);\n157                     } else if (StringUtil.in(name, Constants.Formatters)) {\n158                         tb.reconstructFormattingElements();\n159                         Element el = tb.insert(startTag);\n160                         tb.pushActiveFormattingElements(el);\n161                     } else if (name.equals(\"nobr\")) {\n162                         tb.reconstructFormattingElements();\n163                         if (tb.inScope(\"nobr\")) {\n164                             tb.error(this);\n165                             tb.process(new Token.EndTag(\"nobr\"));\n166                             tb.reconstructFormattingElements();\n167                         }\n168                         Element el = tb.insert(startTag);\n169                         tb.pushActiveFormattingElements(el);\n170                     } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n171                         tb.reconstructFormattingElements();\n172                         tb.insert(startTag);\n173                         tb.insertMarkerToFormattingElements();\n174                         tb.framesetOk(false);\n175                     } else if (name.equals(\"table\")) {\n176                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n177                             tb.process(new Token.EndTag(\"p\"));\n178                         }\n179                         tb.insert(startTag);\n180                         tb.framesetOk(false);\n181                         tb.transition(InTable);\n182                     } else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {\n183                         tb.reconstructFormattingElements();\n184                         tb.insertEmpty(startTag);\n185                         tb.framesetOk(false);\n186                     } else if (name.equals(\"input\")) {\n187                         tb.reconstructFormattingElements();\n188                         Element el = tb.insertEmpty(startTag);\n189                         if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n190                             tb.framesetOk(false);\n191                     } else if (StringUtil.in(name, Constants.InBodyStartMedia)) {\n192                         tb.insertEmpty(startTag);\n193                     } else if (name.equals(\"hr\")) {\n194                         if (tb.inButtonScope(\"p\")) {\n195                             tb.process(new Token.EndTag(\"p\"));\n196                         }\n197                         tb.insertEmpty(startTag);\n198                         tb.framesetOk(false);\n199                     } else if (name.equals(\"image\")) {\n200                             return tb.process(startTag.name(\"img\")); \n201                     } else if (name.equals(\"isindex\")) {\n202                         tb.error(this);\n203                         if (tb.getFormElement() != null)\n204                             return false;\n205                         tb.tokeniser.acknowledgeSelfClosingFlag();\n206                         tb.process(new Token.StartTag(\"form\"));\n207                         if (startTag.attributes.hasKey(\"action\")) {\n208                             Element form = tb.getFormElement();\n209                             form.attr(\"action\", startTag.attributes.get(\"action\"));\n210                         }\n211                         tb.process(new Token.StartTag(\"hr\"));\n212                         tb.process(new Token.StartTag(\"label\"));\n213                         String prompt = startTag.attributes.hasKey(\"prompt\") ?\n214                                 startTag.attributes.get(\"prompt\") :\n215                                 \"This is a searchable index. Enter search keywords: \";\n216                         tb.process(new Token.Character(prompt));\n217                         Attributes inputAttribs = new Attributes();\n218                         for (Attribute attr : startTag.attributes) {\n219                             if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))\n220                                 inputAttribs.put(attr);\n221                         }\n222                         inputAttribs.put(\"name\", \"isindex\");\n223                         tb.process(new Token.StartTag(\"input\", inputAttribs));\n224                         tb.process(new Token.EndTag(\"label\"));\n225                         tb.process(new Token.StartTag(\"hr\"));\n226                         tb.process(new Token.EndTag(\"form\"));\n227                     } else if (name.equals(\"textarea\")) {\n228                         tb.insert(startTag);\n229                         tb.tokeniser.transition(TokeniserState.Rcdata);\n230                         tb.markInsertionMode();\n231                         tb.framesetOk(false);\n232                         tb.transition(Text);\n233                     } else if (name.equals(\"xmp\")) {\n234                         if (tb.inButtonScope(\"p\")) {\n235                             tb.process(new Token.EndTag(\"p\"));\n236                         }\n237                         tb.reconstructFormattingElements();\n238                         tb.framesetOk(false);\n239                         handleRawtext(startTag, tb);\n240                     } else if (name.equals(\"iframe\")) {\n241                         tb.framesetOk(false);\n242                         handleRawtext(startTag, tb);\n243                     } else if (name.equals(\"noembed\")) {\n244                         handleRawtext(startTag, tb);\n245                     } else if (name.equals(\"select\")) {\n246                         tb.reconstructFormattingElements();\n247                         tb.insert(startTag);\n248                         tb.framesetOk(false);\n249                         HtmlTreeBuilderState state = tb.state();\n250                         if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n251                             tb.transition(InSelectInTable);\n252                         else\n253                             tb.transition(InSelect);\n254                     } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\n255                         if (tb.currentElement().nodeName().equals(\"option\"))\n256                             tb.process(new Token.EndTag(\"option\"));\n257                         tb.reconstructFormattingElements();\n258                         tb.insert(startTag);\n259                     } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\n260                         if (tb.inScope(\"ruby\")) {\n261                             tb.generateImpliedEndTags();\n262                             if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n263                                 tb.error(this);\n264                                 tb.popStackToBefore(\"ruby\"); \n265                             }\n266                             tb.insert(startTag);\n267                         }\n268                     } else if (name.equals(\"math\")) {\n269                         tb.reconstructFormattingElements();\n270                         tb.insert(startTag);\n271                         tb.tokeniser.acknowledgeSelfClosingFlag();\n272                     } else if (name.equals(\"svg\")) {\n273                         tb.reconstructFormattingElements();\n274                         tb.insert(startTag);\n275                         tb.tokeniser.acknowledgeSelfClosingFlag();\n276                     } else if (StringUtil.in(name, Constants.InBodyStartDrop)) {\n277                         tb.error(this);\n278                         return false;\n279                     } else {\n280                         tb.reconstructFormattingElements();\n281                         tb.insert(startTag);\n282                     }\n283                     break;\n284                 case EndTag:\n285                     Token.EndTag endTag = t.asEndTag();\n286                     name = endTag.name();\n287                     if (name.equals(\"body\")) {\n288                         if (!tb.inScope(\"body\")) {\n289                             tb.error(this);\n290                             return false;\n291                         } else {\n292                             tb.transition(AfterBody);\n293                         }\n294                     } else if (name.equals(\"html\")) {\n295                         boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n296                         if (notIgnored)\n297                             return tb.process(endTag);\n298                     } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\n299                         if (!tb.inScope(name)) {\n300                             tb.error(this);\n301                             return false;\n302                         } else {\n303                             tb.generateImpliedEndTags();\n304                             if (!tb.currentElement().nodeName().equals(name))\n305                                 tb.error(this);\n306                             tb.popStackToClose(name);\n307                         }\n308                     } else if (name.equals(\"form\")) {\n309                         Element currentForm = tb.getFormElement();\n310                         tb.setFormElement(null);\n311                         if (currentForm == null || !tb.inScope(name)) {\n312                             tb.error(this);\n313                             return false;\n314                         } else {\n315                             tb.generateImpliedEndTags();\n316                             if (!tb.currentElement().nodeName().equals(name))\n317                                 tb.error(this);\n318                             tb.removeFromStack(currentForm);\n319                         }\n320                     } else if (name.equals(\"p\")) {\n321                         if (!tb.inButtonScope(name)) {\n322                             tb.error(this);\n323                             tb.process(new Token.StartTag(name)); \n324                             return tb.process(endTag);\n325                         } else {\n326                             tb.generateImpliedEndTags(name);\n327                             if (!tb.currentElement().nodeName().equals(name))\n328                                 tb.error(this);\n329                             tb.popStackToClose(name);\n330                         }\n331                     } else if (name.equals(\"li\")) {\n332                         if (!tb.inListItemScope(name)) {\n333                             tb.error(this);\n334                             return false;\n335                         } else {\n336                             tb.generateImpliedEndTags(name);\n337                             if (!tb.currentElement().nodeName().equals(name))\n338                                 tb.error(this);\n339                             tb.popStackToClose(name);\n340                         }\n341                     } else if (StringUtil.in(name, Constants.DdDt)) {\n342                         if (!tb.inScope(name)) {\n343                             tb.error(this);\n344                             return false;\n345                         } else {\n346                             tb.generateImpliedEndTags(name);\n347                             if (!tb.currentElement().nodeName().equals(name))\n348                                 tb.error(this);\n349                             tb.popStackToClose(name);\n350                         }\n351                     } else if (StringUtil.in(name, Constants.Headings)) {\n352                         if (!tb.inScope(Constants.Headings)) {\n353                             tb.error(this);\n354                             return false;\n355                         } else {\n356                             tb.generateImpliedEndTags(name);\n357                             if (!tb.currentElement().nodeName().equals(name))\n358                                 tb.error(this);\n359                             tb.popStackToClose(Constants.Headings);\n360                         }\n361                     } else if (name.equals(\"sarcasm\")) {\n362                         return anyOtherEndTag(t, tb);\n363                     } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n364                         OUTER:\n365                         for (int i = 0; i < 8; i++) {\n366                             Element formatEl = tb.getActiveFormattingElement(name);\n367                             if (formatEl == null)\n368                                 return anyOtherEndTag(t, tb);\n369                             else if (!tb.onStack(formatEl)) {\n370                                 tb.error(this);\n371                                 tb.removeFromActiveFormattingElements(formatEl);\n372                                 return true;\n373                             } else if (!tb.inScope(formatEl.nodeName())) {\n374                                 tb.error(this);\n375                                 return false;\n376                             } else if (tb.currentElement() != formatEl)\n377                                 tb.error(this);\n378                             Element furthestBlock = null;\n379                             Element commonAncestor = null;\n380                             boolean seenFormattingElement = false;\n381                             LinkedList<Element> stack = tb.getStack();\n382                             final int stackSize = stack.size();\n383                             for (int si = 0; si < stackSize && si < 64; si++) {\n384                                 Element el = stack.get(si);\n385                                 if (el == formatEl) {\n386                                     commonAncestor = stack.get(si - 1);\n387                                     seenFormattingElement = true;\n388                                 } else if (seenFormattingElement && tb.isSpecial(el)) {\n389                                     furthestBlock = el;\n390                                     break;\n391                                 }\n392                             }\n393                             if (furthestBlock == null) {\n394                                 tb.popStackToClose(formatEl.nodeName());\n395                                 tb.removeFromActiveFormattingElements(formatEl);\n396                                 return true;\n397                             }\n398                             Element node = furthestBlock;\n399                             Element lastNode = furthestBlock;\n400                             INNER:\n401                             for (int j = 0; j < 3; j++) {\n402                                 if (tb.onStack(node))\n403                                     node = tb.aboveOnStack(node);\n404                                 if (!tb.isInActiveFormattingElements(node)) { \n405                                     tb.removeFromStack(node);\n406                                     continue INNER;\n407                                 } else if (node == formatEl)\n408                                     break INNER;\n409                                 Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n410                                 tb.replaceActiveFormattingElement(node, replacement);\n411                                 tb.replaceOnStack(node, replacement);\n412                                 node = replacement;\n413                                 if (lastNode == furthestBlock) {\n414                                 }\n415                                 if (lastNode.parent() != null)\n416                                     lastNode.remove();\n417                                 node.appendChild(lastNode);\n418                                 lastNode = node;\n419                             }\n420                             if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n421                                 if (lastNode.parent() != null)\n422                                     lastNode.remove();\n423                                 tb.insertInFosterParent(lastNode);\n424                             } else {\n425                                 if (lastNode.parent() != null)\n426                                     lastNode.remove();\n427                                 commonAncestor.appendChild(lastNode);\n428                             }\n429                             Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n430                             adopter.attributes().addAll(formatEl.attributes());\n431                             Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n432                             for (Node childNode : childNodes) {\n433                                 adopter.appendChild(childNode); \n434                             }\n435                             furthestBlock.appendChild(adopter);\n436                             tb.removeFromActiveFormattingElements(formatEl);\n437                             tb.removeFromStack(formatEl);\n438                             tb.insertOnStackAfter(furthestBlock, adopter);\n439                         }\n440                     } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n441                         if (!tb.inScope(\"name\")) {\n442                             if (!tb.inScope(name)) {\n443                                 tb.error(this);\n444                                 return false;\n445                             }\n446                             tb.generateImpliedEndTags();\n447                             if (!tb.currentElement().nodeName().equals(name))\n448                                 tb.error(this);\n449                             tb.popStackToClose(name);\n450                             tb.clearFormattingElementsToLastMarker();\n451                         }\n452                     } else if (name.equals(\"br\")) {\n453                         tb.error(this);\n454                         tb.process(new Token.StartTag(\"br\"));\n455                         return false;\n456                     } else {\n457                         return anyOtherEndTag(t, tb);\n458                     }\n459                     break;\n460                 case EOF:\n461                     break;\n462             }\n463             return true;\n464         }\n", "fixed_code": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else if (isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            return false; \n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            return false; \n                        } else if (!tb.framesetOk()) {\n                            return false; \n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            while (stack.size() > 1)\n                                stack.removeLast();\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.in(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.in(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        if (tb.getFromStack(\"svg\") == null)\n                            return tb.process(startTag.name(\"img\")); \n                        else\n                            tb.insert(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n                        tb.process(new Token.Character(prompt));\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); \n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.in(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); \n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n                        OUTER:\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            LinkedList<Element> stack = tb.getStack();\n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            INNER:\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { \n                                    tb.removeFromStack(node);\n                                    continue INNER;\n                                } else if (node == formatEl)\n                                    break INNER;\n                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n                                if (lastNode == furthestBlock) {\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n                                lastNode = node;\n                            }\n                            if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); \n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n                    break;\n                case EOF:\n                    break;\n            }\n            return true;\n        }\n"}
{"bug_id": "Math-20", "buggy_code": "1         public double[] repairAndDecode(final double[] x) {\n2             return\n3                 decode(x);\n4         }\n", "fixed_code": "        public double[] repairAndDecode(final double[] x) {\n            return boundaries != null && isRepairMode ?\n                decode(repair(x)) :\n                decode(x);\n        }\n"}
{"bug_id": "Mockito-7", "buggy_code": "1         private void readTypeVariables() {\n2             for (Type type : typeVariable.getBounds()) {\n3                 registerTypeVariablesOn(type);\n4             }\n5             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n6         }\n", "fixed_code": "        private void readTypeVariables() {\n            for (Type type : typeVariable.getBounds()) {\n                registerTypeVariablesOn(type);\n            }\n            registerTypeParametersOn(new TypeVariable[] { typeVariable });\n            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n        }\n"}
{"bug_id": "JacksonDatabind-1", "buggy_code": "1     public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n2         throws Exception\n3     {\n4         Object value = get(bean);\n5         if (value == null) { \n6             if (_nullSerializer != null) {\n7                 _nullSerializer.serialize(null, jgen, prov);\n8             } else { \n9                 jgen.writeNull();\n10             }\n11         }\n12         JsonSerializer<Object> ser = _serializer;\n13         if (ser == null) {\n14             Class<?> cls = value.getClass();\n15             PropertySerializerMap map = _dynamicSerializers;\n16             ser = map.serializerFor(cls);\n17             if (ser == null) {\n18                 ser = _findAndAddDynamic(map, cls, prov);\n19             }\n20         }\n21         if (_suppressableValue != null) {\n22             if (MARKER_FOR_EMPTY == _suppressableValue) {\n23                 if (ser.isEmpty(value)) { \n24                     serializeAsPlaceholder(bean, jgen, prov);\n25                     return;\n26                 }\n27             } else if (_suppressableValue.equals(value)) { \n28                 serializeAsPlaceholder(bean, jgen, prov);\n29                 return;\n30             }\n31         }\n32         if (value == bean) {\n33             _handleSelfReference(bean, ser);\n34         }\n35         if (_typeSerializer == null) {\n36             ser.serialize(value, jgen, prov);\n37         } else {\n38             ser.serializeWithType(value, jgen, prov, _typeSerializer);\n39         }\n40     }\n", "fixed_code": "    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) { \n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, jgen, prov);\n            } else { \n                jgen.writeNull();\n            }\n            return;\n        }\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(value)) { \n                    serializeAsPlaceholder(bean, jgen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { \n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        }\n        if (value == bean) {\n            _handleSelfReference(bean, ser);\n        }\n        if (_typeSerializer == null) {\n            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n"}
{"bug_id": "Mockito-12", "buggy_code": "1     public Class getGenericType(Field field) {        \n2         Type generic = field.getGenericType();\n3         if (generic != null && generic instanceof ParameterizedType) {\n4             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n5                 return (Class) actual;\n6         }\n7         return Object.class;\n8     }\n", "fixed_code": "    public Class getGenericType(Field field) {        \n        Type generic = field.getGenericType();\n        if (generic != null && generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            if (actual instanceof Class) {\n                return (Class) actual;\n            } else if (actual instanceof ParameterizedType) {\n                return (Class) ((ParameterizedType) actual).getRawType();\n            }\n        }\n        return Object.class;\n    }\n"}
{"bug_id": "Codec-3", "buggy_code": "1     private int handleG(String value, \n2                         DoubleMetaphoneResult result, \n3                         int index, \n4                         boolean slavoGermanic) {\n5         if (charAt(value, index + 1) == 'H') {\n6             index = handleGH(value, result, index);\n7         } else if (charAt(value, index + 1) == 'N') {\n8             if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n9                 result.append(\"KN\", \"N\");\n10             } else if (!contains(value, index + 2, 2, \"EY\") && \n11                        charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n12                 result.append(\"N\", \"KN\");\n13             } else {\n14                 result.append(\"KN\");\n15             }\n16             index = index + 2;\n17         } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n18             result.append(\"KL\", \"L\");\n19             index += 2;\n20         } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n21             result.append('K', 'J');\n22             index += 2;\n23         } else if ((contains(value, index + 1, 2, \"ER\") || \n24                     charAt(value, index + 1) == 'Y') &&\n25                    !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n26                    !contains(value, index - 1, 1, \"E\", \"I\") && \n27                    !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n28             result.append('K', 'J');\n29             index += 2;\n30         } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n31                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n32             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n33                 result.append('K');\n34             } else if (contains(value, index + 1, 4, \"IER\")) {\n35                 result.append('J');\n36             } else {\n37                 result.append('J', 'K');\n38             }\n39             index += 2;\n40         } else if (charAt(value, index + 1) == 'G') {\n41             index += 2;\n42             result.append('K');\n43         } else {\n44             index++;\n45             result.append('K');\n46         }\n47         return index;\n48     }\n", "fixed_code": "    private int handleG(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            index = handleGH(value, result, index);\n        } else if (charAt(value, index + 1) == 'N') {\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n                result.append(\"KN\", \"N\");\n            } else if (!contains(value, index + 2, 2, \"EY\") && \n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n                result.append(\"N\", \"KN\");\n            } else {\n                result.append(\"KN\");\n            }\n            index = index + 2;\n        } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n            result.append(\"KL\", \"L\");\n            index += 2;\n        } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                result.append('K');\n            } else if (contains(value, index + 1, 3, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n"}
{"bug_id": "Jsoup-19", "buggy_code": "1     private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n2         String value = el.absUrl(attr.getKey());\n3         if (!preserveRelativeLinks)\n4             attr.setValue(value);\n5         for (Protocol protocol : protocols) {\n6             String prot = protocol.toString() + \":\";\n7             if (value.toLowerCase().startsWith(prot)) {\n8                 return true;\n9             }\n10         }\n11         return false;\n12     }\n", "fixed_code": "    private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n        String value = el.absUrl(attr.getKey());\n        if (value.length() == 0)\n            value = attr.getValue(); \n        if (!preserveRelativeLinks)\n            attr.setValue(value);\n        for (Protocol protocol : protocols) {\n            String prot = protocol.toString() + \":\";\n            if (value.toLowerCase().startsWith(prot)) {\n                return true;\n            }\n        }\n        return false;\n    }\n"}
{"bug_id": "Jsoup-89", "buggy_code": "1     public String setValue(String val) {\n2         String oldVal = parent.get(this.key);\n3         if (parent != null) {\n4             int i = parent.indexOfKey(this.key);\n5             if (i != Attributes.NotFound)\n6                 parent.vals[i] = val;\n7         }\n8         this.val = val;\n9         return Attributes.checkNotNull(oldVal);\n10     }\n", "fixed_code": "    public String setValue(String val) {\n        String oldVal = this.val;\n        if (parent != null) {\n            oldVal = parent.get(this.key); \n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.vals[i] = val;\n        }\n        this.val = val;\n        return Attributes.checkNotNull(oldVal);\n    }\n"}
{"bug_id": "JacksonDatabind-44", "buggy_code": "1     protected JavaType _narrow(Class<?> subclass)\n2     {\n3         if (_class == subclass) {\n4             return this;\n5         }\n6             return new SimpleType(subclass, _bindings, this, _superInterfaces,\n7                     _valueHandler, _typeHandler, _asStatic);\n8     }\n", "fixed_code": "    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        if (!_class.isAssignableFrom(subclass)) {\n            return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                    _valueHandler, _typeHandler, _asStatic);\n        }\n        Class<?> next = subclass.getSuperclass();\n        if (next == _class) { \n            return new SimpleType(subclass, _bindings, this,\n                    _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n        }\n        if ((next != null) && _class.isAssignableFrom(next)) {\n            JavaType superb = _narrow(next);\n            return new SimpleType(subclass, _bindings, superb,\n                    null, _valueHandler, _typeHandler, _asStatic);\n        }\n        Class<?>[] nextI = subclass.getInterfaces();\n        for (Class<?> iface : nextI) {\n            if (iface == _class) { \n                return new SimpleType(subclass, _bindings, null,\n                        new JavaType[] { this }, _valueHandler, _typeHandler, _asStatic);\n            }\n            if (_class.isAssignableFrom(iface)) { \n                JavaType superb = _narrow(iface);\n                return new SimpleType(subclass, _bindings, null,\n                        new JavaType[] { superb }, _valueHandler, _typeHandler, _asStatic);\n            }\n        }\n        throw new IllegalArgumentException(\"Internal error: Can not resolve sub-type for Class \"+subclass.getName()+\" to \"\n                +_class.getName());\n    }\n"}
{"bug_id": "Closure-62", "buggy_code": "1   private String format(JSError error, boolean warning) {\n2     SourceExcerptProvider source = getSource();\n3     String sourceExcerpt = source == null ? null :\n4         excerpt.get(\n5             source, error.sourceName, error.lineNumber, excerptFormatter);\n6     StringBuilder b = new StringBuilder();\n7     if (error.sourceName != null) {\n8       b.append(error.sourceName);\n9       if (error.lineNumber > 0) {\n10         b.append(':');\n11         b.append(error.lineNumber);\n12       }\n13       b.append(\": \");\n14     }\n15     b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n16     b.append(\" - \");\n17     b.append(error.description);\n18     b.append('\\n');\n19     if (sourceExcerpt != null) {\n20       b.append(sourceExcerpt);\n21       b.append('\\n');\n22       int charno = error.getCharno();\n23       if (excerpt.equals(LINE)\n24           && 0 <= charno && charno < sourceExcerpt.length()) {\n25         for (int i = 0; i < charno; i++) {\n26           char c = sourceExcerpt.charAt(i);\n27           if (Character.isWhitespace(c)) {\n28             b.append(c);\n29           } else {\n30             b.append(' ');\n31           }\n32         }\n33         b.append(\"^\\n\");\n34       }\n35     }\n36     return b.toString();\n37   }\n", "fixed_code": "  private String format(JSError error, boolean warning) {\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n      if (excerpt.equals(LINE)\n          && 0 <= charno && charno <= sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n"}
{"bug_id": "Jsoup-93", "buggy_code": "1     public List<Connection.KeyVal> formData() {\n2         ArrayList<Connection.KeyVal> data = new ArrayList<>();\n3         for (Element el: elements) {\n4             if (!el.tag().isFormSubmittable()) continue; \n5             if (el.hasAttr(\"disabled\")) continue; \n6             String name = el.attr(\"name\");\n7             if (name.length() == 0) continue;\n8             String type = el.attr(\"type\");\n9             if (\"select\".equals(el.normalName())) {\n10                 Elements options = el.select(\"option[selected]\");\n11                 boolean set = false;\n12                 for (Element option: options) {\n13                     data.add(HttpConnection.KeyVal.create(name, option.val()));\n14                     set = true;\n15                 }\n16                 if (!set) {\n17                     Element option = el.select(\"option\").first();\n18                     if (option != null)\n19                         data.add(HttpConnection.KeyVal.create(name, option.val()));\n20                 }\n21             } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n22                 if (el.hasAttr(\"checked\")) {\n23                     final String val = el.val().length() >  0 ? el.val() : \"on\";\n24                     data.add(HttpConnection.KeyVal.create(name, val));\n25                 }\n26             } else {\n27                 data.add(HttpConnection.KeyVal.create(name, el.val()));\n28             }\n29         }\n30         return data;\n31     }\n", "fixed_code": "    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<>();\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; \n            if (el.hasAttr(\"disabled\")) continue; \n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n            if (type.equalsIgnoreCase(\"button\")) continue; \n            if (\"select\".equals(el.normalName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n        return data;\n    }\n"}
{"bug_id": "Closure-21", "buggy_code": "1   public void visit(NodeTraversal t, Node n, Node parent) {\n2     if (n.isEmpty() ||\n3         n.isComma()) {\n4       return;\n5     }\n6     if (parent == null) {\n7       return;\n8     }\n9     if (n.isExprResult()) {\n10       return;\n11     }\n12     if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n13       return;\n14     }\n15     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n16     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n17     if (parent.getType() == Token.COMMA) {\n18       if (isResultUsed) {\n19         return;\n20       }\n21       if (n == parent.getLastChild()) {\n22         for (Node an : parent.getAncestors()) {\n23           int ancestorType = an.getType();\n24           if (ancestorType == Token.COMMA) continue;\n25           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n26           else break;\n27         }\n28       }\n29     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n30       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n31         return;\n32       }\n33     }\n34     if (\n35         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n36       String msg = \"This code lacks side-effects. Is there a bug?\";\n37       if (n.isString()) {\n38         msg = \"Is there a missing '+' on the previous line?\";\n39       } else if (isSimpleOp) {\n40         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n41             \"' operator is not being used.\";\n42       }\n43       t.getCompiler().report(\n44           t.makeError(n, level, USELESS_CODE_ERROR, msg));\n45       if (!NodeUtil.isStatement(n)) {\n46         problemNodes.add(n);\n47       }\n48     }\n49   }\n", "fixed_code": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n    if (parent == null) {\n      return;\n    }\n    if (n.isExprResult() || n.isBlock()) {\n      return;\n    }\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"}
{"bug_id": "Math-8", "buggy_code": "1     public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n2         if (sampleSize <= 0) {\n3             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n4                     sampleSize);\n5         }\n6         final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n7         for (int i = 0; i < sampleSize; i++) {\n8             out[i] = sample();\n9         }\n10         return out;\n11     }\n", "fixed_code": "    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n        final Object[] out = new Object[sampleSize];\n        for (int i = 0; i < sampleSize; i++) {\n            out[i] = sample();\n        }\n        return out;\n    }\n"}
{"bug_id": "JacksonDatabind-46", "buggy_code": "1     public StringBuilder getGenericSignature(StringBuilder sb)\n2     {\n3         _classSignature(_class, sb, false);\n4         sb.append('<');\n5         sb = _referencedType.getGenericSignature(sb);\n6         sb.append(';');\n7         return sb;\n8     }\n", "fixed_code": "    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n        sb.append(\">;\");\n        return sb;\n    }\n"}
{"bug_id": "JacksonDatabind-91", "buggy_code": "1     private boolean _hasCustomHandlers(JavaType t) {\n2         if (t.isContainerType()) {\n3             JavaType ct = t.getContentType();\n4             if (ct != null) {\n5                 return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n6             }\n7         }\n8         return false;\n9     }\n", "fixed_code": "    private boolean _hasCustomHandlers(JavaType t) {\n        if (t.isContainerType()) {\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {\n                    return true;\n                }\n            }\n            if (t.isMapLikeType()) {\n                JavaType kt = t.getKeyType();\n                if (kt.getValueHandler() != null) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n"}
{"bug_id": "Lang-6", "buggy_code": "1     public final void translate(CharSequence input, Writer out) throws IOException {\n2         if (out == null) {\n3             throw new IllegalArgumentException(\"The Writer must not be null\");\n4         }\n5         if (input == null) {\n6             return;\n7         }\n8         int pos = 0;\n9         int len = input.length();\n10         while (pos < len) {\n11             int consumed = translate(input, pos, out);\n12             if (consumed == 0) {\n13                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n14                 out.write(c);\n15                 pos+= c.length;\n16                 continue;\n17             }\n18             for (int pt = 0; pt < consumed; pt++) {\n19                 pos += Character.charCount(Character.codePointAt(input, pos));\n20             }\n21         }\n22     }\n", "fixed_code": "    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pt));\n            }\n        }\n    }\n"}
{"bug_id": "Compress-19", "buggy_code": "1     public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n2                                             boolean hasCompressedSize,\n3                                             boolean hasRelativeHeaderOffset,\n4                                             boolean hasDiskStart)\n5         throws ZipException {\n6         if (rawCentralDirectoryData != null) {\n7             int expectedLength = (hasUncompressedSize ? DWORD : 0)\n8                 + (hasCompressedSize ? DWORD : 0)\n9                 + (hasRelativeHeaderOffset ? DWORD : 0)\n10                 + (hasDiskStart ? WORD : 0);\n11             if (rawCentralDirectoryData.length != expectedLength) {\n12                 throw new ZipException(\"central directory zip64 extended\"\n13                                        + \" information extra field's length\"\n14                                        + \" doesn't match central directory\"\n15                                        + \" data.  Expected length \"\n16                                        + expectedLength + \" but is \"\n17                                        + rawCentralDirectoryData.length);\n18             }\n19             int offset = 0;\n20             if (hasUncompressedSize) {\n21                 size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n22                 offset += DWORD;\n23             }\n24             if (hasCompressedSize) {\n25                 compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n26                                                          offset);\n27                 offset += DWORD;\n28             }\n29             if (hasRelativeHeaderOffset) {\n30                 relativeHeaderOffset =\n31                     new ZipEightByteInteger(rawCentralDirectoryData, offset);\n32                 offset += DWORD;\n33             }\n34             if (hasDiskStart) {\n35                 diskStart = new ZipLong(rawCentralDirectoryData, offset);\n36                 offset += WORD;\n37             }\n38         }\n39     }\n", "fixed_code": "    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length < expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                offset += WORD;\n            }\n        }\n    }\n"}
{"bug_id": "JacksonCore-7", "buggy_code": "1     public int writeValue() {\n2         if (_type == TYPE_OBJECT) {\n3             _gotName = false;\n4             ++_index;\n5             return STATUS_OK_AFTER_COLON;\n6         }\n7         if (_type == TYPE_ARRAY) {\n8             int ix = _index;\n9             ++_index;\n10             return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n11         }\n12         ++_index;\n13         return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n14     }\n", "fixed_code": "    public int writeValue() {\n        if (_type == TYPE_OBJECT) {\n            if (!_gotName) {\n                return STATUS_EXPECT_NAME;\n            }\n            _gotName = false;\n            ++_index;\n            return STATUS_OK_AFTER_COLON;\n        }\n        if (_type == TYPE_ARRAY) {\n            int ix = _index;\n            ++_index;\n            return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n        }\n        ++_index;\n        return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n    }\n"}
{"bug_id": "Compress-5", "buggy_code": "1     public int read(byte[] buffer, int start, int length) throws IOException {\n2         if (closed) {\n3             throw new IOException(\"The stream is closed\");\n4         }\n5         if (inf.finished() || current == null) {\n6             return -1;\n7         }\n8         if (start <= buffer.length && length >= 0 && start >= 0\n9             && buffer.length - start >= length) {\n10             if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n11                 int csize = (int) current.getSize();\n12                 if (readBytesOfEntry >= csize) {\n13                     return -1;\n14                 }\n15                 if (offsetInBuffer >= lengthOfLastRead) {\n16                     offsetInBuffer = 0;\n17                     if ((lengthOfLastRead = in.read(buf)) == -1) {\n18                         return -1;\n19                     }\n20                     count(lengthOfLastRead);\n21                     bytesReadFromStream += lengthOfLastRead;\n22                 }\n23                 int toRead = length > lengthOfLastRead\n24                     ? lengthOfLastRead - offsetInBuffer\n25                     : length;\n26                 if ((csize - readBytesOfEntry) < toRead) {\n27                     toRead = csize - readBytesOfEntry;\n28                 }\n29                 System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n30                 offsetInBuffer += toRead;\n31                 readBytesOfEntry += toRead;\n32                 crc.update(buffer, start, toRead);\n33                 return toRead;\n34             }\n35             if (inf.needsInput()) {\n36                 fill();\n37                 if (lengthOfLastRead > 0) {\n38                     bytesReadFromStream += lengthOfLastRead;\n39                 }\n40             }\n41             int read = 0;\n42             try {\n43                 read = inf.inflate(buffer, start, length);\n44             } catch (DataFormatException e) {\n45                 throw new ZipException(e.getMessage());\n46             }\n47             if (read == 0 && inf.finished()) {\n48                 return -1;\n49             }\n50             crc.update(buffer, start, read);\n51             return read;\n52         }\n53         throw new ArrayIndexOutOfBoundsException();\n54     }\n", "fixed_code": "    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (inf.finished() || current == null) {\n            return -1;\n        }\n        if (start <= buffer.length && length >= 0 && start >= 0\n            && buffer.length - start >= length) {\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                int csize = (int) current.getSize();\n                if (readBytesOfEntry >= csize) {\n                    return -1;\n                }\n                if (offsetInBuffer >= lengthOfLastRead) {\n                    offsetInBuffer = 0;\n                    if ((lengthOfLastRead = in.read(buf)) == -1) {\n                        return -1;\n                    }\n                    count(lengthOfLastRead);\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n                int toRead = length > lengthOfLastRead\n                    ? lengthOfLastRead - offsetInBuffer\n                    : length;\n                if ((csize - readBytesOfEntry) < toRead) {\n                    toRead = csize - readBytesOfEntry;\n                }\n                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n                offsetInBuffer += toRead;\n                readBytesOfEntry += toRead;\n                crc.update(buffer, start, toRead);\n                return toRead;\n            }\n            if (inf.needsInput()) {\n                fill();\n                if (lengthOfLastRead > 0) {\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n            }\n            int read = 0;\n            try {\n                read = inf.inflate(buffer, start, length);\n            } catch (DataFormatException e) {\n                throw new ZipException(e.getMessage());\n            }\n            if (read == 0) {\n                if (inf.finished()) {\n                    return -1;\n                } else if (lengthOfLastRead == -1) {\n                    throw new IOException(\"Truncated ZIP file\");\n                }\n            }\n            crc.update(buffer, start, read);\n            return read;\n        }\n        throw new ArrayIndexOutOfBoundsException();\n    }\n"}
{"bug_id": "JacksonCore-5", "buggy_code": "1     private final static int _parseIndex(String str) {\n2         final int len = str.length();\n3         if (len == 0 || len > 10) {\n4             return -1;\n5         }\n6         for (int i = 0; i < len; ++i) {\n7             char c = str.charAt(i++);\n8             if (c > '9' || c < '0') {\n9                 return -1;\n10             }\n11         }\n12         if (len == 10) {\n13             long l = NumberInput.parseLong(str);\n14             if (l > Integer.MAX_VALUE) {\n15                 return -1;\n16             }\n17         }\n18         return NumberInput.parseInt(str);\n19     }\n", "fixed_code": "    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n"}
{"bug_id": "JacksonDatabind-12", "buggy_code": "1     public boolean isCachable() {\n2         return (_valueTypeDeserializer == null)\n3                 && (_ignorableProperties == null);\n4     }\n", "fixed_code": "    public boolean isCachable() {\n        return (_valueDeserializer == null)\n                && (_keyDeserializer == null)\n                && (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }\n"}
{"bug_id": "Compress-46", "buggy_code": "1     private static ZipLong unixTimeToZipLong(long l) {\n2         final long TWO_TO_32 = 0x100000000L;\n3         if (l >= TWO_TO_32) {\n4             throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n5         }\n6         return new ZipLong(l);\n7     }\n", "fixed_code": "    private static ZipLong unixTimeToZipLong(long l) {\n        if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n        }\n        return new ZipLong(l);\n    }\n"}
{"bug_id": "JxPath-12", "buggy_code": "1     public static boolean testNode(Node node, NodeTest test) {\n2         if (test == null) {\n3             return true;\n4         }\n5         if (test instanceof NodeNameTest) {\n6             if (node.getNodeType() != Node.ELEMENT_NODE) {\n7                 return false;\n8             }\n9             NodeNameTest nodeNameTest = (NodeNameTest) test;\n10             QName testName = nodeNameTest.getNodeName();\n11             String namespaceURI = nodeNameTest.getNamespaceURI();\n12             boolean wildcard = nodeNameTest.isWildcard();\n13             String testPrefix = testName.getPrefix();\n14             if (wildcard && testPrefix == null) {\n15                 return true;\n16             }\n17             if (wildcard\n18                 || testName.getName()\n19                         .equals(DOMNodePointer.getLocalName(node))) {\n20                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n21                 return equalStrings(namespaceURI, nodeNS);\n22             }\n23             return false;\n24         }\n25         if (test instanceof NodeTypeTest) {\n26             int nodeType = node.getNodeType();\n27             switch (((NodeTypeTest) test).getNodeType()) {\n28                 case Compiler.NODE_TYPE_NODE :\n29                     return nodeType == Node.ELEMENT_NODE\n30                             || nodeType == Node.DOCUMENT_NODE;\n31                 case Compiler.NODE_TYPE_TEXT :\n32                     return nodeType == Node.CDATA_SECTION_NODE\n33                         || nodeType == Node.TEXT_NODE;\n34                 case Compiler.NODE_TYPE_COMMENT :\n35                     return nodeType == Node.COMMENT_NODE;\n36                 case Compiler.NODE_TYPE_PI :\n37                     return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n38             }\n39             return false;\n40         }\n41         if (test instanceof ProcessingInstructionTest) {\n42             if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n43                 String testPI = ((ProcessingInstructionTest) test).getTarget();\n44                 String nodePI = ((ProcessingInstruction) node).getTarget();\n45                 return testPI.equals(nodePI);\n46             }\n47         }\n48         return false;\n49     }\n", "fixed_code": "    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n"}
{"bug_id": "Math-63", "buggy_code": "1     public static boolean equals(double x, double y) {\n2         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n3     }\n", "fixed_code": "    public static boolean equals(double x, double y) {\n        return equals(x, y, 1);\n    }\n"}
{"bug_id": "Math-60", "buggy_code": "1     public double cumulativeProbability(double x) throws MathException {\n2         final double dev = x - mean;\n3         try {\n4         return 0.5 * (1.0 + Erf.erf((dev) /\n5                     (standardDeviation * FastMath.sqrt(2.0))));\n6         } catch (MaxIterationsExceededException ex) {\n7             if (x < (mean - 20 * standardDeviation)) { \n8                 return 0;\n9             } else if (x > (mean + 20 * standardDeviation)) {\n10                 return 1;\n11             } else {\n12                 throw ex;\n13             }\n14         }\n15     }\n", "fixed_code": "    public double cumulativeProbability(double x) throws MathException {\n        final double dev = x - mean;\n        if (FastMath.abs(dev) > 40 * standardDeviation) { \n            return dev < 0 ? 0.0d : 1.0d;\n        }\n        return 0.5 * (1.0 + Erf.erf((dev) /\n                    (standardDeviation * FastMath.sqrt(2.0))));\n    }\n"}
{"bug_id": "Lang-29", "buggy_code": "1     static float toJavaVersionInt(String version) {\n2         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n3     }\n", "fixed_code": "    static int toJavaVersionInt(String version) {\n        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n    }\n"}
{"bug_id": "JxPath-5", "buggy_code": "1     private int compareNodePointers(\n2         NodePointer p1,\n3         int depth1,\n4         NodePointer p2,\n5         int depth2) \n6     {\n7         if (depth1 < depth2) {\n8             int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n9             return r == 0 ? -1 : r;\n10         }\n11         if (depth1 > depth2) {\n12             int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n13             return r == 0 ? 1 : r;\n14         }\n15         if (p1 == null && p2 == null) {\n16             return 0;\n17         }\n18         if (p1 != null && p1.equals(p2)) {\n19             return 0;\n20         }\n21         if (depth1 == 1) {\n22             throw new JXPathException(\n23                     \"Cannot compare pointers that do not belong to the same tree: '\"\n24                             + p1 + \"' and '\" + p2 + \"'\");\n25         }\n26         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n27         if (r != 0) {\n28             return r;\n29         }\n30         return p1.parent.compareChildNodePointers(p1, p2);\n31     }\n", "fixed_code": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n        if (depth1 == 1) {\n            return 0;\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }\n"}
{"bug_id": "Math-59", "buggy_code": "1     public static float max(final float a, final float b) {\n2         return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n3     }\n", "fixed_code": "    public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n    }\n"}
{"bug_id": "Lang-33", "buggy_code": "1     public static Class<?>[] toClass(Object[] array) {\n2         if (array == null) {\n3             return null;\n4         } else if (array.length == 0) {\n5             return ArrayUtils.EMPTY_CLASS_ARRAY;\n6         }\n7         Class<?>[] classes = new Class[array.length];\n8         for (int i = 0; i < array.length; i++) {\n9             classes[i] = array[i].getClass();\n10         }\n11         return classes;\n12     }\n", "fixed_code": "    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i] == null ? null : array[i].getClass();\n        }\n        return classes;\n    }\n"}
{"bug_id": "JacksonDatabind-74", "buggy_code": "1     protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n2             TokenBuffer tb) throws IOException\n3     {\n4         JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n5         if (deser != null) {\n6             if (tb != null) {\n7                 tb.writeEndObject();\n8                 p = tb.asParser(p);\n9                 p.nextToken();\n10             }\n11             return deser.deserialize(p, ctxt);\n12         }\n13         Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n14         if (result != null) {\n15             return result;\n16         }\n17         if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n18             return super.deserializeTypedFromAny(p, ctxt);\n19         }\n20         ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n21                 \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n22         return null;\n23     }\n", "fixed_code": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n            TokenBuffer tb) throws IOException\n    {\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                p = tb.asParser(p);\n                p.nextToken();\n            }\n            return deser.deserialize(p, ctxt);\n        }\n        Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n            return super.deserializeTypedFromAny(p, ctxt);\n        } else if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                String str = p.getText().trim();\n                if (str.isEmpty()) {\n                    return null;\n                }\n            }\n        }\n        ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n        return null;\n    }\n"}
{"bug_id": "Compress-15", "buggy_code": "1     public boolean equals(Object obj) {\n2         if (this == obj) {\n3             return true;\n4         }\n5         if (obj == null || getClass() != obj.getClass()) {\n6             return false;\n7         }\n8         ZipArchiveEntry other = (ZipArchiveEntry) obj;\n9         String myName = getName();\n10         String otherName = other.getName();\n11         if (myName == null) {\n12             if (otherName != null) {\n13                 return false;\n14             }\n15         } else if (!myName.equals(otherName)) {\n16             return false;\n17         }\n18         String myComment = getComment();\n19         String otherComment = other.getComment();\n20         if (myComment == null) {\n21             if (otherComment != null) {\n22                 return false;\n23             }\n24         } else if (!myComment.equals(otherComment)) {\n25             return false;\n26         }\n27         return getTime() == other.getTime()\n28             && getInternalAttributes() == other.getInternalAttributes()\n29             && getPlatform() == other.getPlatform()\n30             && getExternalAttributes() == other.getExternalAttributes()\n31             && getMethod() == other.getMethod()\n32             && getSize() == other.getSize()\n33             && getCrc() == other.getCrc()\n34             && getCompressedSize() == other.getCompressedSize()\n35             && Arrays.equals(getCentralDirectoryExtra(),\n36                              other.getCentralDirectoryExtra())\n37             && Arrays.equals(getLocalFileDataExtra(),\n38                              other.getLocalFileDataExtra())\n39             && gpb.equals(other.gpb);\n40     }\n", "fixed_code": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        ZipArchiveEntry other = (ZipArchiveEntry) obj;\n        String myName = getName();\n        String otherName = other.getName();\n        if (myName == null) {\n            if (otherName != null) {\n                return false;\n            }\n        } else if (!myName.equals(otherName)) {\n            return false;\n        }\n        String myComment = getComment();\n        String otherComment = other.getComment();\n        if (myComment == null) {\n            myComment = \"\";\n        }\n        if (otherComment == null) {\n            otherComment = \"\";\n        }\n        return getTime() == other.getTime()\n            && myComment.equals(otherComment)\n            && getInternalAttributes() == other.getInternalAttributes()\n            && getPlatform() == other.getPlatform()\n            && getExternalAttributes() == other.getExternalAttributes()\n            && getMethod() == other.getMethod()\n            && getSize() == other.getSize()\n            && getCrc() == other.getCrc()\n            && getCompressedSize() == other.getCompressedSize()\n            && Arrays.equals(getCentralDirectoryExtra(),\n                             other.getCentralDirectoryExtra())\n            && Arrays.equals(getLocalFileDataExtra(),\n                             other.getLocalFileDataExtra())\n            && gpb.equals(other.gpb);\n    }\n"}
{"bug_id": "Closure-31", "buggy_code": "1   Node parseInputs() {\n2     boolean devMode = options.devMode != DevMode.OFF;\n3     if (externsRoot != null) {\n4       externsRoot.detachChildren();\n5     }\n6     if (jsRoot != null) {\n7       jsRoot.detachChildren();\n8     }\n9     jsRoot = IR.block();\n10     jsRoot.setIsSyntheticBlock(true);\n11     externsRoot = IR.block();\n12     externsRoot.setIsSyntheticBlock(true);\n13     externAndJsRoot = IR.block(externsRoot, jsRoot);\n14     externAndJsRoot.setIsSyntheticBlock(true);\n15     if (options.tracer.isOn()) {\n16       tracker = new PerformanceTracker(jsRoot, options.tracer);\n17       addChangeHandler(tracker.getCodeChangeHandler());\n18     }\n19     Tracer tracer = newTracer(\"parseInputs\");\n20     try {\n21       for (CompilerInput input : externs) {\n22         Node n = input.getAstRoot(this);\n23         if (hasErrors()) {\n24           return null;\n25         }\n26         externsRoot.addChildToBack(n);\n27       }\n28       if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n29         processAMDAndCommonJSModules();\n30       }\n31       boolean staleInputs = false;\n32       if (options.dependencyOptions.needsManagement() &&\n33           !options.skipAllPasses &&\n34           options.closurePass) {\n35         for (CompilerInput input : inputs) {\n36           for (String provide : input.getProvides()) {\n37             getTypeRegistry().forwardDeclareType(provide);\n38           }\n39         }\n40         try {\n41           inputs =\n42               (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n43               .manageDependencies(options.dependencyOptions, inputs);\n44           staleInputs = true;\n45         } catch (CircularDependencyException e) {\n46           report(JSError.make(\n47               JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n48           if (hasErrors()) {\n49             return null;\n50           }\n51         } catch (MissingProvideException e) {\n52           report(JSError.make(\n53               MISSING_ENTRY_ERROR, e.getMessage()));\n54           if (hasErrors()) {\n55             return null;\n56           }\n57         }\n58       }\n59       for (CompilerInput input : inputs) {\n60         Node n = input.getAstRoot(this);\n61         if (n == null) {\n62           continue;\n63         }\n64         if (n.getJSDocInfo() != null) {\n65           JSDocInfo info = n.getJSDocInfo();\n66           if (info.isExterns()) {\n67             externsRoot.addChildToBack(n);\n68             input.setIsExtern(true);\n69             input.getModule().remove(input);\n70             externs.add(input);\n71             staleInputs = true;\n72           } else if (info.isNoCompile()) {\n73             input.getModule().remove(input);\n74             staleInputs = true;\n75           }\n76         }\n77       }\n78       if (staleInputs) {\n79         fillEmptyModules(modules);\n80         rebuildInputsFromModules();\n81       }\n82       for (CompilerInput input : inputs) {\n83         Node n = input.getAstRoot(this);\n84         if (n == null) {\n85           continue;\n86         }\n87         if (devMode) {\n88           runSanityCheck();\n89           if (hasErrors()) {\n90             return null;\n91           }\n92         }\n93         if (options.sourceMapOutputPath != null ||\n94             options.nameReferenceReportPath != null) {\n95           SourceInformationAnnotator sia =\n96               new SourceInformationAnnotator(\n97                   input.getName(), options.devMode != DevMode.OFF);\n98           NodeTraversal.traverse(this, n, sia);\n99         }\n100         jsRoot.addChildToBack(n);\n101       }\n102       if (hasErrors()) {\n103         return null;\n104       }\n105       return externAndJsRoot;\n106     } finally {\n107       stopTracer(tracer, \"parseInputs\");\n108     }\n109   }\n", "fixed_code": "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer = newTracer(\"parseInputs\");\n    try {\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n            input.getModule().remove(input);\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n        jsRoot.addChildToBack(n);\n      }\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n"}
{"bug_id": "Lang-57", "buggy_code": "1     public static boolean isAvailableLocale(Locale locale) {\n2         return cAvailableLocaleSet.contains(locale);\n3     }\n", "fixed_code": "    public static boolean isAvailableLocale(Locale locale) {\n        return availableLocaleList().contains(locale);\n    }\n"}
{"bug_id": "Jsoup-75", "buggy_code": "1     final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n2         final int sz = size;\n3         for (int i = 0; i < sz; i++) {\n4             final String key = keys[i];\n5             final String val = vals[i];\n6             accum.append(' ').append(key);\n7             if (!(out.syntax() == Document.OutputSettings.Syntax.html\n8                 && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n9                 accum.append(\"=\\\"\");\n10                 Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n11                 accum.append('\"');\n12             }\n13         }\n14     }\n", "fixed_code": "    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n"}
{"bug_id": "Lang-51", "buggy_code": "1     public static boolean toBoolean(String str) {\n2         if (str == \"true\") {\n3             return true;\n4         }\n5         if (str == null) {\n6             return false;\n7         }\n8         switch (str.length()) {\n9             case 2: {\n10                 char ch0 = str.charAt(0);\n11                 char ch1 = str.charAt(1);\n12                 return \n13                     (ch0 == 'o' || ch0 == 'O') &&\n14                     (ch1 == 'n' || ch1 == 'N');\n15             }\n16             case 3: {\n17                 char ch = str.charAt(0);\n18                 if (ch == 'y') {\n19                     return \n20                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n21                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n22                 }\n23                 if (ch == 'Y') {\n24                     return \n25                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n26                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n27                 }\n28             }\n29             case 4: {\n30                 char ch = str.charAt(0);\n31                 if (ch == 't') {\n32                     return \n33                         (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n34                         (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n35                         (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n36                 }\n37                 if (ch == 'T') {\n38                     return \n39                         (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n40                         (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n41                         (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n42                 }\n43             }\n44         }\n45         return false;\n46     }\n", "fixed_code": "    public static boolean toBoolean(String str) {\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n                return false;\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n"}
{"bug_id": "Closure-126", "buggy_code": "1   void tryMinimizeExits(Node n, int exitType, String labelName) {\n2     if (matchingExitNode(n, exitType, labelName)) {\n3       NodeUtil.removeChild(n.getParent(), n);\n4       compiler.reportCodeChange();\n5       return;\n6     }\n7     if (n.isIf()) {\n8       Node ifBlock = n.getFirstChild().getNext();\n9       tryMinimizeExits(ifBlock, exitType, labelName);\n10       Node elseBlock = ifBlock.getNext();\n11       if (elseBlock != null) {\n12         tryMinimizeExits(elseBlock, exitType, labelName);\n13       }\n14       return;\n15     }\n16     if (n.isTry()) {\n17       Node tryBlock = n.getFirstChild();\n18       tryMinimizeExits(tryBlock, exitType, labelName);\n19       Node allCatchNodes = NodeUtil.getCatchBlock(n);\n20       if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n21         Preconditions.checkState(allCatchNodes.hasOneChild());\n22         Node catchNode = allCatchNodes.getFirstChild();\n23         Node catchCodeBlock = catchNode.getLastChild();\n24         tryMinimizeExits(catchCodeBlock, exitType, labelName);\n25       }\n26       if (NodeUtil.hasFinally(n)) {\n27         Node finallyBlock = n.getLastChild();\n28         tryMinimizeExits(finallyBlock, exitType, labelName);\n29       }\n30     }\n31     if (n.isLabel()) {\n32       Node labelBlock = n.getLastChild();\n33       tryMinimizeExits(labelBlock, exitType, labelName);\n34     }\n35     if (!n.isBlock() || n.getLastChild() == null) {\n36       return;\n37     }\n38     for (Node c : n.children()) {\n39       if (c.isIf()) {\n40         Node ifTree = c;\n41         Node trueBlock, falseBlock;\n42         trueBlock = ifTree.getFirstChild().getNext();\n43         falseBlock = trueBlock.getNext();\n44         tryMinimizeIfBlockExits(trueBlock, falseBlock,\n45             ifTree, exitType, labelName);\n46         trueBlock = ifTree.getFirstChild().getNext();\n47         falseBlock = trueBlock.getNext();\n48         if (falseBlock != null) {\n49           tryMinimizeIfBlockExits(falseBlock, trueBlock,\n50               ifTree, exitType, labelName);\n51         }\n52       }\n53       if (c == n.getLastChild()) {\n54         break;\n55       }\n56     }\n57     for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n58       tryMinimizeExits(c, exitType, labelName);\n59       if (c == n.getLastChild()) {\n60         break;\n61       }\n62     }\n63   }\n", "fixed_code": "  void tryMinimizeExits(Node n, int exitType, String labelName) {\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n    }\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n    for (Node c : n.children()) {\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }\n"}
{"bug_id": "Lang-58", "buggy_code": "1     public static Number createNumber(String str) throws NumberFormatException {\n2         if (str == null) {\n3             return null;\n4         }\n5         if (StringUtils.isBlank(str)) {\n6             throw new NumberFormatException(\"A blank string is not a valid number\");\n7         }  \n8         if (str.startsWith(\"--\")) {\n9             return null;\n10         }\n11         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n12             return createInteger(str);\n13         }   \n14         char lastChar = str.charAt(str.length() - 1);\n15         String mant;\n16         String dec;\n17         String exp;\n18         int decPos = str.indexOf('.');\n19         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n20         if (decPos > -1) {\n21             if (expPos > -1) {\n22                 if (expPos < decPos) {\n23                     throw new NumberFormatException(str + \" is not a valid number.\");\n24                 }\n25                 dec = str.substring(decPos + 1, expPos);\n26             } else {\n27                 dec = str.substring(decPos + 1);\n28             }\n29             mant = str.substring(0, decPos);\n30         } else {\n31             if (expPos > -1) {\n32                 mant = str.substring(0, expPos);\n33             } else {\n34                 mant = str;\n35             }\n36             dec = null;\n37         }\n38         if (!Character.isDigit(lastChar)) {\n39             if (expPos > -1 && expPos < str.length() - 1) {\n40                 exp = str.substring(expPos + 1, str.length() - 1);\n41             } else {\n42                 exp = null;\n43             }\n44             String numeric = str.substring(0, str.length() - 1);\n45             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n46             switch (lastChar) {\n47                 case 'l' :\n48                 case 'L' :\n49                     if (dec == null\n50                         && exp == null\n51                         && isDigits(numeric.substring(1))\n52                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n53                         try {\n54                             return createLong(numeric);\n55                         } catch (NumberFormatException nfe) {\n56                         }\n57                         return createBigInteger(numeric);\n58                     }\n59                     throw new NumberFormatException(str + \" is not a valid number.\");\n60                 case 'f' :\n61                 case 'F' :\n62                     try {\n63                         Float f = NumberUtils.createFloat(numeric);\n64                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n65                             return f;\n66                         }\n67                     } catch (NumberFormatException nfe) {\n68                     }\n69                 case 'd' :\n70                 case 'D' :\n71                     try {\n72                         Double d = NumberUtils.createDouble(numeric);\n73                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n74                             return d;\n75                         }\n76                     } catch (NumberFormatException nfe) {\n77                     }\n78                     try {\n79                         return createBigDecimal(numeric);\n80                     } catch (NumberFormatException e) {\n81                     }\n82                 default :\n83                     throw new NumberFormatException(str + \" is not a valid number.\");\n84             }\n85         } else {\n86             if (expPos > -1 && expPos < str.length() - 1) {\n87                 exp = str.substring(expPos + 1, str.length());\n88             } else {\n89                 exp = null;\n90             }\n91             if (dec == null && exp == null) {\n92                 try {\n93                     return createInteger(str);\n94                 } catch (NumberFormatException nfe) {\n95                 }\n96                 try {\n97                     return createLong(str);\n98                 } catch (NumberFormatException nfe) {\n99                 }\n100                 return createBigInteger(str);\n101             } else {\n102                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n103                 try {\n104                     Float f = createFloat(str);\n105                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n106                         return f;\n107                     }\n108                 } catch (NumberFormatException nfe) {\n109                 }\n110                 try {\n111                     Double d = createDouble(str);\n112                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n113                         return d;\n114                     }\n115                 } catch (NumberFormatException nfe) {\n116                 }\n117                 return createBigDecimal(str);\n118             }\n119         }\n120     }\n", "fixed_code": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n        if (decPos > -1) {\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                        }\n                        return createBigInteger(numeric);\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                    }\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        } else {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigInteger(str);\n            } else {\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigDecimal(str);\n            }\n        }\n    }\n"}
{"bug_id": "Lang-24", "buggy_code": "1     public static boolean isNumber(String str) {\n2         if (StringUtils.isEmpty(str)) {\n3             return false;\n4         }\n5         char[] chars = str.toCharArray();\n6         int sz = chars.length;\n7         boolean hasExp = false;\n8         boolean hasDecPoint = false;\n9         boolean allowSigns = false;\n10         boolean foundDigit = false;\n11         int start = (chars[0] == '-') ? 1 : 0;\n12         if (sz > start + 1) {\n13             if (chars[start] == '0' && chars[start + 1] == 'x') {\n14                 int i = start + 2;\n15                 if (i == sz) {\n16                     return false; \n17                 }\n18                 for (; i < chars.length; i++) {\n19                     if ((chars[i] < '0' || chars[i] > '9')\n20                         && (chars[i] < 'a' || chars[i] > 'f')\n21                         && (chars[i] < 'A' || chars[i] > 'F')) {\n22                         return false;\n23                     }\n24                 }\n25                 return true;\n26             }\n27         }\n28         sz--; \n29         int i = start;\n30         while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n31             if (chars[i] >= '0' && chars[i] <= '9') {\n32                 foundDigit = true;\n33                 allowSigns = false;\n34             } else if (chars[i] == '.') {\n35                 if (hasDecPoint || hasExp) {\n36                     return false;\n37                 }\n38                 hasDecPoint = true;\n39             } else if (chars[i] == 'e' || chars[i] == 'E') {\n40                 if (hasExp) {\n41                     return false;\n42                 }\n43                 if (!foundDigit) {\n44                     return false;\n45                 }\n46                 hasExp = true;\n47                 allowSigns = true;\n48             } else if (chars[i] == '+' || chars[i] == '-') {\n49                 if (!allowSigns) {\n50                     return false;\n51                 }\n52                 allowSigns = false;\n53                 foundDigit = false; \n54             } else {\n55                 return false;\n56             }\n57             i++;\n58         }\n59         if (i < chars.length) {\n60             if (chars[i] >= '0' && chars[i] <= '9') {\n61                 return true;\n62             }\n63             if (chars[i] == 'e' || chars[i] == 'E') {\n64                 return false;\n65             }\n66             if (chars[i] == '.') {\n67                 if (hasDecPoint || hasExp) {\n68                     return false;\n69                 }\n70                 return foundDigit;\n71             }\n72             if (!allowSigns\n73                 && (chars[i] == 'd'\n74                     || chars[i] == 'D'\n75                     || chars[i] == 'f'\n76                     || chars[i] == 'F')) {\n77                 return foundDigit;\n78             }\n79             if (chars[i] == 'l'\n80                 || chars[i] == 'L') {\n81                 return foundDigit && !hasExp;\n82             }\n83             return false;\n84         }\n85         return !allowSigns && foundDigit;\n86     }\n", "fixed_code": "    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1) {\n            if (chars[start] == '0' && chars[start + 1] == 'x') {\n                int i = start + 2;\n                if (i == sz) {\n                    return false; \n                }\n                for (; i < chars.length; i++) {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                        && (chars[i] < 'a' || chars[i] > 'f')\n                        && (chars[i] < 'A' || chars[i] > 'F')) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; \n        int i = start;\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                foundDigit = true;\n                allowSigns = false;\n            } else if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    return false;\n                }\n                hasDecPoint = true;\n            } else if (chars[i] == 'e' || chars[i] == 'E') {\n                if (hasExp) {\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; \n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                return false;\n            }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    return false;\n                }\n                return foundDigit;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                return foundDigit && !hasExp && !hasDecPoint;\n            }\n            return false;\n        }\n        return !allowSigns && foundDigit;\n    }\n"}
{"bug_id": "Csv-10", "buggy_code": "1     public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n2         Assertions.notNull(out, \"out\");\n3         Assertions.notNull(format, \"format\");\n4         this.out = out;\n5         this.format = format;\n6         this.format.validate();\n7     }\n", "fixed_code": "    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n        this.out = out;\n        this.format = format;\n        this.format.validate();\n        if (format.getHeader() != null) {\n            this.printRecord((Object[]) format.getHeader());\n        }\n    }\n"}
{"bug_id": "Mockito-1", "buggy_code": "1     public void captureArgumentsFrom(Invocation invocation) {\n2         if (invocation.getMethod().isVarArgs()) {\n3             int indexOfVararg = invocation.getRawArguments().length - 1;\n4             throw new UnsupportedOperationException();\n5         } else {\n6             for (int position = 0; position < matchers.size(); position++) {\n7                 Matcher m = matchers.get(position);\n8                 if (m instanceof CapturesArguments) {\n9                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n10                 }\n11             }\n12         }\n13     }\n", "fixed_code": "    public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n            for (int position = 0; position < indexOfVararg; position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n            for (int position = indexOfVararg; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n                }\n            }\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n    }\n"}
{"bug_id": "Math-7", "buggy_code": "1     protected double acceptStep(final AbstractStepInterpolator interpolator,\n2                                 final double[] y, final double[] yDot, final double tEnd)\n3         throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n4             double previousT = interpolator.getGlobalPreviousTime();\n5             final double currentT = interpolator.getGlobalCurrentTime();\n6             if (! statesInitialized) {\n7                 for (EventState state : eventsStates) {\n8                     state.reinitializeBegin(interpolator);\n9                 }\n10                 statesInitialized = true;\n11             }\n12             final int orderingSign = interpolator.isForward() ? +1 : -1;\n13             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n14                 public int compare(EventState es0, EventState es1) {\n15                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n16                 }\n17             });\n18             for (final EventState state : eventsStates) {\n19                 if (state.evaluateStep(interpolator)) {\n20                     occuringEvents.add(state);\n21                 }\n22             }\n23             while (!occuringEvents.isEmpty()) {\n24                 final Iterator<EventState> iterator = occuringEvents.iterator();\n25                 final EventState currentEvent = iterator.next();\n26                 iterator.remove();\n27                 final double eventT = currentEvent.getEventTime();\n28                 interpolator.setSoftPreviousTime(previousT);\n29                 interpolator.setSoftCurrentTime(eventT);\n30                 interpolator.setInterpolatedTime(eventT);\n31                 final double[] eventY = interpolator.getInterpolatedState().clone();\n32                 currentEvent.stepAccepted(eventT, eventY);\n33                 isLastStep = currentEvent.stop();\n34                 for (final StepHandler handler : stepHandlers) {\n35                     handler.handleStep(interpolator, isLastStep);\n36                 }\n37                 if (isLastStep) {\n38                     System.arraycopy(eventY, 0, y, 0, y.length);\n39                     for (final EventState remaining : occuringEvents) {\n40                         remaining.stepAccepted(eventT, eventY);\n41                     }\n42                     return eventT;\n43                 }\n44                 boolean needReset = currentEvent.reset(eventT, eventY);\n45                 if (needReset) {\n46                     System.arraycopy(eventY, 0, y, 0, y.length);\n47                     computeDerivatives(eventT, y, yDot);\n48                     resetOccurred = true;\n49                     for (final EventState remaining : occuringEvents) {\n50                         remaining.stepAccepted(eventT, eventY);\n51                     }\n52                     return eventT;\n53                 }\n54                 previousT = eventT;\n55                 interpolator.setSoftPreviousTime(eventT);\n56                 interpolator.setSoftCurrentTime(currentT);\n57                 if (currentEvent.evaluateStep(interpolator)) {\n58                     occuringEvents.add(currentEvent);\n59                 }\n60             }\n61             interpolator.setInterpolatedTime(currentT);\n62             final double[] currentY = interpolator.getInterpolatedState();\n63             for (final EventState state : eventsStates) {\n64                 state.stepAccepted(currentT, currentY);\n65                 isLastStep = isLastStep || state.stop();\n66             }\n67             isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n68             for (StepHandler handler : stepHandlers) {\n69                 handler.handleStep(interpolator, isLastStep);\n70             }\n71             return currentT;\n72     }\n", "fixed_code": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventY);\n                    isLastStep = isLastStep || state.stop();\n                }\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n                if (isLastStep) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    return eventT;\n                }\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventY);\n                }\n                if (needReset) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n"}
{"bug_id": "Closure-114", "buggy_code": "1     private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n2       Node nameNode = n.getFirstChild();\n3       Node parent = n.getParent();\n4       NameInformation ns = createNameInformation(t, nameNode);\n5       if (ns != null) {\n6         if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n7           if (parent.getFirstChild().getNext() != n) {\n8             recordDepScope(recordNode, ns);\n9           } else {\n10             recordDepScope(nameNode, ns);\n11           }\n12         } else {\n13           recordDepScope(recordNode, ns);\n14         }\n15       }\n16     }\n", "fixed_code": "    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {\n          recordDepScope(recordNode, ns);\n        }\n      }\n    }\n"}
{"bug_id": "JacksonCore-26", "buggy_code": "1     public void feedInput(byte[] buf, int start, int end) throws IOException\n2     {\n3         if (_inputPtr < _inputEnd) {\n4             _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n5         }\n6         if (end < start) {\n7             _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n8         }\n9         if (_endOfInput) {\n10             _reportError(\"Already closed, can not feed more input\");\n11         }\n12         _currInputProcessed += _origBufferLen;\n13         _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n14         _inputBuffer = buf;\n15         _inputPtr = start;\n16         _inputEnd = end;\n17         _origBufferLen = end - start;\n18     }\n", "fixed_code": "    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        _currInputProcessed += _origBufferLen;\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n        _currBufferStart = start;\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n"}
{"bug_id": "Math-43", "buggy_code": "1     public void addValue(double value) {\n2         sumImpl.increment(value);\n3         sumsqImpl.increment(value);\n4         minImpl.increment(value);\n5         maxImpl.increment(value);\n6         sumLogImpl.increment(value);\n7         secondMoment.increment(value);\n8         if (!(meanImpl instanceof Mean)) {\n9             meanImpl.increment(value);\n10         }\n11         if (!(varianceImpl instanceof Variance)) {\n12             varianceImpl.increment(value);\n13         }\n14         if (!(geoMeanImpl instanceof GeometricMean)) {\n15             geoMeanImpl.increment(value);\n16         }\n17         n++;\n18     }\n", "fixed_code": "    public void addValue(double value) {\n        sumImpl.increment(value);\n        sumsqImpl.increment(value);\n        minImpl.increment(value);\n        maxImpl.increment(value);\n        sumLogImpl.increment(value);\n        secondMoment.increment(value);\n        if (meanImpl != mean) {\n            meanImpl.increment(value);\n        }\n        if (varianceImpl != variance) {\n            varianceImpl.increment(value);\n        }\n        if (geoMeanImpl != geoMean) {\n            geoMeanImpl.increment(value);\n        }\n        n++;\n    }\n"}
{"bug_id": "Closure-11", "buggy_code": "1   private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n2     Node property = n.getLastChild();\n3     Node objNode = n.getFirstChild();\n4     JSType childType = getJSType(objNode);\n5     if (childType.isDict()) {\n6       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n7     } else if (n.getJSType() != null && parent.isAssign()) {\n8       return;\n9     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n10         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n11       checkPropertyAccess(childType, property.getString(), t, n);\n12     }\n13     ensureTyped(t, n);\n14   }\n", "fixed_code": "  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n    if (childType.isDict()) {\n      report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\n        \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n      checkPropertyAccess(childType, property.getString(), t, n);\n    }\n    ensureTyped(t, n);\n  }\n"}
{"bug_id": "Lang-26", "buggy_code": "1     public String format(Date date) {\n2         Calendar c = new GregorianCalendar(mTimeZone);\n3         c.setTime(date);\n4         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n5     }\n", "fixed_code": "    public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n"}
{"bug_id": "Codec-15", "buggy_code": "1     private char getMappingCode(final String str, final int index) {\n2         final char mappedChar = this.map(str.charAt(index));\n3         if (index > 1 && mappedChar != '0') {\n4             final char hwChar = str.charAt(index - 1);\n5             if ('H' == hwChar || 'W' == hwChar) {\n6                 final char preHWChar = str.charAt(index - 2);\n7                 final char firstCode = this.map(preHWChar);\n8                 if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n9                     return 0;\n10                 }\n11             }\n12         }\n13         return mappedChar;\n14     }\n", "fixed_code": "    private char getMappingCode(final String str, final int index) {\n        final char mappedChar = this.map(str.charAt(index));\n        if (index > 1 && mappedChar != '0') {\n            for (int i=index-1 ; i>=0 ; i--) {\n                final char prevChar = str.charAt(i);\n                if (this.map(prevChar)==mappedChar) {\n                    return 0;\n                }\n                if ('H'!=prevChar && 'W'!=prevChar) {\n                    break;\n                }\n            }\n        }\n        return mappedChar;\n    }\n"}
{"bug_id": "Math-84", "buggy_code": "1     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n2         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n3         while (true) {\n4             incrementIterationsCounter();\n5             final RealPointValuePair[] original = simplex;\n6             final RealPointValuePair best = original[0];\n7             final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n8             if (comparator.compare(reflected, best) < 0) {\n9                 final RealPointValuePair[] reflectedSimplex = simplex;\n10                 final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n11                 if (comparator.compare(reflected, expanded) <= 0) {\n12                     simplex = reflectedSimplex;\n13                 }\n14                 return;\n15             }\n16             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n17             if (comparator.compare(contracted, best) < 0) {\n18                 return;\n19             }\n20         }\n21     }\n", "fixed_code": "    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n        final RealConvergenceChecker checker = getConvergenceChecker();\n        while (true) {\n            incrementIterationsCounter();\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    simplex = reflectedSimplex;\n                }\n                return;\n            }\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                return;\n            }\n            final int iter = getIterations();\n            boolean converged = true;\n            for (int i = 0; i < simplex.length; ++i) {\n                converged &= checker.converged(iter, original[i], simplex[i]);\n            }\n            if (converged) {\n                return;\n            }\n        }\n    }\n"}
{"bug_id": "Lang-14", "buggy_code": "1     public static boolean equals(CharSequence cs1, CharSequence cs2) {\n2         if (cs1 == cs2) {\n3             return true;\n4         }\n5         if (cs1 == null || cs2 == null) {\n6             return false;\n7         }\n8             return cs1.equals(cs2);\n9     }\n", "fixed_code": "    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }\n"}
{"bug_id": "Chart-17", "buggy_code": "1     public Object clone() throws CloneNotSupportedException {\n2         Object clone = createCopy(0, getItemCount() - 1);\n3         return clone;\n4     }\n", "fixed_code": "    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n"}
{"bug_id": "Jsoup-85", "buggy_code": "1     public Attribute(String key, String val, Attributes parent) {\n2         Validate.notNull(key);\n3         this.key = key.trim();\n4         Validate.notEmpty(key); \n5         this.val = val;\n6         this.parent = parent;\n7     }\n", "fixed_code": "    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); \n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n"}
{"bug_id": "Math-94", "buggy_code": "1     public static int gcd(int u, int v) {\n2         if (u * v == 0) {\n3             return (Math.abs(u) + Math.abs(v));\n4         }\n5         if (u > 0) {\n6             u = -u;\n7         } \n8         if (v > 0) {\n9             v = -v;\n10         } \n11         int k = 0;\n12         while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n13             u /= 2;\n14             v /= 2;\n15             k++; \n16         }\n17         if (k == 31) {\n18             throw new ArithmeticException(\"overflow: gcd is 2^31\");\n19         }\n20         int t = ((u & 1) == 1) ? v : -(u / 2);\n21         do {\n22             while ((t & 1) == 0) { \n23                 t /= 2; \n24             }\n25             if (t > 0) {\n26                 u = -t;\n27             } else {\n28                 v = t;\n29             }\n30             t = (v - u) / 2;\n31         } while (t != 0);\n32         return -u * (1 << k); \n33     }\n", "fixed_code": "    public static int gcd(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        if (u > 0) {\n            u = -u;\n        } \n        if (v > 0) {\n            v = -v;\n        } \n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n            u /= 2;\n            v /= 2;\n            k++; \n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        int t = ((u & 1) == 1) ? v : -(u / 2);\n        do {\n            while ((t & 1) == 0) { \n                t /= 2; \n            }\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            t = (v - u) / 2;\n        } while (t != 0);\n        return -u * (1 << k); \n    }\n"}
{"bug_id": "Compress-27", "buggy_code": "1     public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n2         long    result = 0;\n3         int     end = offset + length;\n4         int     start = offset;\n5         if (length < 2){\n6             throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n7         }\n8         if (buffer[start] == 0) {\n9             return 0L;\n10         }\n11         while (start < end){\n12             if (buffer[start] == ' '){\n13                 start++;\n14             } else {\n15                 break;\n16             }\n17         }\n18         byte trailer = buffer[end - 1];\n19         while (start < end && (trailer == 0 || trailer == ' ')) {\n20             end--;\n21             trailer = buffer[end - 1];\n22         }\n23         if (start == end) {\n24             throw new IllegalArgumentException(\n25                     exceptionMessage(buffer, offset, length, start, trailer));\n26         }\n27         for ( ;start < end; start++) {\n28             final byte currentByte = buffer[start];\n29             if (currentByte < '0' || currentByte > '7'){\n30                 throw new IllegalArgumentException(\n31                         exceptionMessage(buffer, offset, length, start, currentByte));\n32             }\n33             result = (result << 3) + (currentByte - '0'); \n34         }\n35         return result;\n36     }\n", "fixed_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); \n        }\n        return result;\n    }\n"}
{"bug_id": "Closure-58", "buggy_code": "1   private void computeGenKill(Node n, BitSet gen, BitSet kill,\n2       boolean conditional) {\n3     switch (n.getType()) {\n4       case Token.SCRIPT:\n5       case Token.BLOCK:\n6       case Token.FUNCTION:\n7         return;\n8       case Token.WHILE:\n9       case Token.DO:\n10       case Token.IF:\n11         computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n12             conditional);\n13         return;\n14       case Token.FOR:\n15         if (!NodeUtil.isForIn(n)) {\n16           computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n17               conditional);\n18         } else {\n19           Node lhs = n.getFirstChild();\n20           Node rhs = lhs.getNext();\n21           if (NodeUtil.isVar(lhs)) {\n22             lhs = lhs.getLastChild();\n23           }\n24             addToSetIfLocal(lhs, kill);\n25             addToSetIfLocal(lhs, gen);\n26           computeGenKill(rhs, gen, kill, conditional);\n27         }\n28         return;\n29       case Token.VAR:\n30         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n31           if (c.hasChildren()) {\n32             computeGenKill(c.getFirstChild(), gen, kill, conditional);\n33             if (!conditional) {\n34               addToSetIfLocal(c, kill);\n35             }\n36           }\n37         }\n38         return;\n39       case Token.AND:\n40       case Token.OR:\n41         computeGenKill(n.getFirstChild(), gen, kill, conditional);\n42         computeGenKill(n.getLastChild(), gen, kill, true);\n43         return;\n44       case Token.HOOK:\n45         computeGenKill(n.getFirstChild(), gen, kill, conditional);\n46         computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n47         computeGenKill(n.getLastChild(), gen, kill, true);\n48         return;\n49       case Token.NAME:\n50         if (isArgumentsName(n)) {\n51           markAllParametersEscaped();\n52         } else {\n53           addToSetIfLocal(n, gen);\n54         }\n55         return;\n56       default:\n57         if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n58           Node lhs = n.getFirstChild();\n59           if (!conditional) {\n60             addToSetIfLocal(lhs, kill);\n61           }\n62           if (!NodeUtil.isAssign(n)) {\n63             addToSetIfLocal(lhs, gen);\n64           }\n65           computeGenKill(lhs.getNext(), gen, kill, conditional);\n66         } else {\n67           for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n68             computeGenKill(c, gen, kill, conditional);\n69           }\n70         }\n71         return;\n72     }\n73   }\n", "fixed_code": "  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n      boolean conditional) {\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n            conditional);\n        return;\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n              conditional);\n        } else {\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (NodeUtil.isVar(lhs)) {\n            lhs = lhs.getLastChild();\n          }\n          if (NodeUtil.isName(lhs)) {\n            addToSetIfLocal(lhs, kill);\n            addToSetIfLocal(lhs, gen);\n          } else {\n            computeGenKill(lhs, gen, kill, conditional);\n          }\n          computeGenKill(rhs, gen, kill, conditional);\n        }\n        return;\n      case Token.VAR:\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (c.hasChildren()) {\n            computeGenKill(c.getFirstChild(), gen, kill, conditional);\n            if (!conditional) {\n              addToSetIfLocal(c, kill);\n            }\n          }\n        }\n        return;\n      case Token.AND:\n      case Token.OR:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n      case Token.HOOK:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n      case Token.NAME:\n        if (isArgumentsName(n)) {\n          markAllParametersEscaped();\n        } else {\n          addToSetIfLocal(n, gen);\n        }\n        return;\n      default:\n        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n          Node lhs = n.getFirstChild();\n          if (!conditional) {\n            addToSetIfLocal(lhs, kill);\n          }\n          if (!NodeUtil.isAssign(n)) {\n            addToSetIfLocal(lhs, gen);\n          }\n          computeGenKill(lhs.getNext(), gen, kill, conditional);\n        } else {\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n            computeGenKill(c, gen, kill, conditional);\n          }\n        }\n        return;\n    }\n  }\n"}
{"bug_id": "Lang-1", "buggy_code": "1     public static Number createNumber(final String str) throws NumberFormatException {\n2         if (str == null) {\n3             return null;\n4         }\n5         if (StringUtils.isBlank(str)) {\n6             throw new NumberFormatException(\"A blank string is not a valid number\");\n7         }\n8         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n9         int pfxLen = 0;\n10         for(final String pfx : hex_prefixes) {\n11             if (str.startsWith(pfx)) {\n12                 pfxLen += pfx.length();\n13                 break;\n14             }\n15         }\n16         if (pfxLen > 0) { \n17             final int hexDigits = str.length() - pfxLen;\n18             if (hexDigits > 16) { \n19                 return createBigInteger(str);\n20             }\n21             if (hexDigits > 8) { \n22                 return createLong(str);\n23             }\n24             return createInteger(str);\n25         }\n26         final char lastChar = str.charAt(str.length() - 1);\n27         String mant;\n28         String dec;\n29         String exp;\n30         final int decPos = str.indexOf('.');\n31         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; \n32         int numDecimals = 0; \n33         if (decPos > -1) { \n34             if (expPos > -1) { \n35                 if (expPos < decPos || expPos > str.length()) { \n36                     throw new NumberFormatException(str + \" is not a valid number.\");\n37                 }\n38                 dec = str.substring(decPos + 1, expPos);\n39             } else {\n40                 dec = str.substring(decPos + 1);\n41             }\n42             mant = str.substring(0, decPos);\n43             numDecimals = dec.length(); \n44         } else {\n45             if (expPos > -1) {\n46                 if (expPos > str.length()) { \n47                     throw new NumberFormatException(str + \" is not a valid number.\");\n48                 }\n49                 mant = str.substring(0, expPos);\n50             } else {\n51                 mant = str;\n52             }\n53             dec = null;\n54         }\n55         if (!Character.isDigit(lastChar) && lastChar != '.') {\n56             if (expPos > -1 && expPos < str.length() - 1) {\n57                 exp = str.substring(expPos + 1, str.length() - 1);\n58             } else {\n59                 exp = null;\n60             }\n61             final String numeric = str.substring(0, str.length() - 1);\n62             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n63             switch (lastChar) {\n64                 case 'l' :\n65                 case 'L' :\n66                     if (dec == null\n67                         && exp == null\n68                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n69                         try {\n70                             return createLong(numeric);\n71                         } catch (final NumberFormatException nfe) { \n72                         }\n73                         return createBigInteger(numeric);\n74                     }\n75                     throw new NumberFormatException(str + \" is not a valid number.\");\n76                 case 'f' :\n77                 case 'F' :\n78                     try {\n79                         final Float f = NumberUtils.createFloat(numeric);\n80                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n81                             return f;\n82                         }\n83                     } catch (final NumberFormatException nfe) { \n84                     }\n85                 case 'd' :\n86                 case 'D' :\n87                     try {\n88                         final Double d = NumberUtils.createDouble(numeric);\n89                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n90                             return d;\n91                         }\n92                     } catch (final NumberFormatException nfe) { \n93                     }\n94                     try {\n95                         return createBigDecimal(numeric);\n96                     } catch (final NumberFormatException e) { \n97                     }\n98                 default :\n99                     throw new NumberFormatException(str + \" is not a valid number.\");\n100             }\n101         }\n102         if (expPos > -1 && expPos < str.length() - 1) {\n103             exp = str.substring(expPos + 1, str.length());\n104         } else {\n105             exp = null;\n106         }\n107         if (dec == null && exp == null) { \n108             try {\n109                 return createInteger(str);\n110             } catch (final NumberFormatException nfe) { \n111             }\n112             try {\n113                 return createLong(str);\n114             } catch (final NumberFormatException nfe) { \n115             }\n116             return createBigInteger(str);\n117         }\n118         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n119         try {\n120             if(numDecimals <= 7){\n121                 final Float f = createFloat(str);\n122                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n123                     return f;\n124                 }\n125             }\n126         } catch (final NumberFormatException nfe) { \n127         }\n128         try {\n129             if(numDecimals <= 16){\n130                 final Double d = createDouble(str);\n131                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n132                     return d;\n133                 }\n134             }\n135         } catch (final NumberFormatException nfe) { \n136         }\n137         return createBigDecimal(str);\n138     }\n", "fixed_code": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen += pfx.length();\n                break;\n            }\n        }\n        if (pfxLen > 0) { \n            char firstSigDigit = 0; \n            for(int i = pfxLen; i < str.length(); i++) {\n                firstSigDigit = str.charAt(i);\n                if (firstSigDigit == '0') { \n                    pfxLen++;\n                } else {\n                    break;\n                }\n            }\n            final int hexDigits = str.length() - pfxLen;\n            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { \n                return createBigInteger(str);\n            }\n            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { \n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; \n        int numDecimals = 0; \n        if (decPos > -1) { \n            if (expPos > -1) { \n                if (expPos < decPos || expPos > str.length()) { \n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n            numDecimals = dec.length(); \n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) { \n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            final String numeric = str.substring(0, str.length() - 1);\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { \n                        }\n                        return createBigInteger(numeric);\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (final NumberFormatException nfe) { \n                    }\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { \n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { \n                    }\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        }\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { \n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { \n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { \n            }\n            return createBigInteger(str);\n        }\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        try {\n            if(numDecimals <= 7){\n                final Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            }\n        } catch (final NumberFormatException nfe) { \n        }\n        try {\n            if(numDecimals <= 16){\n                final Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            }\n        } catch (final NumberFormatException nfe) { \n        }\n        return createBigDecimal(str);\n    }\n"}
{"bug_id": "Collections-26", "buggy_code": "1     private Object readResolve() {\n2         calculateHashCode(keys);\n3         return this;\n4     }\n", "fixed_code": "    protected Object readResolve() {\n        calculateHashCode(keys);\n        return this;\n    }\n"}
{"bug_id": "JacksonCore-15", "buggy_code": "1     public JsonToken nextToken() throws IOException\n2     {\n3         TokenFilterContext ctxt = _exposedContext;\n4         if (ctxt != null) {\n5             while (true) {\n6                 JsonToken t = ctxt.nextTokenToRead();\n7                 if (t != null) {\n8                     _currToken = t;\n9                     return t;\n10                 }\n11                 if (ctxt == _headContext) {\n12                     _exposedContext = null;\n13                     if (ctxt.inArray()) {\n14                         t = delegate.getCurrentToken();\n15                         _currToken = t;\n16                         return t;\n17                     }\n18                     break;\n19                 }\n20                 ctxt = _headContext.findChildOf(ctxt);\n21                 _exposedContext = ctxt;\n22                 if (ctxt == null) { \n23                     throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n24                 }\n25             }\n26         }\n27         JsonToken t = delegate.nextToken();\n28         if (t == null) {\n29             return (_currToken = t);\n30         }\n31         TokenFilter f;\n32         switch (t.id()) {\n33         case ID_START_ARRAY:\n34             f = _itemFilter;\n35             if (f == TokenFilter.INCLUDE_ALL) {\n36                 _headContext = _headContext.createChildArrayContext(f, true);\n37                 return (_currToken = t);\n38             }\n39             if (f == null) { \n40                 delegate.skipChildren();\n41                 break;\n42             }\n43             f = _headContext.checkValue(f);\n44             if (f == null) {\n45                 delegate.skipChildren();\n46                 break;\n47             }\n48             if (f != TokenFilter.INCLUDE_ALL) {\n49                 f = f.filterStartArray();\n50             }\n51             _itemFilter = f;\n52             if (f == TokenFilter.INCLUDE_ALL) {\n53                 _headContext = _headContext.createChildArrayContext(f, true);\n54                 return (_currToken = t);\n55             }\n56             _headContext = _headContext.createChildArrayContext(f, false);\n57             if (_includePath) {\n58                 t = _nextTokenWithBuffering(_headContext);\n59                 if (t != null) {\n60                     _currToken = t;\n61                     return t;\n62                 }\n63             }\n64             break;\n65         case ID_START_OBJECT:\n66             f = _itemFilter;\n67             if (f == TokenFilter.INCLUDE_ALL) {\n68                 _headContext = _headContext.createChildObjectContext(f, true);\n69                 return (_currToken = t);\n70             }\n71             if (f == null) { \n72                 delegate.skipChildren();\n73                 break;\n74             }\n75             f = _headContext.checkValue(f);\n76             if (f == null) {\n77                 delegate.skipChildren();\n78                 break;\n79             }\n80             if (f != TokenFilter.INCLUDE_ALL) {\n81                 f = f.filterStartObject();\n82             }\n83             _itemFilter = f;\n84             if (f == TokenFilter.INCLUDE_ALL) {\n85                 _headContext = _headContext.createChildObjectContext(f, true);\n86                 return (_currToken = t);\n87             }\n88             _headContext = _headContext.createChildObjectContext(f, false);\n89             if (_includePath) {\n90                 t = _nextTokenWithBuffering(_headContext);\n91                 if (t != null) {\n92                     _currToken = t;\n93                     return t;\n94                 }\n95             }\n96             break;\n97         case ID_END_ARRAY:\n98         case ID_END_OBJECT:\n99             {\n100                 boolean returnEnd = _headContext.isStartHandled();\n101                 f = _headContext.getFilter();\n102                 if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n103                     f.filterFinishArray();\n104                 }\n105                 _headContext = _headContext.getParent();\n106                 _itemFilter = _headContext.getFilter();\n107                 if (returnEnd) {\n108                     return (_currToken = t);\n109                 }\n110             }\n111             break;\n112         case ID_FIELD_NAME:\n113             {\n114                 final String name = delegate.getCurrentName();\n115                 f = _headContext.setFieldName(name);\n116                 if (f == TokenFilter.INCLUDE_ALL) {\n117                     _itemFilter = f;\n118                     if (!_includePath) {\n119                         if (_includeImmediateParent && !_headContext.isStartHandled()) {\n120                             t = _headContext.nextTokenToRead(); \n121                             _exposedContext = _headContext;\n122                         }\n123                     }\n124                     return (_currToken = t);\n125                 }\n126                 if (f == null) {\n127                     delegate.nextToken();\n128                     delegate.skipChildren();\n129                     break;\n130                 }\n131                 f = f.includeProperty(name);\n132                 if (f == null) {\n133                     delegate.nextToken();\n134                     delegate.skipChildren();\n135                     break;\n136                 }\n137                 _itemFilter = f;\n138                 if (f == TokenFilter.INCLUDE_ALL) {\n139                     if (_includePath) {\n140                         return (_currToken = t);\n141                     }\n142                 }\n143                 if (_includePath) {\n144                     t = _nextTokenWithBuffering(_headContext);\n145                     if (t != null) {\n146                         _currToken = t;\n147                         return t;\n148                     }\n149                 }\n150                 break;\n151             }\n152         default: \n153             f = _itemFilter;\n154             if (f == TokenFilter.INCLUDE_ALL) {\n155                 return (_currToken = t);\n156             }\n157             if (f != null) {\n158                 f = _headContext.checkValue(f);\n159                 if ((f == TokenFilter.INCLUDE_ALL)\n160                         || ((f != null) && f.includeValue(delegate))) {\n161                     return (_currToken = t);\n162                 }\n163             }\n164             break;\n165         }\n166         return _nextToken2();\n167     }\n", "fixed_code": "    public JsonToken nextToken() throws IOException\n    {\n    \tif(!_allowMultipleMatches && _currToken != null && _exposedContext == null){\n    \t\tif((_currToken.isStructEnd()  && _headContext.isStartHandled()) ){\n    \t\t\treturn (_currToken = null);\n    \t\t}\n    \t\telse if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath \n    \t\t\t\t&& _itemFilter == TokenFilter.INCLUDE_ALL) {\n    \t\t\treturn (_currToken = null);\n    \t\t}\n    \t}\n        TokenFilterContext ctxt = _exposedContext;\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n                        _currToken = t;\n                        return t;\n                    }\n                    break;\n                }\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { \n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            return (_currToken = t);\n        }\n        TokenFilter f;\n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { \n                delegate.skipChildren();\n                break;\n            }\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { \n                delegate.skipChildren();\n                break;\n            }\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); \n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n        default: \n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n        }\n        return _nextToken2();\n    }\n"}
{"bug_id": "Gson-12", "buggy_code": "1   @Override public void skipValue() throws IOException {\n2     if (peek() == JsonToken.NAME) {\n3       nextName();\n4       pathNames[stackSize - 2] = \"null\";\n5     } else {\n6       popStack();\n7         pathNames[stackSize - 1] = \"null\";\n8     }\n9       pathIndices[stackSize - 1]++;\n10   }\n", "fixed_code": "  @Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n      pathNames[stackSize - 2] = \"null\";\n    } else {\n      popStack();\n      if (stackSize > 0) {\n        pathNames[stackSize - 1] = \"null\";\n      }\n    }\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n"}
{"bug_id": "Math-23", "buggy_code": "1     protected UnivariatePointValuePair doOptimize() {\n2         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n3         final double lo = getMin();\n4         final double mid = getStartValue();\n5         final double hi = getMax();\n6         final ConvergenceChecker<UnivariatePointValuePair> checker\n7             = getConvergenceChecker();\n8         double a;\n9         double b;\n10         if (lo < hi) {\n11             a = lo;\n12             b = hi;\n13         } else {\n14             a = hi;\n15             b = lo;\n16         }\n17         double x = mid;\n18         double v = x;\n19         double w = x;\n20         double d = 0;\n21         double e = 0;\n22         double fx = computeObjectiveValue(x);\n23         if (!isMinim) {\n24             fx = -fx;\n25         }\n26         double fv = fx;\n27         double fw = fx;\n28         UnivariatePointValuePair previous = null;\n29         UnivariatePointValuePair current\n30             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n31         int iter = 0;\n32         while (true) {\n33             final double m = 0.5 * (a + b);\n34             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n35             final double tol2 = 2 * tol1;\n36             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n37             if (!stop) {\n38                 double p = 0;\n39                 double q = 0;\n40                 double r = 0;\n41                 double u = 0;\n42                 if (FastMath.abs(e) > tol1) { \n43                     r = (x - w) * (fx - fv);\n44                     q = (x - v) * (fx - fw);\n45                     p = (x - v) * q - (x - w) * r;\n46                     q = 2 * (q - r);\n47                     if (q > 0) {\n48                         p = -p;\n49                     } else {\n50                         q = -q;\n51                     }\n52                     r = e;\n53                     e = d;\n54                     if (p > q * (a - x) &&\n55                         p < q * (b - x) &&\n56                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n57                         d = p / q;\n58                         u = x + d;\n59                         if (u - a < tol2 || b - u < tol2) {\n60                             if (x <= m) {\n61                                 d = tol1;\n62                             } else {\n63                                 d = -tol1;\n64                             }\n65                         }\n66                     } else {\n67                         if (x < m) {\n68                             e = b - x;\n69                         } else {\n70                             e = a - x;\n71                         }\n72                         d = GOLDEN_SECTION * e;\n73                     }\n74                 } else {\n75                     if (x < m) {\n76                         e = b - x;\n77                     } else {\n78                         e = a - x;\n79                     }\n80                     d = GOLDEN_SECTION * e;\n81                 }\n82                 if (FastMath.abs(d) < tol1) {\n83                     if (d >= 0) {\n84                         u = x + tol1;\n85                     } else {\n86                         u = x - tol1;\n87                     }\n88                 } else {\n89                     u = x + d;\n90                 }\n91                 double fu = computeObjectiveValue(u);\n92                 if (!isMinim) {\n93                     fu = -fu;\n94                 }\n95                 previous = current;\n96                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n97                 if (checker != null) {\n98                     if (checker.converged(iter, previous, current)) {\n99                         return best(current, previous, isMinim);\n100                     }\n101                 }\n102                 if (fu <= fx) {\n103                     if (u < x) {\n104                         b = x;\n105                     } else {\n106                         a = x;\n107                     }\n108                     v = w;\n109                     fv = fw;\n110                     w = x;\n111                     fw = fx;\n112                     x = u;\n113                     fx = fu;\n114                 } else {\n115                     if (u < x) {\n116                         a = u;\n117                     } else {\n118                         b = u;\n119                     }\n120                     if (fu <= fw ||\n121                         Precision.equals(w, x)) {\n122                         v = w;\n123                         fv = fw;\n124                         w = u;\n125                         fw = fu;\n126                     } else if (fu <= fv ||\n127                                Precision.equals(v, x) ||\n128                                Precision.equals(v, w)) {\n129                         v = u;\n130                         fv = fu;\n131                     }\n132                 }\n133             } else { \n134                 return\n135                             best(current,\n136                                  previous,\n137                             isMinim);\n138             }\n139             ++iter;\n140         }\n141     }\n", "fixed_code": "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        UnivariatePointValuePair best = current;\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n                if (FastMath.abs(e) > tol1) { \n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n                    r = e;\n                    e = d;\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        d = p / q;\n                        u = x + d;\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                best = best(best,\n                            best(current,\n                                 previous,\n                                 isMinim),\n                            isMinim);\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return best;\n                    }\n                }\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { \n                return best(best,\n                            best(current,\n                                 previous,\n                                 isMinim),\n                            isMinim);\n            }\n            ++iter;\n        }\n    }\n"}
{"bug_id": "Math-55", "buggy_code": "1   public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n2       return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n3   }\n", "fixed_code": "  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n      final double n1 = v1.getNormSq();\n      final double n2 = v2.getNormSq();\n      if ((n1 * n2) < MathUtils.SAFE_MIN) {\n          return ZERO;\n      }\n      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n      final double x1    = FastMath.scalb(v1.x, -deltaExp);\n      final double y1    = FastMath.scalb(v1.y, -deltaExp);\n      final double z1    = FastMath.scalb(v1.z, -deltaExp);\n      final double x2    = FastMath.scalb(v2.x,  deltaExp);\n      final double y2    = FastMath.scalb(v2.y,  deltaExp);\n      final double z2    = FastMath.scalb(v2.z,  deltaExp);\n      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n      final double rho   = FastMath.rint(256 * ratio) / 256;\n      final double x3 = x1 - rho * x2;\n      final double y3 = y1 - rho * y2;\n      final double z3 = z1 - rho * z2;\n      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n  }\n"}
{"bug_id": "Gson-16", "buggy_code": "1   private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n2                               Collection<TypeVariable> visitedTypeVariables) {\n3     while (true) {\n4       if (toResolve instanceof TypeVariable) {\n5         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n6         toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n7         if (toResolve == typeVariable) {\n8           return toResolve;\n9         }\n10       } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n11         Class<?> original = (Class<?>) toResolve;\n12         Type componentType = original.getComponentType();\n13         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n14         return componentType == newComponentType\n15             ? original\n16             : arrayOf(newComponentType);\n17       } else if (toResolve instanceof GenericArrayType) {\n18         GenericArrayType original = (GenericArrayType) toResolve;\n19         Type componentType = original.getGenericComponentType();\n20         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n21         return componentType == newComponentType\n22             ? original\n23             : arrayOf(newComponentType);\n24       } else if (toResolve instanceof ParameterizedType) {\n25         ParameterizedType original = (ParameterizedType) toResolve;\n26         Type ownerType = original.getOwnerType();\n27         Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n28         boolean changed = newOwnerType != ownerType;\n29         Type[] args = original.getActualTypeArguments();\n30         for (int t = 0, length = args.length; t < length; t++) {\n31           Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n32           if (resolvedTypeArgument != args[t]) {\n33             if (!changed) {\n34               args = args.clone();\n35               changed = true;\n36             }\n37             args[t] = resolvedTypeArgument;\n38           }\n39         }\n40         return changed\n41             ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n42             : original;\n43       } else if (toResolve instanceof WildcardType) {\n44         WildcardType original = (WildcardType) toResolve;\n45         Type[] originalLowerBound = original.getLowerBounds();\n46         Type[] originalUpperBound = original.getUpperBounds();\n47         if (originalLowerBound.length == 1) {\n48           Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n49           if (lowerBound != originalLowerBound[0]) {\n50             return supertypeOf(lowerBound);\n51           }\n52         } else if (originalUpperBound.length == 1) {\n53           Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n54           if (upperBound != originalUpperBound[0]) {\n55             return subtypeOf(upperBound);\n56           }\n57         }\n58         return original;\n59       } else {\n60         return toResolve;\n61       }\n62     }\n63   }\n", "fixed_code": "  private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                              Collection<TypeVariable> visitedTypeVariables) {\n    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        if (visitedTypeVariables.contains(typeVariable)) {\n          return toResolve;\n        } else {\n          visitedTypeVariables.add(typeVariable);\n        }\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n        if (toResolve == typeVariable) {\n          return toResolve;\n        }\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n        boolean changed = newOwnerType != ownerType;\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n        return changed\n            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n            : original;\n      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n          if (lowerBound != originalLowerBound[0]) {\n            return supertypeOf(lowerBound);\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n          if (upperBound != originalUpperBound[0]) {\n            return subtypeOf(upperBound);\n          }\n        }\n        return original;\n      } else {\n        return toResolve;\n      }\n    }\n  }\n"}
{"bug_id": "Closure-99", "buggy_code": "1   public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n2     if (n.getType() == Token.FUNCTION) {\n3       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n4       if (jsDoc != null &&\n5           (jsDoc.isConstructor() ||\n6            jsDoc.hasThisType() ||\n7            jsDoc.isOverride())) {\n8         return false;\n9       }\n10       int pType = parent.getType();\n11       if (!(pType == Token.BLOCK ||\n12             pType == Token.SCRIPT ||\n13             pType == Token.NAME ||\n14             pType == Token.ASSIGN)) {\n15         return false;\n16       }\n17     }\n18     if (parent != null && parent.getType() == Token.ASSIGN) {\n19       Node lhs = parent.getFirstChild();\n20       Node rhs = lhs.getNext();\n21       if (n == lhs) {\n22         if (assignLhsChild == null) {\n23           assignLhsChild = lhs;\n24         }\n25       } else {\n26           if (lhs.getType() == Token.GETPROP &&\n27               lhs.getLastChild().getString().equals(\"prototype\")) {\n28             return false;\n29           }\n30           if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n31             return false;\n32           }\n33       }\n34     }\n35     return true;\n36   }\n", "fixed_code": "  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN)) {\n        return false;\n      }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n      if (n == lhs) {\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        if (NodeUtil.isGet(lhs)) {\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.getType() == Token.GETPROP &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n"}
{"bug_id": "JacksonDatabind-62", "buggy_code": "1     public CollectionDeserializer createContextual(DeserializationContext ctxt,\n2             BeanProperty property) throws JsonMappingException\n3     {\n4         JsonDeserializer<Object> delegateDeser = null;\n5         if (_valueInstantiator != null) {\n6             if (_valueInstantiator.canCreateUsingDelegate()) {\n7                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n8                 if (delegateType == null) {\n9                     throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n10                             +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n11                             +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n12                 }\n13                 delegateDeser = findDeserializer(ctxt, delegateType, property);\n14             }\n15         }\n16         Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n17                 JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n18         JsonDeserializer<?> valueDeser = _valueDeserializer;\n19         valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n20         final JavaType vt = _collectionType.getContentType();\n21         if (valueDeser == null) {\n22             valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n23         } else { \n24             valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n25         }\n26         TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n27         if (valueTypeDeser != null) {\n28             valueTypeDeser = valueTypeDeser.forProperty(property);\n29         }\n30         return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n31     }\n", "fixed_code": "    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        JsonDeserializer<Object> delegateDeser = null;\n        if (_valueInstantiator != null) {\n            if (_valueInstantiator.canCreateUsingDelegate()) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n            } else if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        final JavaType vt = _collectionType.getContentType();\n        if (valueDeser == null) {\n            valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n        } else { \n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n        }\n        TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n        if (valueTypeDeser != null) {\n            valueTypeDeser = valueTypeDeser.forProperty(property);\n        }\n        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n    }\n"}
{"bug_id": "Cli-38", "buggy_code": "1     private boolean isShortOption(String token)\n2     {\n3         if (!token.startsWith(\"-\") || token.length() == 1)\n4         {\n5             return false;\n6         }\n7         int pos = token.indexOf(\"=\");\n8         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n9         return options.hasShortOption(optName);\n10     }\n", "fixed_code": "    private boolean isShortOption(String token)\n    {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName))\n        {\n            return true;\n        }\n        return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));\n    }\n"}
{"bug_id": "Time-15", "buggy_code": "1     public static long safeMultiply(long val1, int val2) {\n2         switch (val2) {\n3             case -1:\n4                 return -val1;\n5             case 0:\n6                 return 0L;\n7             case 1:\n8                 return val1;\n9         }\n10         long total = val1 * val2;\n11         if (total / val2 != val1) {\n12           throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n13         }\n14         return total;\n15     }\n", "fixed_code": "    public static long safeMultiply(long val1, int val2) {\n        switch (val2) {\n            case -1:\n                if (val1 == Long.MIN_VALUE) {\n                    throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n                }\n                return -val1;\n            case 0:\n                return 0L;\n            case 1:\n                return val1;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n"}
{"bug_id": "Csv-3", "buggy_code": "1     int readEscape() throws IOException {\n2         final int c = in.read();\n3         switch (c) {\n4         case 'r':\n5             return CR;\n6         case 'n':\n7             return LF;\n8         case 't':\n9             return TAB;\n10         case 'b':\n11             return BACKSPACE;\n12         case 'f':\n13             return FF;\n14         case CR:\n15         case LF:\n16         case FF: \n17         case TAB: \n18         case BACKSPACE: \n19             return c;\n20         case END_OF_STREAM:\n21             throw new IOException(\"EOF whilst processing escape sequence\");\n22         default:\n23                 return c;\n24         }\n25     }\n", "fixed_code": "    int readEscape() throws IOException {\n        final int c = in.read();\n        switch (c) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: \n        case TAB: \n        case BACKSPACE: \n            return c;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) {\n                return c;\n            }\n            return END_OF_STREAM;\n        }\n    }\n"}
{"bug_id": "Closure-4", "buggy_code": "1   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n2     boolean resolved = resolveViaRegistry(t, enclosing);\n3     if (detectImplicitPrototypeCycle()) {\n4       handleTypeCycle(t);\n5     }\n6     if (resolved) {\n7       super.resolveInternal(t, enclosing);\n8       finishPropertyContinuations();\n9       return registry.isLastGeneration() ?\n10           getReferencedType() : this;\n11     }\n12     resolveViaProperties(t, enclosing);\n13     if (detectImplicitPrototypeCycle()) {\n14       handleTypeCycle(t);\n15     }\n16     super.resolveInternal(t, enclosing);\n17     if (isResolved()) {\n18       finishPropertyContinuations();\n19     }\n20     return registry.isLastGeneration() ?\n21         getReferencedType() : this;\n22   }\n", "fixed_code": "  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectInheritanceCycle()) {\n      handleTypeCycle(t);\n    }\n    if (resolved) {\n      super.resolveInternal(t, enclosing);\n      finishPropertyContinuations();\n      return registry.isLastGeneration() ?\n          getReferencedType() : this;\n    }\n    resolveViaProperties(t, enclosing);\n    if (detectInheritanceCycle()) {\n      handleTypeCycle(t);\n    }\n    super.resolveInternal(t, enclosing);\n    if (isResolved()) {\n      finishPropertyContinuations();\n    }\n    return registry.isLastGeneration() ?\n        getReferencedType() : this;\n  }\n"}
{"bug_id": "Collections-27", "buggy_code": "", "fixed_code": "        private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException {\n            is.defaultReadObject();\n            if (clazz != null && !Collection.class.isAssignableFrom(clazz)) {\n                throw new UnsupportedOperationException();\n            }\n        }\n"}
{"bug_id": "Csv-4", "buggy_code": "1     public Map<String, Integer> getHeaderMap() {\n2         return new LinkedHashMap<String, Integer>(this.headerMap);\n3     }\n", "fixed_code": "    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n"}
{"bug_id": "Compress-18", "buggy_code": "1     void writePaxHeaders(String entryName,\n2                          Map<String, String> headers) throws IOException {\n3         String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n4         if (name.length() >= TarConstants.NAMELEN) {\n5             name = name.substring(0, TarConstants.NAMELEN - 1);\n6         }\n7         TarArchiveEntry pex = new TarArchiveEntry(name,\n8                                                   TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n9         StringWriter w = new StringWriter();\n10         for (Map.Entry<String, String> h : headers.entrySet()) {\n11             String key = h.getKey();\n12             String value = h.getValue();\n13             int len = key.length() + value.length()\n14                 + 3 \n15                 + 2 ;\n16             String line = len + \" \" + key + \"=\" + value + \"\\n\";\n17             int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n18             while (len != actualLength) {\n19                 len = actualLength;\n20                 line = len + \" \" + key + \"=\" + value + \"\\n\";\n21                 actualLength = line.getBytes(CharsetNames.UTF_8).length;\n22             }\n23             w.write(line);\n24         }\n25         byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n26         pex.setSize(data.length);\n27         putArchiveEntry(pex);\n28         write(data);\n29         closeArchiveEntry();\n30     }\n", "fixed_code": "    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n        while (name.endsWith(\"/\")) {\n            name = name.substring(0, name.length() - 1);\n        }\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 \n                + 2 ;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            while (len != actualLength) {\n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }\n"}
{"bug_id": "Closure-96", "buggy_code": "1   private void visitParameterList(NodeTraversal t, Node call,\n2       FunctionType functionType) {\n3     Iterator<Node> arguments = call.children().iterator();\n4     arguments.next(); \n5     Iterator<Node> parameters = functionType.getParameters().iterator();\n6     int ordinal = 0;\n7     Node parameter = null;\n8     Node argument = null;\n9     while (arguments.hasNext() &&\n10            parameters.hasNext()) {\n11         parameter = parameters.next();\n12       argument = arguments.next();\n13       ordinal++;\n14       validator.expectArgumentMatchesParameter(t, argument,\n15           getJSType(argument), getJSType(parameter), call, ordinal);\n16     }\n17     int numArgs = call.getChildCount() - 1;\n18     int minArgs = functionType.getMinArguments();\n19     int maxArgs = functionType.getMaxArguments();\n20     if (minArgs > numArgs || maxArgs < numArgs) {\n21       report(t, call, WRONG_ARGUMENT_COUNT,\n22               validator.getReadableJSTypeName(call.getFirstChild(), false),\n23               String.valueOf(numArgs), String.valueOf(minArgs),\n24               maxArgs != Integer.MAX_VALUE ?\n25               \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n26     }\n27   }\n", "fixed_code": "  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); \n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n    while (arguments.hasNext() &&\n           (parameters.hasNext() ||\n            parameter != null && parameter.isVarArgs())) {\n      if (parameters.hasNext()) {\n        parameter = parameters.next();\n      }\n      argument = arguments.next();\n      ordinal++;\n      validator.expectArgumentMatchesParameter(t, argument,\n          getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n    int numArgs = call.getChildCount() - 1;\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n    if (minArgs > numArgs || maxArgs < numArgs) {\n      report(t, call, WRONG_ARGUMENT_COUNT,\n              validator.getReadableJSTypeName(call.getFirstChild(), false),\n              String.valueOf(numArgs), String.valueOf(minArgs),\n              maxArgs != Integer.MAX_VALUE ?\n              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n    }\n  }\n"}
{"bug_id": "JacksonDatabind-97", "buggy_code": "1     public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n2     {\n3         if (_value == null) {\n4             ctxt.defaultSerializeNull(gen);\n5         } else if (_value instanceof JsonSerializable) {\n6             ((JsonSerializable) _value).serialize(gen, ctxt);\n7         } else {\n8             gen.writeObject(_value);\n9         }\n10     }\n", "fixed_code": "    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n    {\n        if (_value == null) {\n            ctxt.defaultSerializeNull(gen);\n        } else if (_value instanceof JsonSerializable) {\n            ((JsonSerializable) _value).serialize(gen, ctxt);\n        } else {\n            ctxt.defaultSerializeValue(_value, gen);\n        }\n    }\n"}
{"bug_id": "JacksonDatabind-47", "buggy_code": "1     public JavaType refineSerializationType(final MapperConfig<?> config,\n2             final Annotated a, final JavaType baseType) throws JsonMappingException\n3     {\n4         JavaType type = baseType;\n5         final TypeFactory tf = config.getTypeFactory();\n6         Class<?> serClass = findSerializationType(a);\n7         if (serClass != null) {\n8             if (type.hasRawClass(serClass)) {\n9                 type = type.withStaticTyping();\n10             } else {\n11                 try {\n12                         type = tf.constructGeneralizedType(type, serClass);\n13                 } catch (IllegalArgumentException iae) {\n14                     throw new JsonMappingException(null,\n15                             String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n16                                     type, serClass.getName(), a.getName(), iae.getMessage()),\n17                                     iae);\n18                 }\n19             }\n20         }\n21         if (type.isMapLikeType()) {\n22             JavaType keyType = type.getKeyType();\n23             Class<?> keyClass = findSerializationKeyType(a, keyType);\n24             if (keyClass != null) {\n25                 if (keyType.hasRawClass(keyClass)) {\n26                     keyType = keyType.withStaticTyping();\n27                 } else {\n28                     Class<?> currRaw = keyType.getRawClass();\n29                     try {\n30                         if (keyClass.isAssignableFrom(currRaw)) { \n31                             keyType = tf.constructGeneralizedType(keyType, keyClass);\n32                         } else if (currRaw.isAssignableFrom(keyClass)) { \n33                             keyType = tf.constructSpecializedType(keyType, keyClass);\n34                         } else {\n35                             throw new JsonMappingException(null,\n36                                     String.format(\"Can not refine serialization key type %s into %s; types not related\",\n37                                             keyType, keyClass.getName()));\n38                         }\n39                     } catch (IllegalArgumentException iae) {\n40                         throw new JsonMappingException(null,\n41                                 String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n42                                         type, keyClass.getName(), a.getName(), iae.getMessage()),\n43                                         iae);\n44                     }\n45                 }\n46                 type = ((MapLikeType) type).withKeyType(keyType);\n47             }\n48         }\n49         JavaType contentType = type.getContentType();\n50         if (contentType != null) { \n51            Class<?> contentClass = findSerializationContentType(a, contentType);\n52            if (contentClass != null) {\n53                if (contentType.hasRawClass(contentClass)) {\n54                    contentType = contentType.withStaticTyping();\n55                } else {\n56                    Class<?> currRaw = contentType.getRawClass();\n57                    try {\n58                        if (contentClass.isAssignableFrom(currRaw)) { \n59                            contentType = tf.constructGeneralizedType(contentType, contentClass);\n60                        } else if (currRaw.isAssignableFrom(contentClass)) { \n61                            contentType = tf.constructSpecializedType(contentType, contentClass);\n62                        } else {\n63                            throw new JsonMappingException(null,\n64                                    String.format(\"Can not refine serialization content type %s into %s; types not related\",\n65                                            contentType, contentClass.getName()));\n66                        }\n67                    } catch (IllegalArgumentException iae) { \n68                        throw new JsonMappingException(null,\n69                                String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n70                                        type, contentClass.getName(), a.getName(), iae.getMessage()),\n71                                        iae);\n72                    }\n73                }\n74                type = type.withContentType(contentType);\n75            }\n76         }\n77         return type;\n78     }\n", "fixed_code": "    public JavaType refineSerializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException\n    {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n        Class<?> serClass = findSerializationType(a);\n        if (serClass != null) {\n            if (type.hasRawClass(serClass)) {\n                type = type.withStaticTyping();\n            } else {\n                Class<?> currRaw = type.getRawClass();\n                try {\n                    if (serClass.isAssignableFrom(currRaw)) { \n                        type = tf.constructGeneralizedType(type, serClass);\n                    } else if (currRaw.isAssignableFrom(serClass)) { \n                        type = tf.constructSpecializedType(type, serClass);\n                    } else {\n                        throw new JsonMappingException(null,\n                                String.format(\"Can not refine serialization type %s into %s; types not related\",\n                                        type, serClass.getName()));\n                    }\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                    type, serClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findSerializationKeyType(a, keyType);\n            if (keyClass != null) {\n                if (keyType.hasRawClass(keyClass)) {\n                    keyType = keyType.withStaticTyping();\n                } else {\n                    Class<?> currRaw = keyType.getRawClass();\n                    try {\n                        if (keyClass.isAssignableFrom(currRaw)) { \n                            keyType = tf.constructGeneralizedType(keyType, keyClass);\n                        } else if (currRaw.isAssignableFrom(keyClass)) { \n                            keyType = tf.constructSpecializedType(keyType, keyClass);\n                        } else {\n                            throw new JsonMappingException(null,\n                                    String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                            keyType, keyClass.getName()));\n                        }\n                    } catch (IllegalArgumentException iae) {\n                        throw new JsonMappingException(null,\n                                String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                        type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                        iae);\n                    }\n                }\n                type = ((MapLikeType) type).withKeyType(keyType);\n            }\n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { \n           Class<?> contentClass = findSerializationContentType(a, contentType);\n           if (contentClass != null) {\n               if (contentType.hasRawClass(contentClass)) {\n                   contentType = contentType.withStaticTyping();\n               } else {\n                   Class<?> currRaw = contentType.getRawClass();\n                   try {\n                       if (contentClass.isAssignableFrom(currRaw)) { \n                           contentType = tf.constructGeneralizedType(contentType, contentClass);\n                       } else if (currRaw.isAssignableFrom(contentClass)) { \n                           contentType = tf.constructSpecializedType(contentType, contentClass);\n                       } else {\n                           throw new JsonMappingException(null,\n                                   String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                           contentType, contentClass.getName()));\n                       }\n                   } catch (IllegalArgumentException iae) { \n                       throw new JsonMappingException(null,\n                               String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                       type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                       iae);\n                   }\n               }\n               type = type.withContentType(contentType);\n           }\n        }\n        return type;\n    }\n"}
{"bug_id": "Math-27", "buggy_code": "1     public double percentageValue() {\n2         return multiply(100).doubleValue();\n3     }\n", "fixed_code": "    public double percentageValue() {\n        return 100 * doubleValue();\n    }\n"}
{"bug_id": "Closure-36", "buggy_code": "1     private boolean canInline(\n2         Reference declaration,\n3         Reference initialization,\n4         Reference reference) {\n5       if (!isValidDeclaration(declaration)\n6           || !isValidInitialization(initialization)\n7           || !isValidReference(reference)) {\n8         return false;\n9       }\n10       if (declaration != initialization &&\n11           !initialization.getGrandparent().isExprResult()) {\n12         return false;\n13       }\n14       if (declaration.getBasicBlock() != initialization.getBasicBlock()\n15           || declaration.getBasicBlock() != reference.getBasicBlock()) {\n16         return false;\n17       }\n18       Node value = initialization.getAssignedValue();\n19       Preconditions.checkState(value != null);\n20       if (value.isGetProp()\n21           && reference.getParent().isCall()\n22           && reference.getParent().getFirstChild() == reference.getNode()) {\n23         return false;\n24       }\n25       if (value.isFunction()) {\n26         Node callNode = reference.getParent();\n27         if (reference.getParent().isCall()) {\n28           CodingConvention convention = compiler.getCodingConvention();\n29           SubclassRelationship relationship =\n30               convention.getClassesDefinedByCall(callNode);\n31           if (relationship != null) {\n32             return false;\n33           }\n34         }\n35       }\n36       return canMoveAggressively(value) ||\n37           canMoveModerately(initialization, reference);\n38     }\n", "fixed_code": "    private boolean canInline(\n        Reference declaration,\n        Reference initialization,\n        Reference reference) {\n      if (!isValidDeclaration(declaration)\n          || !isValidInitialization(initialization)\n          || !isValidReference(reference)) {\n        return false;\n      }\n      if (declaration != initialization &&\n          !initialization.getGrandparent().isExprResult()) {\n        return false;\n      }\n      if (declaration.getBasicBlock() != initialization.getBasicBlock()\n          || declaration.getBasicBlock() != reference.getBasicBlock()) {\n        return false;\n      }\n      Node value = initialization.getAssignedValue();\n      Preconditions.checkState(value != null);\n      if (value.isGetProp()\n          && reference.getParent().isCall()\n          && reference.getParent().getFirstChild() == reference.getNode()) {\n        return false;\n      }\n      if (value.isFunction()) {\n        Node callNode = reference.getParent();\n        if (reference.getParent().isCall()) {\n          CodingConvention convention = compiler.getCodingConvention();\n          SubclassRelationship relationship =\n              convention.getClassesDefinedByCall(callNode);\n          if (relationship != null) {\n            return false;\n          }\n          if (convention.getSingletonGetterClassName(callNode) != null) {\n            return false;\n          }\n        }\n      }\n      return canMoveAggressively(value) ||\n          canMoveModerately(initialization, reference);\n    }\n"}
{"bug_id": "Jsoup-13", "buggy_code": "1     public boolean hasAttr(String attributeKey) {\n2         Validate.notNull(attributeKey);\n3         return attributes.hasKey(attributeKey);\n4     }\n", "fixed_code": "    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        if (attributeKey.toLowerCase().startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n                return true;\n        }\n        return attributes.hasKey(attributeKey);\n    }\n"}
{"bug_id": "Compress-14", "buggy_code": "1     public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n2         long    result = 0;\n3         int     end = offset + length;\n4         int     start = offset;\n5         if (length < 2){\n6             throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n7         }\n8         boolean allNUL = true;\n9         for (int i = start; i < end; i++){\n10             if (buffer[i] != 0){\n11                 allNUL = false;\n12                 break;\n13             }\n14         }\n15         if (allNUL) {\n16             return 0L;\n17         }\n18         while (start < end){\n19             if (buffer[start] == ' '){\n20                 start++;\n21             } else {\n22                 break;\n23             }\n24         }\n25         byte trailer;\n26         trailer = buffer[end-1];\n27         if (trailer == 0 || trailer == ' '){\n28             end--;\n29         } else {\n30             throw new IllegalArgumentException(\n31                     exceptionMessage(buffer, offset, length, end-1, trailer));\n32         }\n33         trailer = buffer[end-1];\n34         if (trailer == 0 || trailer == ' '){\n35             end--;\n36         }\n37         for ( ;start < end; start++) {\n38             final byte currentByte = buffer[start];\n39             if (currentByte < '0' || currentByte > '7'){\n40                 throw new IllegalArgumentException(\n41                         exceptionMessage(buffer, offset, length, start, currentByte));\n42             }\n43             result = (result << 3) + (currentByte - '0'); \n44         }\n45         return result;\n46     }\n", "fixed_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); \n        }\n        return result;\n    }\n"}
{"bug_id": "JacksonDatabind-83", "buggy_code": "1     public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n2     {\n3         String text = p.getValueAsString();\n4         if (text != null) { \n5             if (text.length() == 0 || (text = text.trim()).length() == 0) {\n6                 return _deserializeFromEmptyString();\n7             }\n8             Exception cause = null;\n9             try {\n10                 if (_deserialize(text, ctxt) != null) {\n11                 return _deserialize(text, ctxt);\n12                 }\n13             } catch (IllegalArgumentException iae) {\n14                 cause = iae;\n15             } catch (MalformedURLException me) {\n16                 cause = me;\n17             }\n18             String msg = \"not a valid textual representation\";\n19             if (cause != null) {\n20                 String m2 = cause.getMessage();\n21                 if (m2 != null) {\n22                     msg = msg + \", problem: \"+m2;\n23                 }\n24             }\n25             JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n26             if (cause != null) {\n27                 e.initCause(cause);\n28             }\n29             throw e;\n30         }\n31         JsonToken t = p.getCurrentToken();\n32         if (t == JsonToken.START_ARRAY) {\n33             return _deserializeFromArray(p, ctxt);\n34         }\n35         if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n36             Object ob = p.getEmbeddedObject();\n37             if (ob == null) {\n38                 return null;\n39             }\n40             if (_valueClass.isAssignableFrom(ob.getClass())) {\n41                 return (T) ob;\n42             }\n43             return _deserializeEmbedded(ob, ctxt);\n44         }\n45         return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n46     }\n", "fixed_code": "    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        String text = p.getValueAsString();\n        if (text != null) { \n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                return _deserializeFromEmptyString();\n            }\n            Exception cause = null;\n            try {\n                return _deserialize(text, ctxt);\n            } catch (IllegalArgumentException iae) {\n                cause = iae;\n            } catch (MalformedURLException me) {\n                cause = me;\n            }\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n        }\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }\n"}
{"bug_id": "Closure-24", "buggy_code": "1     private void findAliases(NodeTraversal t) {\n2       Scope scope = t.getScope();\n3       for (Var v : scope.getVarIterable()) {\n4         Node n = v.getNode();\n5         int type = n.getType();\n6         Node parent = n.getParent();\n7         if (parent.isVar()) {\n8           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n9           String name = n.getString();\n10           Var aliasVar = scope.getVar(name);\n11           aliases.put(name, aliasVar);\n12           String qualifiedName =\n13               aliasVar.getInitialValue().getQualifiedName();\n14           transformation.addAlias(name, qualifiedName);\n15         } else {\n16           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n17         }\n18         }\n19       }\n20     }\n", "fixed_code": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n        if (parent.isVar() &&\n            n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n          String name = n.getString();\n          Var aliasVar = scope.getVar(name);\n          aliases.put(name, aliasVar);\n          String qualifiedName =\n              aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n        } else if (v.isBleedingFunction()) {\n        } else if (parent.getType() == Token.LP) {\n        } else {\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n"}
{"bug_id": "Math-57", "buggy_code": "1     private static <T extends Clusterable<T>> List<Cluster<T>>\n2         chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n3         final List<T> pointSet = new ArrayList<T>(points);\n4         final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n5         final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n6         resultSet.add(new Cluster<T>(firstPoint));\n7         final double[] dx2 = new double[pointSet.size()];\n8         while (resultSet.size() < k) {\n9             int sum = 0;\n10             for (int i = 0; i < pointSet.size(); i++) {\n11                 final T p = pointSet.get(i);\n12                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n13                 final double d = p.distanceFrom(nearest.getCenter());\n14                 sum += d * d;\n15                 dx2[i] = sum;\n16             }\n17             final double r = random.nextDouble() * sum;\n18             for (int i = 0 ; i < dx2.length; i++) {\n19                 if (dx2[i] >= r) {\n20                     final T p = pointSet.remove(i);\n21                     resultSet.add(new Cluster<T>(p));\n22                     break;\n23                 }\n24             }\n25         }\n26         return resultSet;\n27     }\n", "fixed_code": "    private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n            double sum = 0;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n        return resultSet;\n    }\n"}
{"bug_id": "Closure-57", "buggy_code": "1   private static String extractClassNameIfGoog(Node node, Node parent,\n2       String functionName){\n3     String className = null;\n4     if (NodeUtil.isExprCall(parent)) {\n5       Node callee = node.getFirstChild();\n6       if (callee != null && callee.getType() == Token.GETPROP) {\n7         String qualifiedName = callee.getQualifiedName();\n8         if (functionName.equals(qualifiedName)) {\n9           Node target = callee.getNext();\n10           if (target != null) {\n11             className = target.getString();\n12           }\n13         }\n14       }\n15     }\n16     return className;\n17   }\n", "fixed_code": "  private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName){\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n      Node callee = node.getFirstChild();\n      if (callee != null && callee.getType() == Token.GETPROP) {\n        String qualifiedName = callee.getQualifiedName();\n        if (functionName.equals(qualifiedName)) {\n          Node target = callee.getNext();\n          if (target != null && target.getType() == Token.STRING) {\n            className = target.getString();\n          }\n        }\n      }\n    }\n    return className;\n  }\n"}
{"bug_id": "Jsoup-1", "buggy_code": "1     private void normalise(Element element) {\n2         List<Node> toMove = new ArrayList<Node>();\n3         for (Node node: element.childNodes) {\n4             if (node instanceof TextNode) {\n5                 TextNode tn = (TextNode) node;\n6                 if (!tn.isBlank())\n7                     toMove.add(tn);\n8             }\n9         }\n10         for (Node node: toMove) {\n11             element.removeChild(node);\n12             body().appendChild(new TextNode(\" \", \"\"));\n13             body().appendChild(node);\n14         }\n15     }\n", "fixed_code": "    private void normalise(Element element) {\n        List<Node> toMove = new ArrayList<Node>();\n        for (Node node: element.childNodes) {\n            if (node instanceof TextNode) {\n                TextNode tn = (TextNode) node;\n                if (!tn.isBlank())\n                    toMove.add(tn);\n            }\n        }\n        for (Node node: toMove) {\n            element.removeChild(node);\n            body().prependChild(node);\n            body().prependChild(new TextNode(\" \", \"\"));\n        }\n    }\n"}
{"bug_id": "Math-32", "buggy_code": "1     protected void computeGeometricalProperties() {\n2         final Vector2D[][] v = getVertices();\n3         if (v.length == 0) {\n4             final BSPTree<Euclidean2D> tree = getTree(false);\n5             if ((Boolean) tree.getAttribute()) {\n6                 setSize(Double.POSITIVE_INFINITY);\n7                 setBarycenter(Vector2D.NaN);\n8             } else {\n9                 setSize(0);\n10                 setBarycenter(new Vector2D(0, 0));\n11             }\n12         } else if (v[0][0] == null) {\n13             setSize(Double.POSITIVE_INFINITY);\n14             setBarycenter(Vector2D.NaN);\n15         } else {\n16             double sum  = 0;\n17             double sumX = 0;\n18             double sumY = 0;\n19             for (Vector2D[] loop : v) {\n20                 double x1 = loop[loop.length - 1].getX();\n21                 double y1 = loop[loop.length - 1].getY();\n22                 for (final Vector2D point : loop) {\n23                     final double x0 = x1;\n24                     final double y0 = y1;\n25                     x1 = point.getX();\n26                     y1 = point.getY();\n27                     final double factor = x0 * y1 - y0 * x1;\n28                     sum  += factor;\n29                     sumX += factor * (x0 + x1);\n30                     sumY += factor * (y0 + y1);\n31                 }\n32             }\n33             if (sum < 0) {\n34                 setSize(Double.POSITIVE_INFINITY);\n35                 setBarycenter(Vector2D.NaN);\n36             } else {\n37                 setSize(sum / 2);\n38                 setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n39             }\n40         }\n41     }\n", "fixed_code": "    protected void computeGeometricalProperties() {\n        final Vector2D[][] v = getVertices();\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n            if (sum < 0) {\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n        }\n    }\n"}
{"bug_id": "Math-72", "buggy_code": "1     public double solve(final UnivariateRealFunction f,\n2                         final double min, final double max, final double initial)\n3         throws MaxIterationsExceededException, FunctionEvaluationException {\n4         clearResult();\n5         verifySequence(min, initial, max);\n6         double yInitial = f.value(initial);\n7         if (Math.abs(yInitial) <= functionValueAccuracy) {\n8             setResult(initial, 0);\n9             return result;\n10         }\n11         double yMin = f.value(min);\n12         if (Math.abs(yMin) <= functionValueAccuracy) {\n13             setResult(yMin, 0);\n14             return result;\n15         }\n16         if (yInitial * yMin < 0) {\n17             return solve(f, min, yMin, initial, yInitial, min, yMin);\n18         }\n19         double yMax = f.value(max);\n20         if (Math.abs(yMax) <= functionValueAccuracy) {\n21             setResult(yMax, 0);\n22             return result;\n23         }\n24         if (yInitial * yMax < 0) {\n25             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n26         }\n27         if (yMin * yMax > 0) {\n28             throw MathRuntimeException.createIllegalArgumentException(\n29                   NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n30         }\n31         return solve(f, min, yMin, max, yMax, initial, yInitial);\n32     }\n", "fixed_code": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        verifySequence(min, initial, max);\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n            return result;\n        }\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            return result;\n        }\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n    }\n"}
{"bug_id": "JacksonCore-6", "buggy_code": "1     private final static int _parseIndex(String str) {\n2         final int len = str.length();\n3         if (len == 0 || len > 10) {\n4             return -1;\n5         }\n6         for (int i = 0; i < len; ++i) {\n7             char c = str.charAt(i);\n8             if (c > '9' || c < '0') {\n9                 return -1;\n10             }\n11         }\n12         if (len == 10) {\n13             long l = NumberInput.parseLong(str);\n14             if (l > Integer.MAX_VALUE) {\n15                 return -1;\n16             }\n17         }\n18         return NumberInput.parseInt(str);\n19     }\n", "fixed_code": "    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        char c = str.charAt(0);\n        if (c <= '0') {\n            return (len == 1 && c == '0') ? 0 : -1;\n        }\n        if (c > '9') {\n            return -1;\n        }\n        for (int i = 1; i < len; ++i) {\n            c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n"}
{"bug_id": "Closure-172", "buggy_code": "1     private boolean isQualifiedNameInferred(\n2         String qName, Node n, JSDocInfo info,\n3         Node rhsValue, JSType valueType) {\n4       if (valueType == null) {\n5         return true;\n6       }\n7       if (qName != null && qName.endsWith(\".prototype\")) {\n8           return false;\n9       }\n10       boolean inferred = true;\n11       if (info != null) {\n12         inferred = !(info.hasType()\n13             || info.hasEnumParameterType()\n14             || (isConstantSymbol(info, n) && valueType != null\n15                 && !valueType.isUnknownType())\n16             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n17       }\n18       if (inferred && rhsValue != null && rhsValue.isFunction()) {\n19         if (info != null) {\n20           return false;\n21         } else if (!scope.isDeclared(qName, false) &&\n22             n.isUnscopedQualifiedName()) {\n23           for (Node current = n.getParent();\n24                !(current.isScript() || current.isFunction());\n25                current = current.getParent()) {\n26             if (NodeUtil.isControlStructure(current)) {\n27               return true;\n28             }\n29           }\n30           AstFunctionContents contents =\n31               getFunctionAnalysisResults(scope.getRootNode());\n32           if (contents == null ||\n33               !contents.getEscapedQualifiedNames().contains(qName)) {\n34             return false;\n35           }\n36         }\n37       }\n38       return inferred;\n39     }\n", "fixed_code": "    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n      if (qName != null && qName.endsWith(\".prototype\")) {\n        String className = qName.substring(0, qName.lastIndexOf(\".prototype\"));\n        Var slot = scope.getSlot(className);\n        JSType classType = slot == null ? null : slot.getType();\n        if (classType != null\n            && (classType.isConstructor() || classType.isInterface())) {\n          return false;\n        }\n      }\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }\n"}
{"bug_id": "Closure-150", "buggy_code": "1     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n2       if (n == scope.getRootNode()) return;\n3       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n4         handleFunctionInputs(parent);\n5         return;\n6       }\n7       attachLiteralTypes(n);\n8       switch (n.getType()) {\n9         case Token.FUNCTION:\n10           if (parent.getType() == Token.NAME) {\n11             return;\n12           }\n13           defineDeclaredFunction(n, parent);\n14           break;\n15         case Token.CATCH:\n16           defineCatch(n, parent);\n17           break;\n18         case Token.VAR:\n19           defineVar(n, parent);\n20           break;\n21       }\n22     }\n", "fixed_code": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n      super.visit(t, n, parent);\n    }\n"}
{"bug_id": "Jsoup-45", "buggy_code": "1     void resetInsertionMode() {\n2         boolean last = false;\n3         for (int pos = stack.size() -1; pos >= 0; pos--) {\n4             Element node = stack.get(pos);\n5             if (pos == 0) {\n6                 last = true;\n7                 node = contextElement;\n8             }\n9             String name = node.nodeName();\n10             if (\"select\".equals(name)) {\n11                 transition(HtmlTreeBuilderState.InSelect);\n12                 break; \n13             } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n14                 transition(HtmlTreeBuilderState.InCell);\n15                 break;\n16             } else if (\"tr\".equals(name)) {\n17                 transition(HtmlTreeBuilderState.InRow);\n18                 break;\n19             } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n20                 transition(HtmlTreeBuilderState.InTableBody);\n21                 break;\n22             } else if (\"caption\".equals(name)) {\n23                 transition(HtmlTreeBuilderState.InCaption);\n24                 break;\n25             } else if (\"colgroup\".equals(name)) {\n26                 transition(HtmlTreeBuilderState.InColumnGroup);\n27                 break; \n28             } else if (\"table\".equals(name)) {\n29                 transition(HtmlTreeBuilderState.InTable);\n30                 break;\n31             } else if (\"head\".equals(name)) {\n32                 transition(HtmlTreeBuilderState.InBody);\n33                 break; \n34             } else if (\"body\".equals(name)) {\n35                 transition(HtmlTreeBuilderState.InBody);\n36                 break;\n37             } else if (\"frameset\".equals(name)) {\n38                 transition(HtmlTreeBuilderState.InFrameset);\n39                 break; \n40             } else if (\"html\".equals(name)) {\n41                 transition(HtmlTreeBuilderState.BeforeHead);\n42                 break; \n43             } else if (last) {\n44                 transition(HtmlTreeBuilderState.InBody);\n45                 break; \n46             }\n47         }\n48     }\n", "fixed_code": "    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; \n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; \n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; \n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; \n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; \n            }\n        }\n    }\n"}
{"bug_id": "Compress-40", "buggy_code": "1     public long readBits(final int count) throws IOException {\n2         if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n3             throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n4         }\n5         while (bitsCachedSize < count) {\n6             final long nextByte = in.read();\n7             if (nextByte < 0) {\n8                 return nextByte;\n9             }\n10             if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n11                 bitsCached |= (nextByte << bitsCachedSize);\n12             } else {\n13                 bitsCached <<= 8;\n14                 bitsCached |= nextByte;\n15             }\n16             bitsCachedSize += 8;\n17         }\n18         final long bitsOut;\n19             if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n20                 bitsOut = (bitsCached & MASKS[count]);\n21                 bitsCached >>>= count;\n22             } else {\n23                 bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n24             }\n25             bitsCachedSize -= count;\n26         return bitsOut;\n27     }\n", "fixed_code": "    public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n        while (bitsCachedSize < count && bitsCachedSize < 57) {\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsCached |= (nextByte << bitsCachedSize);\n            } else {\n                bitsCached <<= 8;\n                bitsCached |= nextByte;\n            }\n            bitsCachedSize += 8;\n        }\n        int overflowBits = 0;\n        long overflow = 0l;\n        if (bitsCachedSize < count) {\n            int bitsToAddCount = count - bitsCachedSize;\n            overflowBits = 8 - bitsToAddCount;\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n                bitsCached |= (bitsToAdd << bitsCachedSize);\n                overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n            } else {\n                bitsCached <<= bitsToAddCount;\n                long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n                bitsCached |= bitsToAdd;\n                overflow = nextByte & MASKS[overflowBits];\n            }\n            bitsCachedSize = count;\n        }\n        final long bitsOut;\n        if (overflowBits == 0) {\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsOut = (bitsCached & MASKS[count]);\n                bitsCached >>>= count;\n            } else {\n                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n            }\n            bitsCachedSize -= count;\n        } else {\n            bitsOut = bitsCached & MASKS[count];\n            bitsCached = overflow;\n            bitsCachedSize = overflowBits;\n        }\n        return bitsOut;\n    }\n"}
{"bug_id": "JacksonDatabind-39", "buggy_code": "1     public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n2     {\n3             p.skipChildren();\n4         return null;\n5     }\n", "fixed_code": "    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        if (p.hasToken(JsonToken.FIELD_NAME)) {\n            while (true) {\n                JsonToken t = p.nextToken();\n                if ((t == null) || (t == JsonToken.END_OBJECT)) {\n                    break;\n                }\n                p.skipChildren();\n            }\n        } else {\n            p.skipChildren();\n        }\n        return null;\n    }\n"}
{"bug_id": "Closure-117", "buggy_code": "1   String getReadableJSTypeName(Node n, boolean dereference) {\n2     if (n.isGetProp()) {\n3       ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n4       if (objectType != null) {\n5         String propName = n.getLastChild().getString();\n6         if (objectType.getConstructor() != null &&\n7             objectType.getConstructor().isInterface()) {\n8           objectType = FunctionType.getTopDefiningInterface(\n9               objectType, propName);\n10         } else {\n11           while (objectType != null && !objectType.hasOwnProperty(propName)) {\n12             objectType = objectType.getImplicitPrototype();\n13           }\n14         }\n15         if (objectType != null &&\n16             (objectType.getConstructor() != null ||\n17              objectType.isFunctionPrototypeType())) {\n18           return objectType.toString() + \".\" + propName;\n19         }\n20       }\n21     }\n22     JSType type = getJSType(n);\n23     if (dereference) {\n24       ObjectType dereferenced = type.dereference();\n25       if (dereferenced != null) {\n26         type = dereferenced;\n27       }\n28     }\n29     if (type.isFunctionPrototypeType() ||\n30         (type.toObjectType() != null &&\n31          type.toObjectType().getConstructor() != null)) {\n32       return type.toString();\n33     }\n34     String qualifiedName = n.getQualifiedName();\n35     if (qualifiedName != null) {\n36       return qualifiedName;\n37     } else if (type.isFunctionType()) {\n38       return \"function\";\n39     } else {\n40       return type.toString();\n41     }\n42   }\n", "fixed_code": "  String getReadableJSTypeName(Node n, boolean dereference) {\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      return type.toString();\n    }\n    if (n.isGetProp()) {\n      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          objectType = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n        } else {\n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      return qualifiedName;\n    } else if (type.isFunctionType()) {\n      return \"function\";\n    } else {\n      return type.toString();\n    }\n  }\n"}
{"bug_id": "Closure-130", "buggy_code": "1   private void inlineAliases(GlobalNamespace namespace) {\n2     Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n3     while (!workList.isEmpty()) {\n4       Name name = workList.pop();\n5       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n6         continue;\n7       }\n8       if (name.globalSets == 1 && name.localSets == 0 &&\n9           name.aliasingGets > 0) {\n10         List<Ref> refs = Lists.newArrayList(name.getRefs());\n11         for (Ref ref : refs) {\n12           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n13             if (inlineAliasIfPossible(ref, namespace)) {\n14               name.removeRef(ref);\n15             }\n16           }\n17         }\n18       }\n19       if ((name.type == Name.Type.OBJECTLIT ||\n20            name.type == Name.Type.FUNCTION) &&\n21           name.aliasingGets == 0 && name.props != null) {\n22         workList.addAll(name.props);\n23       }\n24     }\n25   }\n", "fixed_code": "  private void inlineAliases(GlobalNamespace namespace) {\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        workList.addAll(name.props);\n      }\n    }\n  }\n"}
{"bug_id": "Gson-5", "buggy_code": "1     public static Date parse(String date, ParsePosition pos) throws ParseException {\n2         Exception fail = null;\n3         try {\n4             int offset = pos.getIndex();\n5             int year = parseInt(date, offset, offset += 4);\n6             if (checkOffset(date, offset, '-')) {\n7                 offset += 1;\n8             }\n9             int month = parseInt(date, offset, offset += 2);\n10             if (checkOffset(date, offset, '-')) {\n11                 offset += 1;\n12             }\n13             int day = parseInt(date, offset, offset += 2);\n14             int hour = 0;\n15             int minutes = 0;\n16             int seconds = 0;\n17             int milliseconds = 0; \n18             boolean hasT = checkOffset(date, offset, 'T');\n19             if (!hasT && (date.length() <= offset)) {\n20                 Calendar calendar = new GregorianCalendar(year, month - 1, day);\n21                 pos.setIndex(offset);\n22                 return calendar.getTime();\n23             }\n24             if (hasT) {\n25                 hour = parseInt(date, offset += 1, offset += 2);\n26                 if (checkOffset(date, offset, ':')) {\n27                     offset += 1;\n28                 }\n29                 minutes = parseInt(date, offset, offset += 2);\n30                 if (checkOffset(date, offset, ':')) {\n31                     offset += 1;\n32                 }\n33                 if (date.length() > offset) {\n34                     char c = date.charAt(offset);\n35                     if (c != 'Z' && c != '+' && c != '-') {\n36                         seconds = parseInt(date, offset, offset += 2);\n37                         if (seconds > 59 && seconds < 63) seconds = 59; \n38                         if (checkOffset(date, offset, '.')) {\n39                             offset += 1;\n40                             int endOffset = indexOfNonDigit(date, offset + 1); \n41                             int parseEndOffset = Math.min(endOffset, offset + 3); \n42                             int fraction = parseInt(date, offset, parseEndOffset);\n43                             switch (parseEndOffset - offset) { \n44                             case 2:\n45                                 milliseconds = fraction * 10;\n46                                 break;\n47                             case 1:\n48                                 milliseconds = fraction * 100;\n49                                 break;\n50                             default:\n51                                 milliseconds = fraction;\n52                             }\n53                             offset = endOffset;\n54                         }\n55                     }\n56                 }\n57             }\n58             if (date.length() <= offset) {\n59                 throw new IllegalArgumentException(\"No time zone indicator\");\n60             }\n61             TimeZone timezone = null;\n62             char timezoneIndicator = date.charAt(offset);\n63             if (timezoneIndicator == 'Z') {\n64                 timezone = TIMEZONE_UTC;\n65                 offset += 1;\n66             } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n67                 String timezoneOffset = date.substring(offset);\n68                 offset += timezoneOffset.length();\n69                 if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n70                     timezone = TIMEZONE_UTC;\n71                 } else {\n72                     String timezoneId = \"GMT\" + timezoneOffset;\n73                     timezone = TimeZone.getTimeZone(timezoneId);\n74                     String act = timezone.getID();\n75                     if (!act.equals(timezoneId)) {\n76                         String cleaned = act.replace(\":\", \"\");\n77                         if (!cleaned.equals(timezoneId)) {\n78                             throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n79                                     +timezone.getID());\n80                         }\n81                     }\n82                 }\n83             } else {\n84                 throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n85             }\n86             Calendar calendar = new GregorianCalendar(timezone);\n87             calendar.setLenient(false);\n88             calendar.set(Calendar.YEAR, year);\n89             calendar.set(Calendar.MONTH, month - 1);\n90             calendar.set(Calendar.DAY_OF_MONTH, day);\n91             calendar.set(Calendar.HOUR_OF_DAY, hour);\n92             calendar.set(Calendar.MINUTE, minutes);\n93             calendar.set(Calendar.SECOND, seconds);\n94             calendar.set(Calendar.MILLISECOND, milliseconds);\n95             pos.setIndex(offset);\n96             return calendar.getTime();\n97         } catch (IndexOutOfBoundsException e) {\n98             fail = e;\n99         } catch (NumberFormatException e) {\n100             fail = e;\n101         } catch (IllegalArgumentException e) {\n102             fail = e;\n103         }\n104         String input = (date == null) ? null : ('\"' + date + \"'\");\n105         String msg = fail.getMessage();\n106         if (msg == null || msg.isEmpty()) {\n107             msg = \"(\"+fail.getClass().getName()+\")\";\n108         }\n109         ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n110         ex.initCause(fail);\n111         throw ex;\n112     }\n", "fixed_code": "    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        Exception fail = null;\n        try {\n            int offset = pos.getIndex();\n            int year = parseInt(date, offset, offset += 4);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n            int month = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n            int day = parseInt(date, offset, offset += 2);\n            int hour = 0;\n            int minutes = 0;\n            int seconds = 0;\n            int milliseconds = 0; \n            boolean hasT = checkOffset(date, offset, 'T');\n            if (!hasT && (date.length() <= offset)) {\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n            if (hasT) {\n                hour = parseInt(date, offset += 1, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n                minutes = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n                if (date.length() > offset) {\n                    char c = date.charAt(offset);\n                    if (c != 'Z' && c != '+' && c != '-') {\n                        seconds = parseInt(date, offset, offset += 2);\n                        if (seconds > 59 && seconds < 63) seconds = 59; \n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1;\n                            int endOffset = indexOfNonDigit(date, offset + 1); \n                            int parseEndOffset = Math.min(endOffset, offset + 3); \n                            int fraction = parseInt(date, offset, parseEndOffset);\n                            switch (parseEndOffset - offset) { \n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                            }\n                            offset = endOffset;\n                        }\n                    }\n                }\n            }\n            if (date.length() <= offset) {\n                throw new IllegalArgumentException(\"No time zone indicator\");\n            }\n            TimeZone timezone = null;\n            char timezoneIndicator = date.charAt(offset);\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n                timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";\n                offset += timezoneOffset.length();\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    String timezoneId = \"GMT\" + timezoneOffset;\n                    timezone = TimeZone.getTimeZone(timezoneId);\n                    String act = timezone.getID();\n                    if (!act.equals(timezoneId)) {\n                        String cleaned = act.replace(\":\", \"\");\n                        if (!cleaned.equals(timezoneId)) {\n                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                    +timezone.getID());\n                        }\n                    }\n                }\n            } else {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n            }\n            Calendar calendar = new GregorianCalendar(timezone);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1);\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\n            calendar.set(Calendar.MINUTE, minutes);\n            calendar.set(Calendar.SECOND, seconds);\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        } catch (IndexOutOfBoundsException e) {\n            fail = e;\n        } catch (NumberFormatException e) {\n            fail = e;\n        } catch (IllegalArgumentException e) {\n            fail = e;\n        }\n        String input = (date == null) ? null : ('\"' + date + \"'\");\n        String msg = fail.getMessage();\n        if (msg == null || msg.isEmpty()) {\n            msg = \"(\"+fail.getClass().getName()+\")\";\n        }\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n        ex.initCause(fail);\n        throw ex;\n    }\n"}
{"bug_id": "Closure-131", "buggy_code": "1     public static boolean isJSIdentifier(String s) {\n2       int length = s.length();\n3       if (length == 0 ||\n4           !Character.isJavaIdentifierStart(s.charAt(0))) {\n5         return false;\n6       }\n7       for (int i = 1; i < length; i++) {\n8         if (\n9             !Character.isJavaIdentifierPart(s.charAt(i))) {\n10           return false;\n11         }\n12       }\n13       return true;\n14     }\n", "fixed_code": "    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n      if (length == 0 ||\n          Character.isIdentifierIgnorable(s.charAt(0)) ||\n          !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n      }\n      for (int i = 1; i < length; i++) {\n        if (Character.isIdentifierIgnorable(s.charAt(i)) ||\n            !Character.isJavaIdentifierPart(s.charAt(i))) {\n          return false;\n        }\n      }\n      return true;\n    }\n"}
{"bug_id": "Closure-95", "buggy_code": "1     void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n2       Preconditions.checkArgument(inferred || type != null);\n3       boolean shouldDeclareOnGlobalThis = false;\n4       if (n.getType() == Token.NAME) {\n5         Preconditions.checkArgument(\n6             parent.getType() == Token.FUNCTION ||\n7             parent.getType() == Token.VAR ||\n8             parent.getType() == Token.LP ||\n9             parent.getType() == Token.CATCH);\n10         shouldDeclareOnGlobalThis = scope.isGlobal() &&\n11             (parent.getType() == Token.VAR ||\n12              parent.getType() == Token.FUNCTION);\n13       } else {\n14         Preconditions.checkArgument(\n15             n.getType() == Token.GETPROP &&\n16             (parent.getType() == Token.ASSIGN ||\n17              parent.getType() == Token.EXPR_RESULT));\n18       }\n19       String variableName = n.getQualifiedName();\n20       Preconditions.checkArgument(!variableName.isEmpty());\n21       Scope scopeToDeclareIn = scope;\n22       if (scopeToDeclareIn.isDeclared(variableName, false)) {\n23         Var oldVar = scopeToDeclareIn.getVar(variableName);\n24         validator.expectUndeclaredVariable(\n25             sourceName, n, parent, oldVar, variableName, type);\n26       } else {\n27         if (!inferred) {\n28           setDeferredType(n, type);\n29         }\n30         CompilerInput input = compiler.getInput(sourceName);\n31         scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n32         if (shouldDeclareOnGlobalThis) {\n33           ObjectType globalThis =\n34               typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n35           boolean isExtern = input.isExtern();\n36           if (inferred) {\n37             globalThis.defineInferredProperty(variableName,\n38                 type == null ?\n39                     getNativeType(JSTypeNative.NO_TYPE) :\n40                     type,\n41                 isExtern);\n42           } else {\n43             globalThis.defineDeclaredProperty(variableName, type, isExtern);\n44           }\n45         }\n46         if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n47           FunctionType fnType = (FunctionType) type;\n48           if (fnType.isConstructor() || fnType.isInterface()) {\n49             FunctionType superClassCtor = fnType.getSuperClassConstructor();\n50             scopeToDeclareIn.declare(variableName + \".prototype\", n,\n51                 fnType.getPrototype(), compiler.getInput(sourceName),\n52                 superClassCtor == null ||\n53                 superClassCtor.getInstanceType().equals(\n54                     getNativeType(OBJECT_TYPE)));\n55           }\n56         }\n57       }\n58     }\n", "fixed_code": "    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n      boolean shouldDeclareOnGlobalThis = false;\n      if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(\n            parent.getType() == Token.FUNCTION ||\n            parent.getType() == Token.VAR ||\n            parent.getType() == Token.LP ||\n            parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() &&\n            (parent.getType() == Token.VAR ||\n             parent.getType() == Token.FUNCTION);\n      } else {\n        Preconditions.checkArgument(\n            n.getType() == Token.GETPROP &&\n            (parent.getType() == Token.ASSIGN ||\n             parent.getType() == Token.EXPR_RESULT));\n      }\n      String variableName = n.getQualifiedName();\n      Preconditions.checkArgument(!variableName.isEmpty());\n      Scope scopeToDeclareIn = scope;\n      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n          isQnameRootedInGlobalScope(n)) {\n        Scope globalScope = scope.getGlobalScope();\n        if (!globalScope.isDeclared(variableName, false)) {\n          scopeToDeclareIn = scope.getGlobalScope();\n        }\n      }\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(\n            sourceName, n, parent, oldVar, variableName, type);\n      } else {\n        if (!inferred) {\n          setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n          ObjectType globalThis =\n              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n          boolean isExtern = input.isExtern();\n          if (inferred) {\n            globalThis.defineInferredProperty(variableName,\n                type == null ?\n                    getNativeType(JSTypeNative.NO_TYPE) :\n                    type,\n                isExtern);\n          } else {\n            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n          }\n        }\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n          FunctionType fnType = (FunctionType) type;\n          if (fnType.isConstructor() || fnType.isInterface()) {\n            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n                fnType.getPrototype(), compiler.getInput(sourceName),\n                superClassCtor == null ||\n                superClassCtor.getInstanceType().equals(\n                    getNativeType(OBJECT_TYPE)));\n          }\n        }\n      }\n    }\n"}
{"bug_id": "Closure-78", "buggy_code": "1   private Node performArithmeticOp(int opType, Node left, Node right) {\n2     if (opType == Token.ADD\n3         && (NodeUtil.mayBeString(left, false)\n4             || NodeUtil.mayBeString(right, false))) {\n5       return null;\n6     }\n7     double result;\n8     Double lValObj = NodeUtil.getNumberValue(left);\n9     if (lValObj == null) {\n10       return null;\n11     }\n12     Double rValObj = NodeUtil.getNumberValue(right);\n13     if (rValObj == null) {\n14       return null;\n15     }\n16     double lval = lValObj;\n17     double rval = rValObj;\n18     switch (opType) {\n19       case Token.BITAND:\n20         result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n21         break;\n22       case Token.BITOR:\n23         result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n24         break;\n25       case Token.BITXOR:\n26         result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n27         break;\n28       case Token.ADD:\n29         result = lval + rval;\n30         break;\n31       case Token.SUB:\n32         result = lval - rval;\n33         break;\n34       case Token.MUL:\n35         result = lval * rval;\n36         break;\n37       case Token.MOD:\n38         if (rval == 0) {\n39           error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n40           return null;\n41         }\n42         result = lval % rval;\n43         break;\n44       case Token.DIV:\n45         if (rval == 0) {\n46           error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n47           return null;\n48         }\n49         result = lval / rval;\n50         break;\n51       default:\n52         throw new Error(\"Unexpected arithmetic operator\");\n53     }\n54     if (String.valueOf(result).length() <=\n55         String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n56         Math.abs(result) <= MAX_FOLD_NUMBER) {\n57       Node newNumber = Node.newNumber(result);\n58       return newNumber;\n59     } else if (Double.isNaN(result)) {\n60       return Node.newString(Token.NAME, \"NaN\");\n61     } else if (result == Double.POSITIVE_INFINITY) {\n62       return Node.newString(Token.NAME, \"Infinity\");\n63     } else if (result == Double.NEGATIVE_INFINITY) {\n64       return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n65     }\n66     return null;\n67   }\n", "fixed_code": "  private Node performArithmeticOp(int opType, Node left, Node right) {\n    if (opType == Token.ADD\n        && (NodeUtil.mayBeString(left, false)\n            || NodeUtil.mayBeString(right, false))) {\n      return null;\n    }\n    double result;\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n      return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n      return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch (opType) {\n      case Token.BITAND:\n        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITOR:\n        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITXOR:\n        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n        break;\n      case Token.ADD:\n        result = lval + rval;\n        break;\n      case Token.SUB:\n        result = lval - rval;\n        break;\n      case Token.MUL:\n        result = lval * rval;\n        break;\n      case Token.MOD:\n        if (rval == 0) {\n          return null;\n        }\n        result = lval % rval;\n        break;\n      case Token.DIV:\n        if (rval == 0) {\n          return null;\n        }\n        result = lval / rval;\n        break;\n      default:\n        throw new Error(\"Unexpected arithmetic operator\");\n    }\n    if (String.valueOf(result).length() <=\n        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n        Math.abs(result) <= MAX_FOLD_NUMBER) {\n      Node newNumber = Node.newNumber(result);\n      return newNumber;\n    } else if (Double.isNaN(result)) {\n      return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n      return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n      return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n  }\n"}
{"bug_id": "JacksonDatabind-27", "buggy_code": "1     protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n2         throws IOException\n3     {\n4         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n5         final PropertyBasedCreator creator = _propertyBasedCreator;\n6         PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n7         TokenBuffer tokens = new TokenBuffer(p);\n8         tokens.writeStartObject();\n9         JsonToken t = p.getCurrentToken();\n10         for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n11             String propName = p.getCurrentName();\n12             p.nextToken(); \n13             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n14             if (creatorProp != null) {\n15                 if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n16                     ;\n17                 } else {\n18                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n19                         t = p.nextToken(); \n20                         Object bean;\n21                         try {\n22                             bean = creator.build(ctxt, buffer);\n23                         } catch (Exception e) {\n24                             wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n25                             continue; \n26                         }\n27                         while (t == JsonToken.FIELD_NAME) {\n28                             p.nextToken(); \n29                             tokens.copyCurrentStructure(p);\n30                             t = p.nextToken();\n31                         }\n32                         if (bean.getClass() != _beanType.getRawClass()) {\n33                             throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n34                         }\n35                         return ext.complete(p, ctxt, bean);\n36                     }\n37                 }\n38                 continue;\n39             }\n40             if (buffer.readIdProperty(propName)) {\n41                 continue;\n42             }\n43             SettableBeanProperty prop = _beanProperties.find(propName);\n44             if (prop != null) {\n45                 buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n46                 continue;\n47             }\n48             if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n49                 continue;\n50             }\n51             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n52                 handleIgnoredProperty(p, ctxt, handledType(), propName);\n53                 continue;\n54             }\n55             if (_anySetter != null) {\n56                 buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n57             }\n58         }\n59         try {\n60             return ext.complete(p, ctxt, buffer, creator);\n61         } catch (Exception e) {\n62             wrapInstantiationProblem(e, ctxt);\n63             return null; \n64         }\n65     }\n", "fixed_code": "    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); \n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                    ;\n                } else {\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); \n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; \n                        }\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); \n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n                            throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        }\n                        return ext.complete(p, ctxt, bean);\n                    }\n                }\n                continue;\n            }\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n        }\n        try {\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; \n        }\n    }\n"}
{"bug_id": "Math-31", "buggy_code": "1     public double evaluate(double x, double epsilon, int maxIterations) {\n2         final double small = 1e-50;\n3         double hPrev = getA(0, x);\n4         if (Precision.equals(hPrev, 0.0, small)) {\n5             hPrev = small;\n6         }\n7         int n = 1;\n8         double dPrev = 0.0;\n9         double p0 = 1.0;\n10         double q1 = 1.0;\n11         double cPrev = hPrev;\n12         double hN = hPrev;\n13         while (n < maxIterations) {\n14             final double a = getA(n, x);\n15             final double b = getB(n, x);\n16             double cN = a * hPrev + b * p0;\n17             double q2 = a * q1 + b * dPrev;\n18             if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n19                 double scaleFactor = 1d;\n20                 double lastScaleFactor = 1d;\n21                 final int maxPower = 5;\n22                 final double scale = FastMath.max(a,b);\n23                 if (scale <= 0) {  \n24                     throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n25                 }\n26                 for (int i = 0; i < maxPower; i++) {\n27                     lastScaleFactor = scaleFactor;\n28                     scaleFactor *= scale;\n29                     if (a != 0.0 && a > b) {\n30                         cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n31                         q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n32                     } else if (b != 0) {\n33                         cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n34                         q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n35                     }\n36                     if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n37                         break;\n38                     }\n39                 }\n40             }\n41             final double deltaN = cN / q2 / cPrev;\n42             hN = cPrev * deltaN;\n43             if (Double.isInfinite(hN)) {\n44                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n45                                                x);\n46             }\n47             if (Double.isNaN(hN)) {\n48                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n49                                                x);\n50             }\n51             if (FastMath.abs(deltaN - 1.0) < epsilon) {\n52                 break;\n53             }\n54             dPrev = q1;\n55             cPrev = cN / q2;\n56             p0 = hPrev;\n57             hPrev = cN;\n58             q1 = q2;\n59             n++;\n60         }\n61         if (n >= maxIterations) {\n62             throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n63                                                 maxIterations, x);\n64         }\n65         return hN;\n66     }\n", "fixed_code": "    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50;\n        double hPrev = getA(0, x);\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n        int n = 1;\n        double dPrev = 0.0;\n        double cPrev = hPrev;\n        double hN = hPrev;\n        while (n < maxIterations) {\n            final double a = getA(n, x);\n            final double b = getB(n, x);\n            double dN = a + b * dPrev;\n            if (Precision.equals(dN, 0.0, small)) {\n                dN = small;\n            }\n            double cN = a + b / cPrev;\n            if (Precision.equals(cN, 0.0, small)) {\n                cN = small;\n            }\n            dN = 1 / dN;\n            final double deltaN = cN * dN;\n            hN = hPrev * deltaN;\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                               x);\n            }\n            if (Double.isNaN(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                               x);\n            }\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n            dPrev = dN;\n            cPrev = cN;\n            hPrev = hN;\n            n++;\n        }\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n        return hN;\n    }\n"}
{"bug_id": "Chart-13", "buggy_code": "1     protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n2                                RectangleConstraint constraint) {\n3         double[] w = new double[5];\n4         double[] h = new double[5];\n5         w[0] = constraint.getWidth();\n6         if (this.topBlock != null) {\n7             RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n8                     LengthConstraintType.FIXED, 0.0,\n9                     new Range(0.0, constraint.getHeight()),\n10                     LengthConstraintType.RANGE);\n11             Size2D size = this.topBlock.arrange(g2, c1);\n12             h[0] = size.height;\n13         }\n14         w[1] = w[0];\n15         if (this.bottomBlock != null) {\n16             RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n17                     LengthConstraintType.FIXED, 0.0, new Range(0.0,\n18                     constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n19             Size2D size = this.bottomBlock.arrange(g2, c2);\n20             h[1] = size.height;\n21         }\n22         h[2] = constraint.getHeight() - h[1] - h[0];\n23         if (this.leftBlock != null) {\n24             RectangleConstraint c3 = new RectangleConstraint(0.0,\n25                     new Range(0.0, constraint.getWidth()),\n26                     LengthConstraintType.RANGE, h[2], null,\n27                     LengthConstraintType.FIXED);\n28             Size2D size = this.leftBlock.arrange(g2, c3);\n29             w[2] = size.width;\n30         }\n31         h[3] = h[2];\n32         if (this.rightBlock != null) {\n33             RectangleConstraint c4 = new RectangleConstraint(0.0,\n34                     new Range(0.0, constraint.getWidth() - w[2]),\n35                     LengthConstraintType.RANGE, h[2], null,\n36                     LengthConstraintType.FIXED);\n37             Size2D size = this.rightBlock.arrange(g2, c4);\n38             w[3] = size.width;\n39         }\n40         h[4] = h[2];\n41         w[4] = constraint.getWidth() - w[3] - w[2];\n42         RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n43         if (this.centerBlock != null) {\n44             this.centerBlock.arrange(g2, c5);\n45         }\n46         if (this.topBlock != null) {\n47             this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n48                     h[0]));\n49         }\n50         if (this.bottomBlock != null) {\n51             this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n52                     w[1], h[1]));\n53         }\n54         if (this.leftBlock != null) {\n55             this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n56                     h[2]));\n57         }\n58         if (this.rightBlock != null) {\n59             this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n60                     w[3], h[3]));\n61         }\n62         if (this.centerBlock != null) {\n63             this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n64                     h[4]));\n65         }\n66         return new Size2D(constraint.getWidth(), constraint.getHeight());\n67     }\n", "fixed_code": "    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }\n"}
{"bug_id": "Math-106", "buggy_code": "1     public Fraction parse(String source, ParsePosition pos) {\n2         Fraction ret = super.parse(source, pos);\n3         if (ret != null) {\n4             return ret;\n5         }\n6         int initialIndex = pos.getIndex();\n7         parseAndIgnoreWhitespace(source, pos);\n8         Number whole = getWholeFormat().parse(source, pos);\n9         if (whole == null) {\n10             pos.setIndex(initialIndex);\n11             return null;\n12         }\n13         parseAndIgnoreWhitespace(source, pos);\n14         Number num = getNumeratorFormat().parse(source, pos);\n15         if (num == null) {\n16             pos.setIndex(initialIndex);\n17             return null;\n18         }\n19         int startIndex = pos.getIndex();\n20         char c = parseNextCharacter(source, pos);\n21         switch (c) {\n22         case 0 :\n23             return new Fraction(num.intValue(), 1);\n24         case '/' :\n25             break;\n26         default :\n27             pos.setIndex(initialIndex);\n28             pos.setErrorIndex(startIndex);\n29             return null;\n30         }\n31         parseAndIgnoreWhitespace(source, pos);\n32         Number den = getDenominatorFormat().parse(source, pos);\n33         if (den == null) {\n34             pos.setIndex(initialIndex);\n35             return null;\n36         }\n37         int w = whole.intValue();\n38         int n = num.intValue();\n39         int d = den.intValue();\n40         return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n41     }\n", "fixed_code": "    public Fraction parse(String source, ParsePosition pos) {\n        Fraction ret = super.parse(source, pos);\n        if (ret != null) {\n            return ret;\n        }\n        int initialIndex = pos.getIndex();\n        parseAndIgnoreWhitespace(source, pos);\n        Number whole = getWholeFormat().parse(source, pos);\n        if (whole == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        parseAndIgnoreWhitespace(source, pos);\n        Number num = getNumeratorFormat().parse(source, pos);\n        if (num == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        if (num.intValue() < 0) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        switch (c) {\n        case 0 :\n            return new Fraction(num.intValue(), 1);\n        case '/' :\n            break;\n        default :\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        parseAndIgnoreWhitespace(source, pos);\n        Number den = getDenominatorFormat().parse(source, pos);\n        if (den == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        if (den.intValue() < 0) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int w = whole.intValue();\n        int n = num.intValue();\n        int d = den.intValue();\n        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n    }\n"}
{"bug_id": "Compress-41", "buggy_code": "1     public ZipArchiveEntry getNextZipEntry() throws IOException {\n2         boolean firstEntry = true;\n3         if (closed || hitCentralDirectory) {\n4             return null;\n5         }\n6         if (current != null) {\n7             closeEntry();\n8             firstEntry = false;\n9         }\n10         try {\n11             if (firstEntry) {\n12                 readFirstLocalFileHeader(LFH_BUF);\n13             } else {\n14                 readFully(LFH_BUF);\n15             }\n16         } catch (final EOFException e) {\n17             return null;\n18         }\n19         final ZipLong sig = new ZipLong(LFH_BUF);\n20         if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n21             hitCentralDirectory = true;\n22             skipRemainderOfArchive();\n23         }\n24         if (!sig.equals(ZipLong.LFH_SIG)) {\n25             return null;\n26         }\n27         int off = WORD;\n28         current = new CurrentEntry();\n29         final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n30         off += SHORT;\n31         current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n32         final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n33         final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n34         final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n35         current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n36         current.entry.setGeneralPurposeBit(gpFlag);\n37         off += SHORT;\n38         current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n39         off += SHORT;\n40         final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n41         current.entry.setTime(time);\n42         off += WORD;\n43         ZipLong size = null, cSize = null;\n44         if (!current.hasDataDescriptor) {\n45             current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n46             off += WORD;\n47             cSize = new ZipLong(LFH_BUF, off);\n48             off += WORD;\n49             size = new ZipLong(LFH_BUF, off);\n50             off += WORD;\n51         } else {\n52             off += 3 * WORD;\n53         }\n54         final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n55         off += SHORT;\n56         final int extraLen = ZipShort.getValue(LFH_BUF, off);\n57         off += SHORT;\n58         final byte[] fileName = new byte[fileNameLen];\n59         readFully(fileName);\n60         current.entry.setName(entryEncoding.decode(fileName), fileName);\n61         final byte[] extraData = new byte[extraLen];\n62         readFully(extraData);\n63         current.entry.setExtra(extraData);\n64         if (!hasUTF8Flag && useUnicodeExtraFields) {\n65             ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n66         }\n67         processZip64Extra(size, cSize);\n68         if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n69             if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n70                 current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n71             } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n72                 current.in = new ExplodingInputStream(\n73                         current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n74                         current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n75                         new BoundedInputStream(in, current.entry.getCompressedSize()));\n76             } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n77                 current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n78             }\n79         }\n80         entriesRead++;\n81         return current.entry;\n82     }\n", "fixed_code": "    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n        try {\n            if (firstEntry) {\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (final EOFException e) {\n            return null;\n        }\n        final ZipLong sig = new ZipLong(LFH_BUF);\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n            return null;\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            throw new ZipException(String.format(\"Unexpected record signature: 0X%X\", sig.getValue()));\n        }\n        int off = WORD;\n        current = new CurrentEntry();\n        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n        off += SHORT;\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD;\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD;\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        final int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n        processZip64Extra(size, cSize);\n        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n                current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            }\n        }\n        entriesRead++;\n        return current.entry;\n    }\n"}
{"bug_id": "Closure-59", "buggy_code": "1   public void initOptions(CompilerOptions options) {\n2     this.options = options;\n3     if (errorManager == null) {\n4       if (outStream == null) {\n5         setErrorManager(\n6             new LoggerErrorManager(createMessageFormatter(), logger));\n7       } else {\n8         PrintStreamErrorManager printer =\n9             new PrintStreamErrorManager(createMessageFormatter(), outStream);\n10         printer.setSummaryDetailLevel(options.summaryDetailLevel);\n11         setErrorManager(printer);\n12       }\n13     }\n14     if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n15       options.checkTypes = true;\n16     } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n17       options.checkTypes = false;\n18     } else if (!options.checkTypes) {\n19       options.setWarningLevel(\n20           DiagnosticGroup.forType(\n21               RhinoErrorReporter.TYPE_PARSE_ERROR),\n22           CheckLevel.OFF);\n23     }\n24     if (options.checkGlobalThisLevel.isOn()) {\n25       options.setWarningLevel(\n26           DiagnosticGroups.GLOBAL_THIS,\n27           options.checkGlobalThisLevel);\n28     }\n29     if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n30       options.setWarningLevel(\n31           DiagnosticGroups.ES5_STRICT,\n32           CheckLevel.ERROR);\n33     }\n34     List<WarningsGuard> guards = Lists.newArrayList();\n35     guards.add(\n36         new SuppressDocWarningsGuard(\n37             getDiagnosticGroups().getRegisteredGroups()));\n38     guards.add(options.getWarningsGuard());\n39     ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n40     if (!options.checkSymbols &&\n41         !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n42       composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n43           DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n44     }\n45     this.warningsGuard = composedGuards;\n46   }\n", "fixed_code": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n    this.warningsGuard = composedGuards;\n  }\n"}
{"bug_id": "Lang-3", "buggy_code": "1     public static Number createNumber(final String str) throws NumberFormatException {\n2         if (str == null) {\n3             return null;\n4         }\n5         if (StringUtils.isBlank(str)) {\n6             throw new NumberFormatException(\"A blank string is not a valid number\");\n7         }\n8         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n9         int pfxLen = 0;\n10         for(final String pfx : hex_prefixes) {\n11             if (str.startsWith(pfx)) {\n12                 pfxLen += pfx.length();\n13                 break;\n14             }\n15         }\n16         if (pfxLen > 0) { \n17             final int hexDigits = str.length() - pfxLen;\n18             if (hexDigits > 16) { \n19                 return createBigInteger(str);\n20             }\n21             if (hexDigits > 8) { \n22                 return createLong(str);\n23             }\n24             return createInteger(str);\n25         }\n26         final char lastChar = str.charAt(str.length() - 1);\n27         String mant;\n28         String dec;\n29         String exp;\n30         final int decPos = str.indexOf('.');\n31         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; \n32         int numDecimals = 0; \n33         if (decPos > -1) { \n34             if (expPos > -1) { \n35                 if (expPos < decPos || expPos > str.length()) { \n36                     throw new NumberFormatException(str + \" is not a valid number.\");\n37                 }\n38                 dec = str.substring(decPos + 1, expPos);\n39             } else {\n40                 dec = str.substring(decPos + 1);\n41             }\n42             mant = str.substring(0, decPos);\n43             numDecimals = dec.length(); \n44         } else {\n45             if (expPos > -1) {\n46                 if (expPos > str.length()) { \n47                     throw new NumberFormatException(str + \" is not a valid number.\");\n48                 }\n49                 mant = str.substring(0, expPos);\n50             } else {\n51                 mant = str;\n52             }\n53             dec = null;\n54         }\n55         if (!Character.isDigit(lastChar) && lastChar != '.') {\n56             if (expPos > -1 && expPos < str.length() - 1) {\n57                 exp = str.substring(expPos + 1, str.length() - 1);\n58             } else {\n59                 exp = null;\n60             }\n61             final String numeric = str.substring(0, str.length() - 1);\n62             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n63             switch (lastChar) {\n64                 case 'l' :\n65                 case 'L' :\n66                     if (dec == null\n67                         && exp == null\n68                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n69                         try {\n70                             return createLong(numeric);\n71                         } catch (final NumberFormatException nfe) { \n72                         }\n73                         return createBigInteger(numeric);\n74                     }\n75                     throw new NumberFormatException(str + \" is not a valid number.\");\n76                 case 'f' :\n77                 case 'F' :\n78                     try {\n79                         final Float f = NumberUtils.createFloat(numeric);\n80                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n81                             return f;\n82                         }\n83                     } catch (final NumberFormatException nfe) { \n84                     }\n85                 case 'd' :\n86                 case 'D' :\n87                     try {\n88                         final Double d = NumberUtils.createDouble(numeric);\n89                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n90                             return d;\n91                         }\n92                     } catch (final NumberFormatException nfe) { \n93                     }\n94                     try {\n95                         return createBigDecimal(numeric);\n96                     } catch (final NumberFormatException e) { \n97                     }\n98                 default :\n99                     throw new NumberFormatException(str + \" is not a valid number.\");\n100             }\n101         }\n102         if (expPos > -1 && expPos < str.length() - 1) {\n103             exp = str.substring(expPos + 1, str.length());\n104         } else {\n105             exp = null;\n106         }\n107         if (dec == null && exp == null) { \n108             try {\n109                 return createInteger(str);\n110             } catch (final NumberFormatException nfe) { \n111             }\n112             try {\n113                 return createLong(str);\n114             } catch (final NumberFormatException nfe) { \n115             }\n116             return createBigInteger(str);\n117         }\n118         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n119         try {\n120                 final Float f = createFloat(str);\n121                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n122                     return f;\n123                 }\n124         } catch (final NumberFormatException nfe) { \n125         }\n126         try {\n127                 final Double d = createDouble(str);\n128                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n129                     return d;\n130                 }\n131         } catch (final NumberFormatException nfe) { \n132         }\n133         return createBigDecimal(str);\n134     }\n", "fixed_code": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen += pfx.length();\n                break;\n            }\n        }\n        if (pfxLen > 0) { \n            final int hexDigits = str.length() - pfxLen;\n            if (hexDigits > 16) { \n                return createBigInteger(str);\n            }\n            if (hexDigits > 8) { \n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; \n        int numDecimals = 0; \n        if (decPos > -1) { \n            if (expPos > -1) { \n                if (expPos < decPos || expPos > str.length()) { \n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n            numDecimals = dec.length(); \n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) { \n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            final String numeric = str.substring(0, str.length() - 1);\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { \n                        }\n                        return createBigInteger(numeric);\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (final NumberFormatException nfe) { \n                    }\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { \n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { \n                    }\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        }\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { \n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { \n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { \n            }\n            return createBigInteger(str);\n        }\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        try {\n            if(numDecimals <= 7){\n                final Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            }\n        } catch (final NumberFormatException nfe) { \n        }\n        try {\n            if(numDecimals <= 16){\n                final Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            }\n        } catch (final NumberFormatException nfe) { \n        }\n        return createBigDecimal(str);\n    }\n"}
{"bug_id": "Closure-152", "buggy_code": "1   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n2     setResolvedTypeInternal(this);\n3     call = (ArrowType) safeResolve(call, t, scope);\n4     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n5     typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n6     boolean changed = false;\n7     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n8         ImmutableList.builder();\n9     for (ObjectType iface : implementedInterfaces) {\n10       ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n11       resolvedInterfaces.add(resolvedIface);\n12       changed |= (resolvedIface != iface);\n13     }\n14     if (changed) {\n15       implementedInterfaces = resolvedInterfaces.build();\n16     }\n17     if (subTypes != null) {\n18       for (int i = 0; i < subTypes.size(); i++) {\n19         subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n20       }\n21     }\n22     return super.resolveInternal(t, scope);\n23   }\n", "fixed_code": "  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n    return super.resolveInternal(t, scope);\n  }\n"}
{"bug_id": "JacksonDatabind-58", "buggy_code": "1     protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n2             BeanDescription beanDesc, BeanPropertyDefinition propDef,\n3             JavaType propType0)\n4         throws JsonMappingException\n5     {\n6         AnnotatedMember mutator = propDef.getNonConstructorMutator();\n7         if (ctxt.canOverrideAccessModifiers()) {\n8                 mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n9         }\n10         BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n11                 propType0, propDef.getWrapperName(),\n12                 beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n13         JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n14         if (type != propType0) {\n15             property = property.withType(type);\n16         }\n17         JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n18         type = modifyTypeByAnnotation(ctxt, mutator, type);\n19         TypeDeserializer typeDeser = type.getTypeHandler();\n20         SettableBeanProperty prop;\n21         if (mutator instanceof AnnotatedMethod) {\n22             prop = new MethodProperty(propDef, type, typeDeser,\n23                     beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n24         } else {\n25             prop = new FieldProperty(propDef, type, typeDeser,\n26                     beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n27         }\n28         if (propDeser != null) {\n29             prop = prop.withValueDeserializer(propDeser);\n30         }\n31         AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n32         if (ref != null && ref.isManagedReference()) {\n33             prop.setManagedReferenceName(ref.getName());\n34         }\n35         ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n36         if(objectIdInfo != null){\n37             prop.setObjectIdInfo(objectIdInfo);\n38         }\n39         return prop;\n40     }\n", "fixed_code": "    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n        if (ctxt.canOverrideAccessModifiers()) {\n            if ((mutator instanceof AnnotatedField)\n                    && \"cause\".equals(mutator.getName())) {\n                ;\n            } else {\n                mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                propType0, propDef.getWrapperName(),\n                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n        if (type != propType0) {\n            property = property.withType(type);\n        }\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n        type = modifyTypeByAnnotation(ctxt, mutator, type);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if(objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n"}
{"bug_id": "Math-3", "buggy_code": "1     public static double linearCombination(final double[] a, final double[] b)\n2         throws DimensionMismatchException {\n3         final int len = a.length;\n4         if (len != b.length) {\n5             throw new DimensionMismatchException(len, b.length);\n6         }\n7         final double[] prodHigh = new double[len];\n8         double prodLowSum = 0;\n9         for (int i = 0; i < len; i++) {\n10             final double ai = a[i];\n11             final double ca = SPLIT_FACTOR * ai;\n12             final double aHigh = ca - (ca - ai);\n13             final double aLow = ai - aHigh;\n14             final double bi = b[i];\n15             final double cb = SPLIT_FACTOR * bi;\n16             final double bHigh = cb - (cb - bi);\n17             final double bLow = bi - bHigh;\n18             prodHigh[i] = ai * bi;\n19             final double prodLow = aLow * bLow - (((prodHigh[i] -\n20                                                     aHigh * bHigh) -\n21                                                    aLow * bHigh) -\n22                                                   aHigh * bLow);\n23             prodLowSum += prodLow;\n24         }\n25         final double prodHighCur = prodHigh[0];\n26         double prodHighNext = prodHigh[1];\n27         double sHighPrev = prodHighCur + prodHighNext;\n28         double sPrime = sHighPrev - prodHighNext;\n29         double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n30         final int lenMinusOne = len - 1;\n31         for (int i = 1; i < lenMinusOne; i++) {\n32             prodHighNext = prodHigh[i + 1];\n33             final double sHighCur = sHighPrev + prodHighNext;\n34             sPrime = sHighCur - prodHighNext;\n35             sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n36             sHighPrev = sHighCur;\n37         }\n38         double result = sHighPrev + (prodLowSum + sLowSum);\n39         if (Double.isNaN(result)) {\n40             result = 0;\n41             for (int i = 0; i < len; ++i) {\n42                 result += a[i] * b[i];\n43             }\n44         }\n45         return result;\n46     }\n", "fixed_code": "    public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n        if (len == 1) {\n            return a[0] * b[0];\n        }\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n        final double prodHighCur = prodHigh[0];\n        double prodHighNext = prodHigh[1];\n        double sHighPrev = prodHighCur + prodHighNext;\n        double sPrime = sHighPrev - prodHighNext;\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            prodHighNext = prodHigh[i + 1];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur;\n        }\n        double result = sHighPrev + (prodLowSum + sLowSum);\n        if (Double.isNaN(result)) {\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n        return result;\n    }\n"}
{"bug_id": "JacksonCore-3", "buggy_code": "1     public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n2             ObjectCodec codec, BytesToNameCanonicalizer sym,\n3             byte[] inputBuffer, int start, int end,\n4             boolean bufferRecyclable)\n5     {\n6         super(ctxt, features);\n7         _inputStream = in;\n8         _objectCodec = codec;\n9         _symbols = sym;\n10         _inputBuffer = inputBuffer;\n11         _inputPtr = start;\n12         _inputEnd = end;\n13         _bufferRecyclable = bufferRecyclable;\n14     }\n", "fixed_code": "    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, BytesToNameCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _currInputRowStart = start;\n        _currInputProcessed = -start;\n        _bufferRecyclable = bufferRecyclable;\n    }\n"}
{"bug_id": "Lang-39", "buggy_code": "1     private static String replaceEach(String text, String[] searchList, String[] replacementList, \n2                                       boolean repeat, int timeToLive) \n3     {\n4         if (text == null || text.length() == 0 || searchList == null || \n5             searchList.length == 0 || replacementList == null || replacementList.length == 0) \n6         {\n7             return text;\n8         }\n9         if (timeToLive < 0) {\n10             throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n11         }\n12         int searchLength = searchList.length;\n13         int replacementLength = replacementList.length;\n14         if (searchLength != replacementLength) {\n15             throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n16                 + searchLength\n17                 + \" vs \"\n18                 + replacementLength);\n19         }\n20         boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n21         int textIndex = -1;\n22         int replaceIndex = -1;\n23         int tempIndex = -1;\n24         for (int i = 0; i < searchLength; i++) {\n25             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n26                 searchList[i].length() == 0 || replacementList[i] == null) \n27             {\n28                 continue;\n29             }\n30             tempIndex = text.indexOf(searchList[i]);\n31             if (tempIndex == -1) {\n32                 noMoreMatchesForReplIndex[i] = true;\n33             } else {\n34                 if (textIndex == -1 || tempIndex < textIndex) {\n35                     textIndex = tempIndex;\n36                     replaceIndex = i;\n37                 }\n38             }\n39         }\n40         if (textIndex == -1) {\n41             return text;\n42         }\n43         int start = 0;\n44         int increase = 0;\n45         for (int i = 0; i < searchList.length; i++) {\n46             int greater = replacementList[i].length() - searchList[i].length();\n47             if (greater > 0) {\n48                 increase += 3 * greater; \n49             }\n50         }\n51         increase = Math.min(increase, text.length() / 5);\n52         StringBuilder buf = new StringBuilder(text.length() + increase);\n53         while (textIndex != -1) {\n54             for (int i = start; i < textIndex; i++) {\n55                 buf.append(text.charAt(i));\n56             }\n57             buf.append(replacementList[replaceIndex]);\n58             start = textIndex + searchList[replaceIndex].length();\n59             textIndex = -1;\n60             replaceIndex = -1;\n61             tempIndex = -1;\n62             for (int i = 0; i < searchLength; i++) {\n63                 if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n64                     searchList[i].length() == 0 || replacementList[i] == null) \n65                 {\n66                     continue;\n67                 }\n68                 tempIndex = text.indexOf(searchList[i], start);\n69                 if (tempIndex == -1) {\n70                     noMoreMatchesForReplIndex[i] = true;\n71                 } else {\n72                     if (textIndex == -1 || tempIndex < textIndex) {\n73                         textIndex = tempIndex;\n74                         replaceIndex = i;\n75                     }\n76                 }\n77             }\n78         }\n79         int textLength = text.length();\n80         for (int i = start; i < textLength; i++) {\n81             buf.append(text.charAt(i));\n82         }\n83         String result = buf.toString();\n84         if (!repeat) {\n85             return result;\n86         }\n87         return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n88     }\n", "fixed_code": "    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        if (textIndex == -1) {\n            return text;\n        }\n        int start = 0;\n        int increase = 0;\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n        while (textIndex != -1) {\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n            start = textIndex + searchList[replaceIndex].length();\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n"}
{"bug_id": "Compress-13", "buggy_code": "1     protected void setName(String name) {\n2         this.name = name;\n3     }\n", "fixed_code": "    protected void setName(String name) {\n        if (name != null && getPlatform() == PLATFORM_FAT\n            && name.indexOf(\"/\") == -1) {\n            name = name.replace('\\\\', '/');\n        }\n        this.name = name;\n    }\n"}
{"bug_id": "Gson-13", "buggy_code": "1   private int peekNumber() throws IOException {\n2     char[] buffer = this.buffer;\n3     int p = pos;\n4     int l = limit;\n5     long value = 0; \n6     boolean negative = false;\n7     boolean fitsInLong = true;\n8     int last = NUMBER_CHAR_NONE;\n9     int i = 0;\n10     charactersOfNumber:\n11     for (; true; i++) {\n12       if (p + i == l) {\n13         if (i == buffer.length) {\n14           return PEEKED_NONE;\n15         }\n16         if (!fillBuffer(i + 1)) {\n17           break;\n18         }\n19         p = pos;\n20         l = limit;\n21       }\n22       char c = buffer[p + i];\n23       switch (c) {\n24       case '-':\n25         if (last == NUMBER_CHAR_NONE) {\n26           negative = true;\n27           last = NUMBER_CHAR_SIGN;\n28           continue;\n29         } else if (last == NUMBER_CHAR_EXP_E) {\n30           last = NUMBER_CHAR_EXP_SIGN;\n31           continue;\n32         }\n33         return PEEKED_NONE;\n34       case '+':\n35         if (last == NUMBER_CHAR_EXP_E) {\n36           last = NUMBER_CHAR_EXP_SIGN;\n37           continue;\n38         }\n39         return PEEKED_NONE;\n40       case 'e':\n41       case 'E':\n42         if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n43           last = NUMBER_CHAR_EXP_E;\n44           continue;\n45         }\n46         return PEEKED_NONE;\n47       case '.':\n48         if (last == NUMBER_CHAR_DIGIT) {\n49           last = NUMBER_CHAR_DECIMAL;\n50           continue;\n51         }\n52         return PEEKED_NONE;\n53       default:\n54         if (c < '0' || c > '9') {\n55           if (!isLiteral(c)) {\n56             break charactersOfNumber;\n57           }\n58           return PEEKED_NONE;\n59         }\n60         if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n61           value = -(c - '0');\n62           last = NUMBER_CHAR_DIGIT;\n63         } else if (last == NUMBER_CHAR_DIGIT) {\n64           if (value == 0) {\n65             return PEEKED_NONE; \n66           }\n67           long newValue = value * 10 - (c - '0');\n68           fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n69               || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n70           value = newValue;\n71         } else if (last == NUMBER_CHAR_DECIMAL) {\n72           last = NUMBER_CHAR_FRACTION_DIGIT;\n73         } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n74           last = NUMBER_CHAR_EXP_DIGIT;\n75         }\n76       }\n77     }\n78     if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n79       peekedLong = negative ? value : -value;\n80       pos += i;\n81       return peeked = PEEKED_LONG;\n82     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n83         || last == NUMBER_CHAR_EXP_DIGIT) {\n84       peekedNumberLength = i;\n85       return peeked = PEEKED_NUMBER;\n86     } else {\n87       return PEEKED_NONE;\n88     }\n89   }\n", "fixed_code": "  private int peekNumber() throws IOException {\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    long value = 0; \n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; \n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n"}
{"bug_id": "JacksonDatabind-112", "buggy_code": "1     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n2             BeanProperty property) throws JsonMappingException\n3     {\n4         JsonDeserializer<Object> delegate = null;\n5         if (_valueInstantiator != null) {\n6             AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n7             if (delegateCreator != null) {\n8                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n9                 delegate = findDeserializer(ctxt, delegateType, property);\n10             }\n11         }\n12         JsonDeserializer<?> valueDeser = _valueDeserializer;\n13         final JavaType valueType = _containerType.getContentType();\n14         if (valueDeser == null) {\n15             valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n16             if (valueDeser == null) {\n17                 valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n18             }\n19         } else { \n20             valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n21         }\n22         Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n23                 JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n24         NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n25         if (isDefaultDeserializer(valueDeser)) {\n26             valueDeser = null;\n27         }\n28         return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n29     }\n", "fixed_code": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        JsonDeserializer<Object> delegate = null;\n        if (_valueInstantiator != null) {\n            AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator();\n            if (delegateCreator != null) {\n                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n                delegate = findDeserializer(ctxt, delegateType, property);\n            } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                delegate = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        final JavaType valueType = _containerType.getContentType();\n        if (valueDeser == null) {\n            valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n            if (valueDeser == null) {\n                valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n            }\n        } else { \n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n        }\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n        if (isDefaultDeserializer(valueDeser)) {\n            valueDeser = null;\n        }\n        return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n    }\n"}
{"bug_id": "Closure-65", "buggy_code": "1   static String strEscape(String s, char quote,\n2                           String doublequoteEscape,\n3                           String singlequoteEscape,\n4                           String backslashEscape,\n5                           CharsetEncoder outputCharsetEncoder) {\n6     StringBuilder sb = new StringBuilder(s.length() + 2);\n7     sb.append(quote);\n8     for (int i = 0; i < s.length(); i++) {\n9       char c = s.charAt(i);\n10       switch (c) {\n11         case '\\0': sb.append(\"\\\\0\"); break;\n12         case '\\n': sb.append(\"\\\\n\"); break;\n13         case '\\r': sb.append(\"\\\\r\"); break;\n14         case '\\t': sb.append(\"\\\\t\"); break;\n15         case '\\\\': sb.append(backslashEscape); break;\n16         case '\\\"': sb.append(doublequoteEscape); break;\n17         case '\\'': sb.append(singlequoteEscape); break;\n18         case '>':                       \n19           if (i >= 2 &&\n20               ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n21                (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n22             sb.append(\"\\\\>\");\n23           } else {\n24             sb.append(c);\n25           }\n26           break;\n27         case '<':\n28           final String END_SCRIPT = \"/script\";\n29           final String START_COMMENT = \"!--\";\n30           if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n31                               END_SCRIPT.length())) {\n32             sb.append(\"<\\\\\");\n33           } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n34                                      START_COMMENT.length())) {\n35             sb.append(\"<\\\\\");\n36           } else {\n37             sb.append(c);\n38           }\n39           break;\n40         default:\n41           if (outputCharsetEncoder != null) {\n42             if (outputCharsetEncoder.canEncode(c)) {\n43               sb.append(c);\n44             } else {\n45               appendHexJavaScriptRepresentation(sb, c);\n46             }\n47           } else {\n48             if (c > 0x1f && c < 0x7f) {\n49               sb.append(c);\n50             } else {\n51               appendHexJavaScriptRepresentation(sb, c);\n52             }\n53           }\n54       }\n55     }\n56     sb.append(quote);\n57     return sb.toString();\n58   }\n", "fixed_code": "  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\000\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       \n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          final String END_SCRIPT = \"/script\";\n          final String START_COMMENT = \"!--\";\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            if (c > 0x1f && c < 0x7f) {\n              sb.append(c);\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n"}
{"bug_id": "Math-26", "buggy_code": "1     private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n2         throws FractionConversionException\n3     {\n4         long overflow = Integer.MAX_VALUE;\n5         double r0 = value;\n6         long a0 = (long)FastMath.floor(r0);\n7         if (a0 > overflow) {\n8             throw new FractionConversionException(value, a0, 1l);\n9         }\n10         if (FastMath.abs(a0 - value) < epsilon) {\n11             this.numerator = (int) a0;\n12             this.denominator = 1;\n13             return;\n14         }\n15         long p0 = 1;\n16         long q0 = 0;\n17         long p1 = a0;\n18         long q1 = 1;\n19         long p2 = 0;\n20         long q2 = 1;\n21         int n = 0;\n22         boolean stop = false;\n23         do {\n24             ++n;\n25             double r1 = 1.0 / (r0 - a0);\n26             long a1 = (long)FastMath.floor(r1);\n27             p2 = (a1 * p1) + p0;\n28             q2 = (a1 * q1) + q0;\n29             if ((p2 > overflow) || (q2 > overflow)) {\n30                 throw new FractionConversionException(value, p2, q2);\n31             }\n32             double convergent = (double)p2 / (double)q2;\n33             if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n34                 p0 = p1;\n35                 p1 = p2;\n36                 q0 = q1;\n37                 q1 = q2;\n38                 a0 = a1;\n39                 r0 = r1;\n40             } else {\n41                 stop = true;\n42             }\n43         } while (!stop);\n44         if (n >= maxIterations) {\n45             throw new FractionConversionException(value, maxIterations);\n46         }\n47         if (q2 < maxDenominator) {\n48             this.numerator = (int) p2;\n49             this.denominator = (int) q2;\n50         } else {\n51             this.numerator = (int) p1;\n52             this.denominator = (int) q1;\n53         }\n54     }\n", "fixed_code": "    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n        long p2 = 0;\n        long q2 = 1;\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n    }\n"}
{"bug_id": "Jsoup-77", "buggy_code": "1     private void popStackToClose(Token.EndTag endTag) {\n2         String elName = endTag.name();\n3         Element firstFound = null;\n4         for (int pos = stack.size() -1; pos >= 0; pos--) {\n5             Element next = stack.get(pos);\n6             if (next.nodeName().equals(elName)) {\n7                 firstFound = next;\n8                 break;\n9             }\n10         }\n11         if (firstFound == null)\n12             return; \n13         for (int pos = stack.size() -1; pos >= 0; pos--) {\n14             Element next = stack.get(pos);\n15             stack.remove(pos);\n16             if (next == firstFound)\n17                 break;\n18         }\n19     }\n", "fixed_code": "    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.normalName();\n        Element firstFound = null;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; \n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n"}
{"bug_id": "Jsoup-26", "buggy_code": "1     public Document clean(Document dirtyDocument) {\n2         Validate.notNull(dirtyDocument);\n3         Document clean = Document.createShell(dirtyDocument.baseUri());\n4             copySafeNodes(dirtyDocument.body(), clean.body());\n5         return clean;\n6     }\n", "fixed_code": "    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        if (dirtyDocument.body() != null) \n            copySafeNodes(dirtyDocument.body(), clean.body());\n        return clean;\n    }\n"}
{"bug_id": "JxPath-8", "buggy_code": "1     private boolean compute(Object left, Object right) {\n2         left = reduce(left);\n3         right = reduce(right);\n4         if (left instanceof InitialContext) {\n5             ((InitialContext) left).reset();\n6         }\n7         if (right instanceof InitialContext) {\n8             ((InitialContext) right).reset();\n9         }\n10         if (left instanceof Iterator && right instanceof Iterator) {\n11             return findMatch((Iterator) left, (Iterator) right);\n12         }\n13         if (left instanceof Iterator) {\n14             return containsMatch((Iterator) left, right);\n15         }\n16         if (right instanceof Iterator) {\n17             return containsMatch((Iterator) right, left);\n18         }\n19         double ld = InfoSetUtil.doubleValue(left);\n20         double rd = InfoSetUtil.doubleValue(right);\n21         return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n22     }\n", "fixed_code": "    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        if (Double.isNaN(ld)) {\n            return false;\n        }\n        double rd = InfoSetUtil.doubleValue(right);\n        if (Double.isNaN(rd)) {\n            return false;\n        }\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }\n"}
{"bug_id": "Math-30", "buggy_code": "1     private double calculateAsymptoticPValue(final double Umin,\n2                                              final int n1,\n3                                              final int n2)\n4         throws ConvergenceException, MaxCountExceededException {\n5         final int n1n2prod = n1 * n2;\n6         final double EU = n1n2prod / 2.0;\n7         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n8         final double z = (Umin - EU) / FastMath.sqrt(VarU);\n9         final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n10         return 2 * standardNormal.cumulativeProbability(z);\n11     }\n", "fixed_code": "    private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n        final double n1n2prod = n1 * n2;\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n        return 2 * standardNormal.cumulativeProbability(z);\n    }\n"}
{"bug_id": "JacksonDatabind-99", "buggy_code": "1     protected String buildCanonicalName()\n2     {\n3         StringBuilder sb = new StringBuilder();\n4         sb.append(_class.getName());\n5         sb.append('<');\n6         sb.append(_referencedType.toCanonical());\n7         return sb.toString();\n8     }\n", "fixed_code": "    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n        sb.append('>');\n        return sb.toString();\n    }\n"}
{"bug_id": "Math-40", "buggy_code": "1     protected double doSolve() {\n2         final double[] x = new double[maximalOrder + 1];\n3         final double[] y = new double[maximalOrder + 1];\n4         x[0] = getMin();\n5         x[1] = getStartValue();\n6         x[2] = getMax();\n7         verifySequence(x[0], x[1], x[2]);\n8         y[1] = computeObjectiveValue(x[1]);\n9         if (Precision.equals(y[1], 0.0, 1)) {\n10             return x[1];\n11         }\n12         y[0] = computeObjectiveValue(x[0]);\n13         if (Precision.equals(y[0], 0.0, 1)) {\n14             return x[0];\n15         }\n16         int nbPoints;\n17         int signChangeIndex;\n18         if (y[0] * y[1] < 0) {\n19             nbPoints        = 2;\n20             signChangeIndex = 1;\n21         } else {\n22             y[2] = computeObjectiveValue(x[2]);\n23             if (Precision.equals(y[2], 0.0, 1)) {\n24                 return x[2];\n25             }\n26             if (y[1] * y[2] < 0) {\n27                 nbPoints        = 3;\n28                 signChangeIndex = 2;\n29             } else {\n30                 throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n31             }\n32         }\n33         final double[] tmpX = new double[x.length];\n34         double xA    = x[signChangeIndex - 1];\n35         double yA    = y[signChangeIndex - 1];\n36         double absYA = FastMath.abs(yA);\n37         int agingA   = 0;\n38         double xB    = x[signChangeIndex];\n39         double yB    = y[signChangeIndex];\n40         double absYB = FastMath.abs(yB);\n41         int agingB   = 0;\n42         while (true) {\n43             final double xTol = getAbsoluteAccuracy() +\n44                                 getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n45             if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n46                 switch (allowed) {\n47                 case ANY_SIDE :\n48                     return absYA < absYB ? xA : xB;\n49                 case LEFT_SIDE :\n50                     return xA;\n51                 case RIGHT_SIDE :\n52                     return xB;\n53                 case BELOW_SIDE :\n54                     return (yA <= 0) ? xA : xB;\n55                 case ABOVE_SIDE :\n56                     return (yA <  0) ? xB : xA;\n57                 default :\n58                     throw new MathInternalError(null);\n59                 }\n60             }\n61             double targetY;\n62             if (agingA >= MAXIMAL_AGING) {\n63                 targetY = -REDUCTION_FACTOR * yB;\n64             } else if (agingB >= MAXIMAL_AGING) {\n65                 targetY = -REDUCTION_FACTOR * yA;\n66             } else {\n67                 targetY = 0;\n68             }\n69             double nextX;\n70             int start = 0;\n71             int end   = nbPoints;\n72             do {\n73                 System.arraycopy(x, start, tmpX, start, end - start);\n74                 nextX = guessX(targetY, tmpX, y, start, end);\n75                 if (!((nextX > xA) && (nextX < xB))) {\n76                     if (signChangeIndex - start >= end - signChangeIndex) {\n77                         ++start;\n78                     } else {\n79                         --end;\n80                     }\n81                     nextX = Double.NaN;\n82                 }\n83             } while (Double.isNaN(nextX) && (end - start > 1));\n84             if (Double.isNaN(nextX)) {\n85                 nextX = xA + 0.5 * (xB - xA);\n86                 start = signChangeIndex - 1;\n87                 end   = signChangeIndex;\n88             }\n89             final double nextY = computeObjectiveValue(nextX);\n90             if (Precision.equals(nextY, 0.0, 1)) {\n91                 return nextX;\n92             }\n93             if ((nbPoints > 2) && (end - start != nbPoints)) {\n94                 nbPoints = end - start;\n95                 System.arraycopy(x, start, x, 0, nbPoints);\n96                 System.arraycopy(y, start, y, 0, nbPoints);\n97                 signChangeIndex -= start;\n98             } else  if (nbPoints == x.length) {\n99                 nbPoints--;\n100                 if (signChangeIndex >= (x.length + 1) / 2) {\n101                     System.arraycopy(x, 1, x, 0, nbPoints);\n102                     System.arraycopy(y, 1, y, 0, nbPoints);\n103                     --signChangeIndex;\n104                 }\n105             }\n106             System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n107             x[signChangeIndex] = nextX;\n108             System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n109             y[signChangeIndex] = nextY;\n110             ++nbPoints;\n111             if (nextY * yA <= 0) {\n112                 xB = nextX;\n113                 yB = nextY;\n114                 absYB = FastMath.abs(yB);\n115                 ++agingA;\n116                 agingB = 0;\n117             } else {\n118                 xA = nextX;\n119                 yA = nextY;\n120                 absYA = FastMath.abs(yA);\n121                 agingA = 0;\n122                 ++agingB;\n123                 signChangeIndex++;\n124             }\n125         }\n126     }\n", "fixed_code": "    protected double doSolve() {\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            return x[1];\n        }\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            return x[0];\n        }\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n            nbPoints        = 2;\n            signChangeIndex = 1;\n        } else {\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                return x[2];\n            }\n            if (y[1] * y[2] < 0) {\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n        }\n        final double[] tmpX = new double[x.length];\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n        while (true) {\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    throw new MathInternalError(null);\n                }\n            }\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                final int p = agingA - MAXIMAL_AGING;\n                final double weightA = (1 << p) - 1;\n                final double weightB = p + 1;\n                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n            } else if (agingB >= MAXIMAL_AGING) {\n                final int p = agingB - MAXIMAL_AGING;\n                final double weightA = p + 1;\n                final double weightB = (1 << p) - 1;\n                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n            } else {\n                targetY = 0;\n            }\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n                if (!((nextX > xA) && (nextX < xB))) {\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        ++start;\n                    } else {\n                        --end;\n                    }\n                    nextX = Double.NaN;\n                }\n            } while (Double.isNaN(nextX) && (end - start > 1));\n            if (Double.isNaN(nextX)) {\n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                return nextX;\n            }\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n            } else  if (nbPoints == x.length) {\n                nbPoints--;\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n            }\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n            if (nextY * yA <= 0) {\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n                signChangeIndex++;\n            }\n        }\n    }\n"}
{"bug_id": "Jsoup-37", "buggy_code": "1     public String html() {\n2         StringBuilder accum = new StringBuilder();\n3         html(accum);\n4         return accum.toString().trim();\n5     }\n", "fixed_code": "    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }\n"}
{"bug_id": "Cli-15", "buggy_code": "1     public List getValues(final Option option,\n2                           List defaultValues) {\n3         List valueList = (List) values.get(option);\n4         if ((valueList == null) || valueList.isEmpty()) {\n5             valueList = defaultValues;\n6         }\n7         if ((valueList == null) || valueList.isEmpty()) {\n8             valueList = (List) this.defaultValues.get(option);\n9         }\n10         return valueList == null ? Collections.EMPTY_LIST : valueList;\n11     }\n", "fixed_code": "    public List getValues(final Option option,\n                          List defaultValues) {\n        List valueList = (List) values.get(option);\n        if (defaultValues == null || defaultValues.isEmpty()) {\n            defaultValues = (List) this.defaultValues.get(option);\n        }\n        if (defaultValues != null && !defaultValues.isEmpty()) {\n            if (valueList == null || valueList.isEmpty()) {\n                valueList = defaultValues;\n            } else {\n                if (defaultValues.size() > valueList.size()) {\n                    valueList = new ArrayList(valueList);\n                    for (int i=valueList.size(); i<defaultValues.size(); i++) {\n                        valueList.add(defaultValues.get(i));\n                    }\n                }\n            }\n        }\n        return valueList == null ? Collections.EMPTY_LIST : valueList;\n    }\n"}
{"bug_id": "Cli-8", "buggy_code": "1     protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n2                                              int nextLineTabStop, String text)\n3     {\n4         int pos = findWrapPos(text, width, 0);\n5         if (pos == -1)\n6         {\n7             sb.append(rtrim(text));\n8             return sb;\n9         }\n10         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n11         final String padding = createPadding(nextLineTabStop);\n12         while (true)\n13         {\n14             text = padding + text.substring(pos).trim();\n15             pos = findWrapPos(text, width, nextLineTabStop);\n16             if (pos == -1)\n17             {\n18                 sb.append(text);\n19                 return sb;\n20             }\n21             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n22         }\n23     }\n", "fixed_code": "    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        final String padding = createPadding(nextLineTabStop);\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n            if (pos == -1)\n            {\n                sb.append(text);\n                return sb;\n            }\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n"}
{"bug_id": "Closure-146", "buggy_code": "1   public TypePair getTypesUnderInequality(JSType that) {\n2     if (that instanceof UnionType) {\n3       TypePair p = that.getTypesUnderInequality(this);\n4       return new TypePair(p.typeB, p.typeA);\n5     }\n6     switch (this.testForEquality(that)) {\n7       case TRUE:\n8         return new TypePair(null, null);\n9       case FALSE:\n10       case UNKNOWN:\n11         return new TypePair(this, that);\n12     }\n13     throw new IllegalStateException();\n14   }\n", "fixed_code": "  public TypePair getTypesUnderInequality(JSType that) {\n    if (that instanceof UnionType) {\n      TypePair p = that.getTypesUnderInequality(this);\n      return new TypePair(p.typeB, p.typeA);\n    }\n    switch (this.testForEquality(that)) {\n      case TRUE:\n        JSType noType = getNativeType(JSTypeNative.NO_TYPE);\n        return new TypePair(noType, noType);\n      case FALSE:\n      case UNKNOWN:\n        return new TypePair(this, that);\n    }\n    throw new IllegalStateException();\n  }\n"}
{"bug_id": "Compress-26", "buggy_code": "1     public static long skip(InputStream input, long numToSkip) throws IOException {\n2         long available = numToSkip;\n3         while (numToSkip > 0) {\n4             long skipped = input.skip(numToSkip);\n5             if (skipped == 0) {\n6                 break;\n7             }\n8             numToSkip -= skipped;\n9         }\n10         return available - numToSkip;\n11     }\n", "fixed_code": "    public static long skip(InputStream input, long numToSkip) throws IOException {\n        long available = numToSkip;\n        while (numToSkip > 0) {\n            long skipped = input.skip(numToSkip);\n            if (skipped == 0) {\n                break;\n            }\n            numToSkip -= skipped;\n        }\n        if (numToSkip > 0) {\n            byte[] skipBuf = new byte[SKIP_BUF_SIZE];\n            while (numToSkip > 0) {\n                int read = readFully(input, skipBuf, 0,\n                                     (int) Math.min(numToSkip, SKIP_BUF_SIZE));\n                if (read < 1) {\n                    break;\n                }\n                numToSkip -= read;\n            }\n        }\n        return available - numToSkip;\n    }\n"}
{"bug_id": "Compress-31", "buggy_code": "1     public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n2         long    result = 0;\n3         int     end = offset + length;\n4         int     start = offset;\n5         if (length < 2){\n6             throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n7         }\n8         if (buffer[start] == 0) {\n9             return 0L;\n10         }\n11         while (start < end){\n12             if (buffer[start] == ' '){\n13                 start++;\n14             } else {\n15                 break;\n16             }\n17         }\n18         byte trailer = buffer[end - 1];\n19         while (start < end && (trailer == 0 || trailer == ' ')) {\n20             end--;\n21             trailer = buffer[end - 1];\n22         }\n23         for ( ;start < end; start++) {\n24             final byte currentByte = buffer[start];\n25             if (currentByte == 0) {\n26                 break;\n27             }\n28             if (currentByte < '0' || currentByte > '7'){\n29                 throw new IllegalArgumentException(\n30                         exceptionMessage(buffer, offset, length, start, currentByte));\n31             }\n32             result = (result << 3) + (currentByte - '0'); \n33         }\n34         return result;\n35     }\n", "fixed_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); \n        }\n        return result;\n    }\n"}
{"bug_id": "Lang-12", "buggy_code": "1     public static String random(int count, int start, int end, boolean letters, boolean numbers,\n2                                 char[] chars, Random random) {\n3         if (count == 0) {\n4             return \"\";\n5         } else if (count < 0) {\n6             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n7         }\n8         if (start == 0 && end == 0) {\n9                 if (!letters && !numbers) {\n10                     end = Integer.MAX_VALUE;\n11                 } else {\n12                     end = 'z' + 1;\n13                     start = ' ';                \n14                 }\n15         }\n16         char[] buffer = new char[count];\n17         int gap = end - start;\n18         while (count-- != 0) {\n19             char ch;\n20             if (chars == null) {\n21                 ch = (char) (random.nextInt(gap) + start);\n22             } else {\n23                 ch = chars[random.nextInt(gap) + start];\n24             }\n25             if (letters && Character.isLetter(ch)\n26                     || numbers && Character.isDigit(ch)\n27                     || !letters && !numbers) {\n28                 if(ch >= 56320 && ch <= 57343) {\n29                     if(count == 0) {\n30                         count++;\n31                     } else {\n32                         buffer[count] = ch;\n33                         count--;\n34                         buffer[count] = (char) (55296 + random.nextInt(128));\n35                     }\n36                 } else if(ch >= 55296 && ch <= 56191) {\n37                     if(count == 0) {\n38                         count++;\n39                     } else {\n40                         buffer[count] = (char) (56320 + random.nextInt(128));\n41                         count--;\n42                         buffer[count] = ch;\n43                     }\n44                 } else if(ch >= 56192 && ch <= 56319) {\n45                     count++;\n46                 } else {\n47                     buffer[count] = ch;\n48                 }\n49             } else {\n50                 count++;\n51             }\n52         }\n53         return new String(buffer);\n54     }\n", "fixed_code": "    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else {\n                if (!letters && !numbers) {\n                    end = Integer.MAX_VALUE;\n                } else {\n                    end = 'z' + 1;\n                    start = ' ';                \n                }\n            }\n        }\n        char[] buffer = new char[count];\n        int gap = end - start;\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(gap) + start];\n            }\n            if (letters && Character.isLetter(ch)\n                    || numbers && Character.isDigit(ch)\n                    || !letters && !numbers) {\n                if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n"}
{"bug_id": "Compress-44", "buggy_code": "1     public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n2         this.checksum = checksum;\n3         this.in = in;\n4     }\n", "fixed_code": "    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n        if ( checksum == null ){\n            throw new NullPointerException(\"Parameter checksum must not be null\");\n        }\n        if ( in == null ){\n            throw new NullPointerException(\"Parameter in must not be null\");\n        }\n        this.checksum = checksum;\n        this.in = in;\n    }\n"}
{"bug_id": "Time-8", "buggy_code": "1     public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n2         if (hoursOffset == 0 && minutesOffset == 0) {\n3             return DateTimeZone.UTC;\n4         }\n5         if (hoursOffset < -23 || hoursOffset > 23) {\n6             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n7         }\n8         if (minutesOffset < 0 || minutesOffset > 59) {\n9             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n10         }\n11         int offset = 0;\n12         try {\n13             int hoursInMinutes = hoursOffset * 60;\n14             if (hoursInMinutes < 0) {\n15                 minutesOffset = hoursInMinutes - minutesOffset;\n16             } else {\n17                 minutesOffset = hoursInMinutes + minutesOffset;\n18             }\n19             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n20         } catch (ArithmeticException ex) {\n21             throw new IllegalArgumentException(\"Offset is too large\");\n22         }\n23         return forOffsetMillis(offset);\n24     }\n", "fixed_code": "    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n"}
{"bug_id": "Math-2", "buggy_code": "1     public double getNumericalMean() {\n2         return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n3     }\n", "fixed_code": "    public double getNumericalMean() {\n        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());\n    }\n"}
{"bug_id": "Csv-14", "buggy_code": "1     private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n2             final Appendable out, final boolean newRecord) throws IOException {\n3         boolean quote = false;\n4         int start = offset;\n5         int pos = offset;\n6         final int end = offset + len;\n7         final char delimChar = getDelimiter();\n8         final char quoteChar = getQuoteCharacter().charValue();\n9         QuoteMode quoteModePolicy = getQuoteMode();\n10         if (quoteModePolicy == null) {\n11             quoteModePolicy = QuoteMode.MINIMAL;\n12         }\n13         switch (quoteModePolicy) {\n14         case ALL:\n15             quote = true;\n16             break;\n17         case NON_NUMERIC:\n18             quote = !(object instanceof Number);\n19             break;\n20         case NONE:\n21             printAndEscape(value, offset, len, out);\n22             return;\n23         case MINIMAL:\n24             if (len <= 0) {\n25                 if (newRecord) {\n26                     quote = true;\n27                 }\n28             } else {\n29                 char c = value.charAt(pos);\n30                 if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n31                     quote = true;\n32                 } else if (c <= COMMENT) {\n33                     quote = true;\n34                 } else {\n35                     while (pos < end) {\n36                         c = value.charAt(pos);\n37                         if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n38                             quote = true;\n39                             break;\n40                         }\n41                         pos++;\n42                     }\n43                     if (!quote) {\n44                         pos = end - 1;\n45                         c = value.charAt(pos);\n46                         if (c <= SP) {\n47                             quote = true;\n48                         }\n49                     }\n50                 }\n51             }\n52             if (!quote) {\n53                 out.append(value, start, end);\n54                 return;\n55             }\n56             break;\n57         default:\n58             throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n59         }\n60         if (!quote) {\n61             out.append(value, start, end);\n62             return;\n63         }\n64         out.append(quoteChar);\n65         while (pos < end) {\n66             final char c = value.charAt(pos);\n67             if (c == quoteChar) {\n68                 out.append(value, start, pos + 1);\n69                 start = pos;\n70             }\n71             pos++;\n72         }\n73         out.append(value, start, pos);\n74         out.append(quoteChar);\n75     }\n", "fixed_code": "    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n        out.append(quoteChar);\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(value, start, pos + 1);\n                start = pos;\n            }\n            pos++;\n        }\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n"}
{"bug_id": "JacksonDatabind-85", "buggy_code": "1     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n2             BeanProperty property) throws JsonMappingException\n3     {\n4         if (property == null) {\n5             return this;\n6         }\n7         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n8         if (format == null) {\n9             return this;\n10         }\n11         JsonFormat.Shape shape = format.getShape();\n12         if (shape.isNumeric()) {\n13             return withFormat(Boolean.TRUE, null);\n14         }\n15                 if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n16                                 || format.hasLocale() || format.hasTimeZone()) {\n17                     TimeZone tz = format.getTimeZone();\n18                     final String pattern = format.hasPattern()\n19                                     ? format.getPattern()\n20                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n21             final Locale loc = format.hasLocale()\n22                             ? format.getLocale()\n23                             : serializers.getLocale();\n24                     SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n25                     if (tz == null) {\n26                         tz = serializers.getTimeZone();\n27                     }\n28             df.setTimeZone(tz);\n29             return withFormat(Boolean.FALSE, df);\n30         }\n31         return this;\n32     }\n", "fixed_code": "    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n        if (format.hasPattern()) {\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n                    : serializers.getTimeZone();\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n        final boolean hasLocale = format.hasLocale();\n        final boolean hasTZ = format.hasTimeZone();\n        final boolean asString = (shape == JsonFormat.Shape.STRING);\n        if (!hasLocale && !hasTZ && !asString) {\n            return this;\n        }\n        DateFormat df0 = serializers.getConfig().getDateFormat();\n        if (df0 instanceof StdDateFormat) {\n            StdDateFormat std = (StdDateFormat) df0;\n            if (format.hasLocale()) {\n                std = std.withLocale(format.getLocale());\n            }\n            if (format.hasTimeZone()) {\n                std = std.withTimeZone(format.getTimeZone());\n            }\n            return withFormat(Boolean.FALSE, std);\n        }\n        if (!(df0 instanceof SimpleDateFormat)) {\n            serializers.reportMappingProblem(\n\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; can not configure `Locale` or `TimeZone`\",\ndf0.getClass().getName());\n        }\n        SimpleDateFormat df = (SimpleDateFormat) df0;\n        if (hasLocale) {\n            df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n        } else {\n            df = (SimpleDateFormat) df.clone();\n        }\n        TimeZone newTz = format.getTimeZone();\n        boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n        if (changeTZ) {\n            df.setTimeZone(newTz);\n        }\n        return withFormat(Boolean.FALSE, df);\n    }\n"}
{"bug_id": "Compress-17", "buggy_code": "1     public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n2         long    result = 0;\n3         int     end = offset + length;\n4         int     start = offset;\n5         if (length < 2){\n6             throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n7         }\n8         if (buffer[start] == 0) {\n9             return 0L;\n10         }\n11         while (start < end){\n12             if (buffer[start] == ' '){\n13                 start++;\n14             } else {\n15                 break;\n16             }\n17         }\n18         byte trailer;\n19         trailer = buffer[end-1];\n20         if (trailer == 0 || trailer == ' '){\n21             end--;\n22         } else {\n23             throw new IllegalArgumentException(\n24                     exceptionMessage(buffer, offset, length, end-1, trailer));\n25         }\n26         trailer = buffer[end - 1];\n27         if (trailer == 0 || trailer == ' '){\n28             end--;\n29         }\n30         for ( ;start < end; start++) {\n31             final byte currentByte = buffer[start];\n32             if (currentByte < '0' || currentByte > '7'){\n33                 throw new IllegalArgumentException(\n34                         exceptionMessage(buffer, offset, length, start, currentByte));\n35             }\n36             result = (result << 3) + (currentByte - '0'); \n37         }\n38         return result;\n39     }\n", "fixed_code": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        trailer = buffer[end - 1];\n        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); \n        }\n        return result;\n    }\n"}
{"bug_id": "Math-88", "buggy_code": "1     protected RealPointValuePair getSolution() {\n2         double[] coefficients = new double[getOriginalNumDecisionVariables()];\n3         Integer basicRow =\n4             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n5         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n6         for (int i = 0; i < coefficients.length; i++) {\n7             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n8                 coefficients[i] =\n9                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n10                     (restrictToNonNegative ? 0 : mostNegative);\n11             if (basicRow != null) {\n12                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n13                     if (tableau.getEntry(basicRow, j) == 1) {\n14                          coefficients[i] = 0;\n15                     }\n16                 }\n17             }\n18         }\n19         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n20     }\n", "fixed_code": "    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        Set<Integer> basicRows = new HashSet<Integer>();\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n            if (basicRows.contains(basicRow)) {\n                coefficients[i] = 0;\n            } else {\n                basicRows.add(basicRow);\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n"}
{"bug_id": "Closure-91", "buggy_code": "1   public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n2     if (n.getType() == Token.FUNCTION) {\n3       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n4       if (jsDoc != null &&\n5           (jsDoc.isConstructor() ||\n6            jsDoc.isInterface() ||\n7            jsDoc.hasThisType() ||\n8            jsDoc.isOverride())) {\n9         return false;\n10       }\n11       int pType = parent.getType();\n12       if (!(pType == Token.BLOCK ||\n13             pType == Token.SCRIPT ||\n14             pType == Token.NAME ||\n15             pType == Token.ASSIGN ||\n16             pType == Token.STRING ||\n17             pType == Token.NUMBER)) {\n18         return false;\n19       }\n20     }\n21     if (parent != null && parent.getType() == Token.ASSIGN) {\n22       Node lhs = parent.getFirstChild();\n23       Node rhs = lhs.getNext();\n24       if (n == lhs) {\n25         if (assignLhsChild == null) {\n26           assignLhsChild = lhs;\n27         }\n28       } else {\n29         if (NodeUtil.isGet(lhs)) {\n30           if (lhs.getType() == Token.GETPROP &&\n31               lhs.getLastChild().getString().equals(\"prototype\")) {\n32             return false;\n33           }\n34           Node llhs = lhs.getFirstChild();\n35           if (llhs.getType() == Token.GETPROP &&\n36               llhs.getLastChild().getString().equals(\"prototype\")) {\n37             return false;\n38           }\n39         }\n40       }\n41     }\n42     return true;\n43   }\n", "fixed_code": "  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN ||\n            pType == Token.STRING ||\n            pType == Token.NUMBER)) {\n        return false;\n      }\n      Node gramps = parent.getParent();\n      if (NodeUtil.isObjectLitKey(parent, gramps)) {\n        JSDocInfo maybeLends = gramps.getJSDocInfo();\n        if (maybeLends != null &&\n            maybeLends.getLendsName() != null &&\n            maybeLends.getLendsName().endsWith(\".prototype\")) {\n          return false;\n        }\n      }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n      if (n == lhs) {\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        if (NodeUtil.isGet(lhs)) {\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.getType() == Token.GETPROP &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n"}
{"bug_id": "Closure-113", "buggy_code": "1   private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n2     Node left = n.getFirstChild();\n3     Node arg = left.getNext();\n4     if (verifyLastArgumentIsString(t, left, arg)) {\n5       String ns = arg.getString();\n6       ProvidedName provided = providedNames.get(ns);\n7       if (provided == null || !provided.isExplicitlyProvided()) {\n8         unrecognizedRequires.add(\n9             new UnrecognizedRequire(n, ns, t.getSourceName()));\n10       } else {\n11         JSModule providedModule = provided.explicitModule;\n12         Preconditions.checkNotNull(providedModule);\n13         JSModule module = t.getModule();\n14         if (moduleGraph != null &&\n15             module != providedModule &&\n16             !moduleGraph.dependsOn(module, providedModule)) {\n17           compiler.report(\n18               t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n19                   providedModule.getName(),\n20                   module.getName()));\n21         }\n22       }\n23       maybeAddToSymbolTable(left);\n24       maybeAddStringNodeToSymbolTable(arg);\n25       if (provided != null) {\n26         parent.detachFromParent();\n27         compiler.reportCodeChange();\n28       }\n29     }\n30   }\n", "fixed_code": "  private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyLastArgumentIsString(t, left, arg)) {\n      String ns = arg.getString();\n      ProvidedName provided = providedNames.get(ns);\n      if (provided == null || !provided.isExplicitlyProvided()) {\n        unrecognizedRequires.add(\n            new UnrecognizedRequire(n, ns, t.getSourceName()));\n      } else {\n        JSModule providedModule = provided.explicitModule;\n        Preconditions.checkNotNull(providedModule);\n        JSModule module = t.getModule();\n        if (moduleGraph != null &&\n            module != providedModule &&\n            !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(\n              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                  providedModule.getName(),\n                  module.getName()));\n        }\n      }\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n      if (provided != null || requiresLevel.isOn()) {\n        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }\n"}
{"bug_id": "Closure-111", "buggy_code": "1         protected JSType caseTopType(JSType topType) {\n2           return topType;\n3         }\n", "fixed_code": "        protected JSType caseTopType(JSType topType) {\n          return topType.isAllType() ?\n              getNativeType(ARRAY_TYPE) : topType;\n        }\n"}
{"bug_id": "Closure-12", "buggy_code": "1   private boolean hasExceptionHandler(Node cfgNode) {\n2     return false;\n3   }\n", "fixed_code": "  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n    return false;\n  }\n"}
{"bug_id": "Jsoup-70", "buggy_code": "1     static boolean preserveWhitespace(Node node) {\n2         if (node != null && node instanceof Element) {\n3             Element el = (Element) node;\n4                 if (el.tag.preserveWhitespace())\n5                     return true;\n6                 else\n7                     return el.parent() != null && el.parent().tag.preserveWhitespace();\n8         }\n9         return false;\n10     }\n", "fixed_code": "    static boolean preserveWhitespace(Node node) {\n        if (node != null && node instanceof Element) {\n            Element el = (Element) node;\n            int i = 0;\n            do {\n                if (el.tag.preserveWhitespace())\n                    return true;\n                el = el.parent();\n                i++;\n            } while (i < 6 && el != null);\n        }\n        return false;\n    }\n"}
{"bug_id": "Closure-66", "buggy_code": "1   public void visit(NodeTraversal t, Node n, Node parent) {\n2     JSType childType;\n3     JSType leftType, rightType;\n4     Node left, right;\n5     boolean typeable = true;\n6     switch (n.getType()) {\n7       case Token.NAME:\n8         typeable = visitName(t, n, parent);\n9         break;\n10       case Token.LP:\n11         if (parent.getType() != Token.FUNCTION) {\n12           ensureTyped(t, n, getJSType(n.getFirstChild()));\n13         } else {\n14           typeable = false;\n15         }\n16         break;\n17       case Token.COMMA:\n18         ensureTyped(t, n, getJSType(n.getLastChild()));\n19         break;\n20       case Token.TRUE:\n21       case Token.FALSE:\n22         ensureTyped(t, n, BOOLEAN_TYPE);\n23         break;\n24       case Token.THIS:\n25         ensureTyped(t, n, t.getScope().getTypeOfThis());\n26         break;\n27       case Token.REF_SPECIAL:\n28         ensureTyped(t, n);\n29         break;\n30       case Token.GET_REF:\n31         ensureTyped(t, n, getJSType(n.getFirstChild()));\n32         break;\n33       case Token.NULL:\n34         ensureTyped(t, n, NULL_TYPE);\n35         break;\n36       case Token.NUMBER:\n37         ensureTyped(t, n, NUMBER_TYPE);\n38         break;\n39       case Token.STRING:\n40         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n41           ensureTyped(t, n, STRING_TYPE);\n42         }\n43         break;\n44       case Token.GET:\n45       case Token.SET:\n46         break;\n47       case Token.ARRAYLIT:\n48         ensureTyped(t, n, ARRAY_TYPE);\n49         break;\n50       case Token.REGEXP:\n51         ensureTyped(t, n, REGEXP_TYPE);\n52         break;\n53       case Token.GETPROP:\n54         visitGetProp(t, n, parent);\n55         typeable = !(parent.getType() == Token.ASSIGN &&\n56                      parent.getFirstChild() == n);\n57         break;\n58       case Token.GETELEM:\n59         visitGetElem(t, n);\n60         typeable = false;\n61         break;\n62       case Token.VAR:\n63         visitVar(t, n);\n64         typeable = false;\n65         break;\n66       case Token.NEW:\n67         visitNew(t, n);\n68         typeable = true;\n69         break;\n70       case Token.CALL:\n71         visitCall(t, n);\n72         typeable = !NodeUtil.isExpressionNode(parent);\n73         break;\n74       case Token.RETURN:\n75         visitReturn(t, n);\n76         typeable = false;\n77         break;\n78       case Token.DEC:\n79       case Token.INC:\n80         left = n.getFirstChild();\n81         validator.expectNumber(\n82             t, left, getJSType(left), \"increment/decrement\");\n83         ensureTyped(t, n, NUMBER_TYPE);\n84         break;\n85       case Token.NOT:\n86         ensureTyped(t, n, BOOLEAN_TYPE);\n87         break;\n88       case Token.VOID:\n89         ensureTyped(t, n, VOID_TYPE);\n90         break;\n91       case Token.TYPEOF:\n92         ensureTyped(t, n, STRING_TYPE);\n93         break;\n94       case Token.BITNOT:\n95         childType = getJSType(n.getFirstChild());\n96         if (!childType.matchesInt32Context()) {\n97           report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n98               childType.toString());\n99         }\n100         ensureTyped(t, n, NUMBER_TYPE);\n101         break;\n102       case Token.POS:\n103       case Token.NEG:\n104         left = n.getFirstChild();\n105         validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n106         ensureTyped(t, n, NUMBER_TYPE);\n107         break;\n108       case Token.EQ:\n109       case Token.NE: {\n110         leftType = getJSType(n.getFirstChild());\n111         rightType = getJSType(n.getLastChild());\n112         JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n113         JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n114         TernaryValue result =\n115             leftTypeRestricted.testForEquality(rightTypeRestricted);\n116         if (result != TernaryValue.UNKNOWN) {\n117           if (n.getType() == Token.NE) {\n118             result = result.not();\n119           }\n120           report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n121               rightType.toString(), result.toString());\n122         }\n123         ensureTyped(t, n, BOOLEAN_TYPE);\n124         break;\n125       }\n126       case Token.SHEQ:\n127       case Token.SHNE: {\n128         leftType = getJSType(n.getFirstChild());\n129         rightType = getJSType(n.getLastChild());\n130         JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n131         JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n132         if (!leftTypeRestricted.canTestForShallowEqualityWith(\n133                 rightTypeRestricted)) {\n134           report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n135               rightType.toString());\n136         }\n137         ensureTyped(t, n, BOOLEAN_TYPE);\n138         break;\n139       }\n140       case Token.LT:\n141       case Token.LE:\n142       case Token.GT:\n143       case Token.GE:\n144         leftType = getJSType(n.getFirstChild());\n145         rightType = getJSType(n.getLastChild());\n146         if (rightType.isNumber()) {\n147           validator.expectNumber(\n148               t, n, leftType, \"left side of numeric comparison\");\n149         } else if (leftType.isNumber()) {\n150           validator.expectNumber(\n151               t, n, rightType, \"right side of numeric comparison\");\n152         } else if (leftType.matchesNumberContext() &&\n153                    rightType.matchesNumberContext()) {\n154         } else {\n155           String message = \"left side of comparison\";\n156           validator.expectString(t, n, leftType, message);\n157           validator.expectNotNullOrUndefined(\n158               t, n, leftType, message, getNativeType(STRING_TYPE));\n159           message = \"right side of comparison\";\n160           validator.expectString(t, n, rightType, message);\n161           validator.expectNotNullOrUndefined(\n162               t, n, rightType, message, getNativeType(STRING_TYPE));\n163         }\n164         ensureTyped(t, n, BOOLEAN_TYPE);\n165         break;\n166       case Token.IN:\n167         left = n.getFirstChild();\n168         right = n.getLastChild();\n169         leftType = getJSType(left);\n170         rightType = getJSType(right);\n171         validator.expectObject(t, n, rightType, \"'in' requires an object\");\n172         validator.expectString(t, left, leftType, \"left side of 'in'\");\n173         ensureTyped(t, n, BOOLEAN_TYPE);\n174         break;\n175       case Token.INSTANCEOF:\n176         left = n.getFirstChild();\n177         right = n.getLastChild();\n178         leftType = getJSType(left);\n179         rightType = getJSType(right).restrictByNotNullOrUndefined();\n180         validator.expectAnyObject(\n181             t, left, leftType, \"deterministic instanceof yields false\");\n182         validator.expectActualObject(\n183             t, right, rightType, \"instanceof requires an object\");\n184         ensureTyped(t, n, BOOLEAN_TYPE);\n185         break;\n186       case Token.ASSIGN:\n187         visitAssign(t, n);\n188         typeable = false;\n189         break;\n190       case Token.ASSIGN_LSH:\n191       case Token.ASSIGN_RSH:\n192       case Token.ASSIGN_URSH:\n193       case Token.ASSIGN_DIV:\n194       case Token.ASSIGN_MOD:\n195       case Token.ASSIGN_BITOR:\n196       case Token.ASSIGN_BITXOR:\n197       case Token.ASSIGN_BITAND:\n198       case Token.ASSIGN_SUB:\n199       case Token.ASSIGN_ADD:\n200       case Token.ASSIGN_MUL:\n201       case Token.LSH:\n202       case Token.RSH:\n203       case Token.URSH:\n204       case Token.DIV:\n205       case Token.MOD:\n206       case Token.BITOR:\n207       case Token.BITXOR:\n208       case Token.BITAND:\n209       case Token.SUB:\n210       case Token.ADD:\n211       case Token.MUL:\n212         visitBinaryOperator(n.getType(), t, n);\n213         break;\n214       case Token.DELPROP:\n215         if (!isReference(n.getFirstChild())) {\n216           report(t, n, BAD_DELETE);\n217         }\n218         ensureTyped(t, n, BOOLEAN_TYPE);\n219         break;\n220       case Token.CASE:\n221         JSType switchType = getJSType(parent.getFirstChild());\n222         JSType caseType = getJSType(n.getFirstChild());\n223         validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n224         typeable = false;\n225         break;\n226       case Token.WITH: {\n227         Node child = n.getFirstChild();\n228         childType = getJSType(child);\n229         validator.expectObject(\n230             t, child, childType, \"with requires an object\");\n231         typeable = false;\n232         break;\n233       }\n234       case Token.FUNCTION:\n235         visitFunction(t, n);\n236         break;\n237       case Token.LABEL:\n238       case Token.LABEL_NAME:\n239       case Token.SWITCH:\n240       case Token.BREAK:\n241       case Token.CATCH:\n242       case Token.TRY:\n243       case Token.SCRIPT:\n244       case Token.EXPR_RESULT:\n245       case Token.BLOCK:\n246       case Token.EMPTY:\n247       case Token.DEFAULT:\n248       case Token.CONTINUE:\n249       case Token.DEBUGGER:\n250       case Token.THROW:\n251         typeable = false;\n252         break;\n253       case Token.DO:\n254       case Token.FOR:\n255       case Token.IF:\n256       case Token.WHILE:\n257         typeable = false;\n258         break;\n259       case Token.AND:\n260       case Token.HOOK:\n261       case Token.OBJECTLIT:\n262       case Token.OR:\n263         if (n.getJSType() != null) { \n264           ensureTyped(t, n);\n265         } else {\n266           if ((n.getType() == Token.OBJECTLIT)\n267               && (parent.getJSType() instanceof EnumType)) {\n268             ensureTyped(t, n, parent.getJSType());\n269           } else {\n270             ensureTyped(t, n);\n271           }\n272         }\n273         if (n.getType() == Token.OBJECTLIT) {\n274           for (Node key : n.children()) {\n275             visitObjLitKey(t, key, n);\n276           }\n277         }\n278         break;\n279       default:\n280         report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n281         ensureTyped(t, n);\n282         break;\n283     }\n284     typeable = typeable && !inExterns;\n285     if (typeable) {\n286       doPercentTypedAccounting(t, n);\n287     }\n288     checkNoTypeCheckSection(n, false);\n289   }\n", "fixed_code": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable = true;\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n      case Token.LP:\n        if (parent.getType() != Token.FUNCTION) {\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\n        } else {\n          typeable = false;\n        }\n        break;\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n      case Token.REF_SPECIAL:\n        ensureTyped(t, n);\n        break;\n      case Token.GET_REF:\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\n        break;\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n      case Token.STRING:\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, STRING_TYPE);\n        } else {\n          typeable = false;\n        }\n        break;\n      case Token.GET:\n      case Token.SET:\n        break;\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.getType() == Token.ASSIGN &&\n                     parent.getFirstChild() == n);\n        break;\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        typeable = false;\n        break;\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n      case Token.NEW:\n        visitNew(t, n);\n        typeable = true;\n        break;\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !NodeUtil.isExpressionNode(parent);\n        break;\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n      case Token.EQ:\n      case Token.NE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        TernaryValue result =\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\n        if (result != TernaryValue.UNKNOWN) {\n          if (n.getType() == Token.NE) {\n            result = result.not();\n          }\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n      case Token.SHEQ:\n      case Token.SHNE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                rightTypeRestricted)) {\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n              rightType.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n        } else {\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        validator.expectString(t, left, leftType, \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n        validator.expectAnyObject(\n            t, left, leftType, \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n      case Token.DELPROP:\n        if (!isReference(n.getFirstChild())) {\n          report(t, n, BAD_DELETE);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(\n            t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { \n          ensureTyped(t, n);\n        } else {\n          if ((n.getType() == Token.OBJECTLIT)\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.getType() == Token.OBJECTLIT) {\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n);\n          }\n        }\n        break;\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n    typeable = typeable && !inExterns;\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n  }\n"}
{"bug_id": "Closure-23", "buggy_code": "1   private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n2     Node parent = n.getParent();\n3     if (isAssignmentTarget(n)) {\n4       return n;\n5     }\n6     if (!right.isNumber()) {\n7       return n;\n8     }\n9     double index = right.getDouble();\n10     int intIndex = (int) index;\n11     if (intIndex != index) {\n12       error(INVALID_GETELEM_INDEX_ERROR, right);\n13       return n;\n14     }\n15     if (intIndex < 0) {\n16       error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n17       return n;\n18     }\n19     Node current = left.getFirstChild();\n20     Node elem = null;\n21     for (int i = 0; current != null && i < intIndex; i++) {\n22         elem = current;\n23       current = current.getNext();\n24     }\n25     if (elem == null) {\n26       error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n27       return n;\n28     }\n29     if (elem.isEmpty()) {\n30       elem = NodeUtil.newUndefinedNode(elem);\n31     } else {\n32       left.removeChild(elem);\n33     }\n34     n.getParent().replaceChild(n, elem);\n35     reportCodeChange();\n36     return elem;\n37   }\n", "fixed_code": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    if (isAssignmentTarget(n)) {\n      return n;\n    }\n    if (!right.isNumber()) {\n      return n;\n    }\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n    Node current = left.getFirstChild();\n    Node elem = null;\n    for (int i = 0; current != null; i++) {\n      if (i != intIndex) {\n        if (mayHaveSideEffects(current)) {\n          return n;\n        }\n      } else {\n        elem = current;\n      }\n      current = current.getNext();\n    }\n    if (elem == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n    if (elem.isEmpty()) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      left.removeChild(elem);\n    }\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }\n"}
